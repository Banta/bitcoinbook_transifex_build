<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.7" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="bitcoin_network_ch06">Bitcoinネットワーク</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_peer_to_peer_ネットワーク設計">Peer-to-Peer ネットワーク設計</h3>
<div class="paragraph"><p>Bitcoinはインターネット上のpeer-to-peerネットワークとして構築されています。peer-to-peer、またはP2Pという言葉は、ネットワークに参加しているコンピュータがそれぞれ同等の立場を持ち、"特別な"ノードがなく、全てのノードがサービス負荷を負担し合っていることを指します。ネットワークノードは"フラット"なトポロジーを持つメッシュネットワークの中で互いに繋がっています。ここにサーバ、どこかに中央を持つサービス、ネットワーク内の階層はありません。peer-to-peerネットワーク内のノードは、サービスを提供もしまた同時に消費もすることで、ネットワークへ参加することのインセンティブとしての相互利益を保っています。peer-to-peerネットワークは本質的に活発であり、非中央的でオープンです。P2Pネットワークの代表的な例は初期インターネットそのもので、IPネットワーク上のノードは全て平等でした。今日のインターネットの構造はより階層的になりましたが、インターネットプロトコルはまだフラットトポロジーのエッセンスを保っています。Bitcoinが現れる前にP2Pテクノロジーを使った最も大きく最も成功したサービスはファイル共有であり、パイオニアとしてはNapster、最近の発展の牽引としてはBitTorrentなどがあります。</p></div>
<div class="paragraph"><p>Bitcoin&#8217;s P2P network architecture is much more than a topology choice. Bitcoin is a peer-to-peer digital cash system by design, and the network architecture is both a reflection and a foundation of that core characteristic. Decentralization of control is a core design principle and that can only be achieved and maintained by a flat, decentralized P2P consensus network.</p></div>
<div class="paragraph"><p>"Bitcoinネットワーク"という言葉は、Bitcoin P2Pプロトコルが動作しているBitcoinノード全体を指します。Bitcoin P2Pプロトコルに加えて、 Stratumのような他のプロトコルもあり、Stratumはマイニング、軽量またはモバイルのウォレットに使われたりします。これらの他のプロトコルは、Bitcoin P2Pプロトコルを使っているBitcoinネットワークにアクセスするサーバをルーティングするゲートウェイで使われています。また、これにより他のプロトコルで動くノードにネットワークを拡げることができます。例えば、StratumサーバはStratumマイニングノードをStratumプロトコルを通してメインのBitcoinネットワークに接続させ、StratumプロトコルとBitcoin P2Pプロトコルの橋渡しをします。Bitcoin P2Pプロトコル、プールマイニングプロトコル、Stratumプロトコル、およびBitcoinシステムの各要素を繋げるその他の関連したプロトコルを全て含む全ネットワークを"拡張されたBitcoinネットワーク"という言葉で表します。</p></div>
</div>
<div class="sect2">
<h3 id="_ノードタイプと役割">ノードタイプと役割</h3>
<div class="paragraph"><p>Bitcoin P2Pネットワーク内のノードは平等ではありますが、これらはいくつかの役割に分かれています。Bitcoinノードは、ルーティング、ブロックチェーンデータベース、マイニング、ウォレットという機能の集合体です。これらの機能４つを全て持つfull-nodeが<a href="#full_node_reference">[full_node_reference]</a>図で示されています。</p></div>
<div class="imageblock" id="full_node_reference">
<div class="content">
<img src="images/msbt_0601.png" alt="FullNodeReferenceClient_Small" />
</div>
<div class="title">Figure 1. ４種類のBitcoinネットワークノード機能: ウォレット、マイナー、フルブロックチェーンデータベース、ネットワークルーティング</div>
</div>
<div class="paragraph"><p>全てのノードはBitcoinネットワークに参加するためにルーティング機能を必ず持っていて、その他の機能は持っていたり持っていなかったりします。全てのノードはトランザクションとブロックを検証して伝搬し、その他のピアを発見してコネクションを常に保っています。<a href="#full_node_reference">[full_node_reference]</a>図のfull-node例では、ルーティング機能を"Network Routing Node"と書いてあるオレンジの円で示しています。</p></div>
<div class="paragraph"><p>full-nodeと呼ばれるいくつかのノードは、完全で最新のブロックチェーンの管理もしています。full-nodeは外部への参照をすることなく閉じられた形で匿名的かつ厳然にトランザクションを検証します。いくつかのノードはブロックチェーンの一部の管理のみを行っており、 <em>simplified payment verification</em> または SPV と呼ばれている方法でトランザクションを検証します。これらのノードはSPVまたは軽量ノードと呼ばれています。さきほどの図にあったfull-node例では、full-nodeのブロックチェーンデータベースを"Full Blockchain"と書いてあるブルーの円で示しています。<a href="#bitcoin_network">[bitcoin_network]</a>図では、SPVノードがブルーの円がない形で描かれており、これはブロックチェーンの完全なコピーを持たないということを表しています。</p></div>
<div class="paragraph"><p>マイニングノードは新しいブロックを作り出す競争をしており、proof-of-workアルゴリズムを解くための特別なハードウェアを動作させて行っています。いくつかのマイニングノードはfull-nodeでもあり、ブロックチェーンの完全なコピーを管理しています。一方それ以外はマイニングプールに参加している軽量ノードであり、full-nodeを管理しているプールサーバに依存しています。</p></div>
<div class="paragraph"><p>ユーザウォレットは一部がfull nodeになっており、通常デスクトップBitcoinクライアントという形でfull nodeになっています。スマートフォンなどリソースが限られているデバイスでは多くのユーザウォレットがSPVノードになっています。ウォレット機能は<a href="#full_node_reference">[full_node_reference]</a>図にある"Wallet"と書かれたグリーンの円で示されています。</p></div>
<div class="paragraph"><p>Bitcoin P2Pプロトコル上の主なノードタイプに加えて、その他のプロトコルで動作しているノードもあります。例えば、マイニングプール特化型プロトコルや軽量クライアントアクセスプロトコルなどです。</p></div>
<div class="paragraph"><p><a href="#node_type_ledgend">[node_type_ledgend]</a>は拡張されたBitcoinネットワーク上の主なノードタイプを示しています。</p></div>
</div>
<div class="sect2">
<h3 id="_拡張されたbitcoinネットワーク">拡張されたBitcoinネットワーク</h3>
<div class="paragraph"><p>Bitcoin P2Pプロトコルが動作しているメインのBitcoinネットワークは7000から10000個のノードから構成されており、それぞれBitcoin参照クライアント(Bitcoin Core)のいろいろなバージョンが動作しています。また、数百個のノードはBitcoin P2Pプロトコルとは別の BitcoinJ、Libbitcoin、およびbtcdなどの実装が動作しています。Bitcoin P2Pネットワーク上の少数のノードはマイニングノードも兼ねていて、マイニング、トランザクション検証、新ブロック生成の競争をしています。いろいろな大きな企業は、Bitcoin Coreクライアントをベースとするfull-nodeクライアントを使ってBitcoinネットワークと通信をしており、これらはブロックチェーンの完全なコピーやネットワークノードとしての機能を持っているもののマイニングやウォレットの機能は持ちません。これらのノードはネットワークエッジルーターとして機能しており、いろいろなその他のサービス(交換所、ウォレット、ブロックエクプローラ、決済システム)を構築できるようにしています。</p></div>
<div class="paragraph"><p>以前説明したように拡張されたBitcoinネットワークはBitcoin P2Pプロトコルが動作しているネットワークを含んでおり、また一部分に特化したプロトコルで動作しているノードもあります。メインのBitcoin P2Pネットワークに接続しているノードは、多くのプールサーバや、その他のプロトコルで動作しているノードに接続しているプロトコルゲートウェイです。</p></div>
<div class="paragraph"><p><a href="#bitcoin_network">[bitcoin_network]</a>図は拡張されたBitcoinネットワークを示しており、ノードのいろいろなタイプ、ゲートウェイサーバ、エッジルーター、およびウォレットクライアント、またそれぞれが接続し合&gt;うために使っているいろいろなプロトコルを示しています。</p></div>
<div class="imageblock" id="node_type_ledgend">
<div class="content">
<img src="images/msbt_0602.png" alt="BitcoinNodeTypes" />
</div>
<div class="title">Figure 2. 拡張されたBitcoinネットワーク上の様々なノードタイプ</div>
</div>
<div class="imageblock" id="bitcoin_network">
<div class="content">
<img src="images/msbt_0603.png" alt="BitcoinNetwork" />
</div>
<div class="title">Figure 3. いろいろなノードタイプやゲートウェイ、プロトコルを表した拡張されたBitcoinネットワーク全体図</div>
</div>
</div>
<div class="sect2">
<h3 id="_ネットワークをどのように発見するのか">ネットワークをどのように発見するのか</h3>
<div class="paragraph"><p>新しいノードが立ち上がったとき、Bitcoinネットワークに参加するには他のBitcoinノードを見つけなければいけません。このプロセスを始めるために、新しいノードは少なくとも１個のノードを見つけ接続しなければいけません。他のノードの地理的な位置は関係ありません。というのは、Bitcoinネットワークのトポロジーは地理と関連づけて決められてはいないからです。このため、ランダムにノードが選ばれ得ます。</p></div>
<div class="paragraph"><p>知られているピアに接続するために、ノードはTCPコネクションを確立し、通常8333番ポート(一般にBitcoinによって使われているポート)または提供されているなら代替のポートを使います。コネクションを確立すると、ノードは <tt>version</tt> messageを送信することで"ハンドシェイク"を始めます(<a href="#network_handshake">[network_handshake]</a>参照)。version messageはと、以下のような基本的な識別情報を含んでいるものです。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>PROTOCOL_VERSION</tt>
</dt>
<dd>
<p>
クライアントが"会話をする"Bitcoin P2Pプロトコルバージョンを示す定数 (例えば 70002)
</p>
</dd>
<dt class="hdlist1">
<tt>nLocalServices</tt>
</dt>
<dd>
<p>
ノードがサポートしているローカルサービスのリスト、現状 <tt>NODE_NETWORK</tt> のみ
</p>
</dd>
<dt class="hdlist1">
<tt>nTime</tt>
</dt>
<dd>
<p>
現在時刻
</p>
</dd>
<dt class="hdlist1">
<tt>addrYou</tt>
</dt>
<dd>
<p>
このノードから見えるリモートノードのIP address
</p>
</dd>
<dt class="hdlist1">
<tt>addrMe</tt>
</dt>
<dd>
<p>
ローカルノードのIP address
</p>
</dd>
<dt class="hdlist1">
<tt>subver</tt>
</dt>
<dd>
<p>
このノード上で動作しているソフトウェアの種類を示すサブバージョン (例えば "/Satoshi:0.9.2.1/")+
</p>
</dd>
<dt class="hdlist1">
<tt>BestHeight</tt>
</dt>
<dd>
<p>
このノードのブロックチェーンのブロック高
</p>
</dd>
</dl></div>
<div class="paragraph"><p>(<tt>version</tt> network messageの例については <a href="http://bit.ly/1qlsC7w">GitHub</a> 参照)</p></div>
<div class="qlist"><ol>
<li>
<p><em>
ピアノードはコネクションを承認し確立するために<tt>verack+を返します。場合によっては、もしコネクションのお返しにピアとして接続し直す場合は自身の +version</tt>  messageを送ります。 ??
</em></p>
<p>
新しいノードはどのようにしてピアを見つけるのでしょうか？最初の方法はたくさんの"DNSシード"を使ってDNSにクエリを投げることです。DNSシードはBitcoinノードのIPアドレスリストを提供するDNSサーバです。DNSシードのうちいくつかは安定的にリクエストを受け付けているBitcoinノードの静的なIPアドレスを返却しています。また、いくつかのDNSシードは、クローラや長期的に稼働しているBitcoinノードによって集められたBitcoinノードのリストからランダムにいくつかを選んで返却するカスタマイズされたBIND(Berkeley Internet Name Daemon)で実装されています。Bitcoin Coreクライアントは５つのDNSシードを含んでいます。これらは所有者やDNSシードの実装が多様になるように構成され、確実に初期状態構築プロセスが実行できるようになっています。Bitcoin Coreクライアントでは、DNSシードを使うかどうかを <tt>-dnsseed</tt> オプションでコントロールできるようになっています(1がデフォルトで、デフォルトでDNSシードを使用するようになっています)。
</p>
</li>
</ol></div>
<div class="paragraph"><p>DNSシードを使わない場合、Bitcoinネットワークについて何も知らない初期状態構築中のノードには少なくとも１つのBitcoinノードのIPアドレスが与えられなければいけません。その後、このノードはさらに導入手続きを進めて他のノードとのコネクションを確立します。コマンドラインオプション <tt>-seednode</tt> は一番最初のシードBitcoinノードとコネクションを確立するために使われます。導入手続きで最初のシードノードが使われた後、Bitcoinクライアントはこのシードノードとのコネクションを切り、新たに発見したピアを使うようになります。</p></div>
<div class="imageblock" id="network_handshake">
<div class="content">
<img src="images/msbt_0604.png" alt="NetworkHandshake" />
</div>
<div class="title">Figure 4. ピア同士の最初のハンドシェイク</div>
</div>
<div class="paragraph"><p>一度１つまたはそれ以上のコネクションを確立すると、新しいノードは <tt>addr</tt> messageという自身のIP addressが含まれた情報を隣接ノードに送信します。隣接ノードは次々に <tt>addr</tt> messageを彼らの近くのノードに転送し、確実に新しく接続されたノードがwell knownになるようにします。また、新しく接続されたノードは <tt>getaddr</tt> を隣接ノードに送ることができ、他のピアのIP addressリストを返してもらうようにお願いすることもできます。そうすれば、ノードは接続するピアを新たに見つけることができ、その存在を他のノードに知らせることができるのです。<a href="#address_propagation">[address_propagation]</a>図はアドレスを発見する手順を示しています。</p></div>
<div class="imageblock" id="address_propagation">
<div class="content">
<img src="images/msbt_0605.png" alt="AddressPropagation" />
</div>
<div class="title">Figure 5. 自身のIPアドレスの伝搬と他のIPアドレスの発見</div>
</div>
<div class="paragraph"><p>ノードは２、３個の異なったピアと接続し、Bitcoinネットワークへの多様なパスを確立しなければいけません。このパスは信頼できるものではありません(ノードは連絡なく通信が切れたり復活したりする)。このため、他のノードの初期状態構築時にアシストするという目的だけでなく、古いコネクションを失ったときのためにもノードは常に新しいノードを見つけ続けなければいけません。最初に接続するノードはそのピアノードに導入手順を提供するため、初期状態構築をするためには少なくとも１個のコネクションがなければなりません。初期状態構築を終えた後ノードは最も最近うまくコネクションを張れたピアを覚えておき、リブートしたときにすばやく覚えておいたピアとコネクションを張ります。以前繋がっていたどのピアもコネクションリクエストに答えなければ、そのノードは再度シードノードを使って初期状態構築を行うことができます。</p></div>
<div class="paragraph"><p>Bitcoin Coreクライアントが動作しているノードでは、 <tt>getpeerinfo</tt> のコマンドを使ってピアコネクションを表示することができます。</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>自動的に行われるピア管理ではなく特定のピアのIP addressを指定するために <tt>-connect=&lt;IPAddress&gt;</tt> オプションが用意されていて、１つまたは複数のIP addressを指定できます。このオプションが使われると、自動的にピアを見つけたりすることはせずにノードは選択されたIP addressにしか接続しないようになります。</p></div>
<div class="paragraph"><p>コネクション上に何もトラフィックがない場合、ノードは定期的にコネクション維持のためメッセージを送ります。90分以上何の通信もしなかったコネクションがあった場合、ノードはコネクションが切れたとみなし新しいピアを探し始めます。このように、Bitcoinネットワークは常に一時的なノードやネットワークの問題を調整しながら、中央のコントロールなしに必要に応じて有機的に成長または縮小を繰り返します。</p></div>
</div>
<div class="sect2">
<h3 id="_full_nodes">Full Nodes</h3>
<div class="paragraph"><p>full nodeは全てのトランザクションを持っている完全なブロックチェーンを管理しているノードです。もっと正確に言うと、full nodeはおそらく"フルブロックチェーンノード"と呼ばれるべきです。Bitcoinの初期の頃全てのノードはfull nodeでしたが、現在はBitcoin Coreがフルブロックチェーンノードです。これは２年前からBitcoinクライアントの新しい形が導入されてきたためです。新しい形というのは完全なブロックチェーンを管理する形ではなく軽量クライアントとして動かすという形です。次の節でこの詳細を説明します。</p></div>
<div class="paragraph"><p>フルブロックチェーンノードは完全で最新のブロックチェーンコピーを管理しており、これらノードは独立に最初のブロック(起源ブロック)から最新のブロックまでを構築し検証します。また、フルブロックチェーンノードは他のノードや情報源に頼ることなく独立的かつ厳然にどんなトランザクションでも検証します。フルブロックチェーンノードはBitcoinネットワークに頼ることで新しいトランザクションのブロックをBitcoinネットワークから受け取り、それらを検証した後ブロックチェーンのローカルコピーに追加していきます。</p></div>
<div class="paragraph"><p>フルブロックチェーンノードを動作させてみると分かるように、他のノードを全く信頼することも頼ることもなく全てのトランザクションの検証が独立に進められていきます。フルブロックチェーンを保持するために20GB強のストレージが必要であるため、フルブロックチェーンノードを走らせるには多くのディスク容量とBitcoinネットワークからブロックチェーンをダウンロードするための２、３日の時間が必要です。</p></div>
<div class="paragraph"><p>いくつかのフルブロックチェーンBitcoinクライアントの代替実装があり、別のプログラミング言語やソフトウェア設計で構築されています。しかし、主な実装はBitcoin参照クライアント Bitcoin Coreであり、Satoshiクライアントと呼ばれています。Bitcoinネットワーク上の90%以上のノードがBitcoin Coreのいろいろなバージョンで動作しています。このバージョンは+/Satoshi:0.8.6/+のように表示され、"Satoshi"のあとに、前に見た+getpeerinfo+コマンドの結果に出てくるsubversionが付加された形になっています。</p></div>
</div>
<div class="sect2">
<h3 id="_inventory_の交換">"Inventory"の交換</h3>
<div class="paragraph"><p>full nodeがピアと接続して最初にやることは、完全なブロックチェーンを構築することです。もしノードが新しくできたもので全くブロックチェーンを持っていなければ、Bitcoin Coreに埋め込まれている１個のブロック、起源ブロック、しか知りません。このため、新しいノードは数十万ブロックものブロックをBitcoinネットワークからダウンロード＆同期して、フルブロックチェーンを再構築しなければいけません。</p></div>
<div class="paragraph"><p>ブロックチェーンの同期プロセスは、<tt>version</tt> messageから始まります。というのは、<tt>version</tt> messageにノードの現在のブロックチェーン高(ブロック数)を示す<tt>BestHeight+が含まれているからです。ノードは+version</tt> messagesを見て相手のピアが何ブロック保持しているかを知ることで、自身のブロックチェーンと比較できるようになります。次にピアノードは互いにローカルブロックチェーンのトップブロックハッシュ(フィンガープリント)を含む <tt>getblocks</tt> messageを交換します。ピアのうちの一つは、トップブロックのハッシュと受け取ったハッシュは違っても、古いブロックのハッシュと受け取ったハッシュが一致することが分かったとすると、このことから自身の持っているブロックチェーンが相手のピアよりも長いということを知ることができます。</p></div>
<div class="paragraph"><p>より長いブロックチェーンを持っているピアは他のノードよりも多くのブロックを持っており、どのブロックを他のノードが欲しているかを特定することができます。他のノードと共有するべき最初の500ブロックを特定すると、これらブロックそれぞれのハッシュを <tt>inv</tt> (inventory) messageを使って他のノードに送ります。これらのブロックを持っていないノードは、<tt>inv</tt> messageにあるハッシュから自身のブロックチェーンに足りないブロックのハッシュを選んだのち <tt>getdata</tt> messagesを使ってフルブロックデータを送ってもらうようにリクエストを出します。</p></div>
<div class="paragraph"><p>例えば、あるノードが起源ブロックしか持っていないとしましょう。起源ブロックの次の500ブロックのハッシュを含む <tt>inv</tt> messageを他のピアから受け取ります。このノードは接続しているピア全てに次の500ブロックに関するブロックデータ送信リクエストを送りますが、このリクエストを送りすぎることによってBitcoinネットワークが破綻しないようになっています。このノードはピアごとに何ブロックがまだ送られてきていない"未達"状態にあるかをトラッキングし続けており、１ピアに対する未達状態最大ブロック数 ( <tt>MAX_BLOCKS_IN_TRANSIT_PER_PEER</tt> )を越えないようにチェックし続けています。この方法により、もし多くのブロックが必要だったとしても、前のデータ送信リクエストが完了してから次のリクエストを送るようになっています。それぞれのブロックを受け取ると、<a href="#blockchain">[blockchain]</a>図で見るように、ブロックチェーンに追加されていきます。ローカルブロックチェーンが徐々に構築されていくにつれて、より多くのブロックのリクエスト＆受信がされていき、このノードのブロックチェーンがBitcoinネットワークのブロックチェーンに追いつくまでこのプロセスは続きます。</p></div>
<div class="paragraph"><p>ローカルブロックチェーンと他のピアのブロックチェーンとの比較および不足ブロックの取得プロセスは、ノードがどれくらいの時間オフラインになっていても継続されます。ノードが数分オフラインであったために数ブロックが不足してしまったりしても、または数ヶ月オフラインであったために数千ブロックが不足してしまったりしても、このノードはまず <tt>getblocks</tt> を送り、 <tt>inv</tt> レスポンスを受け取り足りないブロックのダウンロードを開始します。</p></div>
</div>
<div class="sect2">
<h3 id="spv_nodes">Simplified Payment Verification (SPV) Nodes</h3>
<div class="paragraph"><p>全てのノードがフルブロックチェーンを保持する能力を備えているわけではありません。多くのBitcoinクライアントはディスク容量や計算スピードが限られているスマートフォンやタブレット、組み込みシステムなどのデバイス上で動作するように設計されています。このようなデバイスに対しては、フルブロックチェーンを保持することなしに前節で説明したプロセスを実行できるように <em>simplified payment verification</em> (SPV)が使われます。この方法を用いるクライアントをSPVクライアントまたは軽量クライアントと呼びます。このクライアントが多く採用されるにつれて、SPVノードがBitcoinノードの主要な形、Bitcoinウォレット、になっています。</p></div>
<div class="paragraph"><p>SPVノードはブロックヘッダだけをダウンロードしトランザクション自体はダウンロードしません。トランザクションがないヘッダだけのブロックチェーンはフルブロックチェーンの1/1000くらいの大きさになります。SPVノードはBitcoinネットワーク上の全てのトランザクションについて知っているわけではないため、使用可能な全てのUTXOを構築できません。SPVノードは、必要に応じてブロックチェーンの関連した部分のみを提供するピアに頼るという方法を用いてトランザクションを検証します。</p></div>
<div class="imageblock" id="inventory_synchronization">
<div class="content">
<img src="images/msbt_0606.png" alt="InventorySynchronization" />
</div>
<div class="title">Figure 6. ピアからブロックを取得することによってブロックチェーンと同期するノード</div>
</div>
<div class="paragraph"><p>アナロジーとして、full nodeは行ったことのない町の全てのストリート、住所についての詳細な地図を持っている観光客に似ています。これに対して、SPVノードはメイン通りしか知らず行き当たりばったりで進む観光客のようなものです。両方の観光客ともメインストリートが確認できる点は同じですが、地図を持っていない観光客はメインストリートにどんな横道があるか、他にどんなストリートがあるかは分かりません。単に23 Church Streetというストリートにいるだけでは、地図を持っていない観光客は同じ名前のストリートが同じに町に他にも多くあるかどうか、目の前のストリートが行きたいストリートなのかどうかを知ることはできないのです。地図を持たない観光客が取れる最も良い方法は、十分な数の人々に尋ねることです。そのうちの何人かが彼をだまそうとしないことを祈りましょう。</p></div>
<div class="paragraph"><p>simplified payment verificationはブロックチェーンの <em>高さ</em> の代わりにブロックチェーンの <em>深さ</em> を参照することでトランザクションを検証します。フルブロックチェーンノードが完全に検証された数千ブロックのブロックチェーンや全てのトランザクションを構築する一方、SPVノードは全てのブロックチェーン(しかし全てのトランザクションではない)とこのSPVノードと関連のあるトランザクションだけを検証します。</p></div>
<div class="paragraph"><p>例えばブロック300,000にあるトランザクションを調べる場合、full nodeは300,000個のブロックを起源ブロックまで結びつけUTXOのフルデータベースを構築しUTXOが使用されていないことを確認することでトランザクションを検証していきます。SPVノードはUTXOが使用されていないかどうかは検証できません。その代わり、SPVノードは <em>merkle path</em>(<a href="#merkle_trees">[merkle_trees]</a>参照)を使うことでトランザクションとこのトランザクションを含んでいるブロックとの間を結びつけていきます。ブロック300,000のトランザクションを使用する場合、SPVノードは６個のブロック、300,001番目から300,006番目まで、を確認するまで待ちます。これは他のノードが、300,000番目のブロックにあるトランザクションが二重に使用されたものではないことを６回検証するまで待つためです。</p></div>
<div class="paragraph"><p>実際にトランザクションがブロックになかったときに、トランザクションがあるとSPVノードを説得することはできません。SPVノードはブロックの中のトランザクションの存在をmerkle path証明をリクエストすることで確認でき、ブロックチェーンにあるproof of workを検証できます。しかし、トランザクションの存在はSPVノードには"隠されて"います。SPVノードは確実にトランザクションは存在することを証明できますが、同じUTXOの二重使用のようなトランザクションが存在しているかどうかは検証できません。なぜなら、全てのトランザクションの記録を持っている訳ではないからです。これらの弱点は、DOS攻撃または二重使用攻撃に利用されてしまいます。これに対抗するために、SPVノードはランダムにいくつかのノードと接続するようにしておく必要があります。これは、できるだけ信頼できるノードと接続するようにしておくためです。ランダムに接続することで、ネットワーク分割攻撃またはSybil攻撃を回避することができます。というのは、SPVノードが攻撃者のノードまたは攻撃者のネットワークにのみに接続してしまうと、信頼できる正しいBitcoinネットワークに接続できなくなってしまうためです。</p></div>
<div class="paragraph"><p>実用上、バランスよくコネクションを持っているSPVノードは十分に安全で、必要なリソース量、実用性、安全性のよいバランスがとられています。しかし、絶対に確実なセキュリティという点では、フルブロックチェーンノードが最も良いです。</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>フルブロックチェーンノードは、あるトランザクションより下の全てのブロックのチェーンをチェックすることでこのトランザクションを検証します。これは、このUTXOが未使用であることを保証するためです。一方、SPVノードはこのブロックよりも上の一握りだけのブロックを確認することで、このブロックがどれだけ深く埋められているかを確認しています。</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>ブロックヘッダを得るために、SPVノードは <tt>getblocks</tt> messageの代わりに  <tt>getheaders</tt> message を使います。<tt>getheaders</tt> message を受け取ったピアは2,000個までのブロックヘッダを１個の <tt>headers</tt> message で返送します。このプロセスはfull nodeがブロックを集めるプロセスと同じです。また、SPVノードはピアが送信したブロックやトランザクションをフィルタリングしています。関連あるトランザクションを取得する際には <tt>getdata</tt> request を使います。ピアはトランザクションが含まれている <tt>tx</tt> message を生成し返却します。<a href="#spv_synchronization">[spv_synchronization]</a>図はブロックヘッダの同期を示しています。</p></div>
<div class="imageblock" id="spv_synchronization">
<div class="content">
<img src="images/msbt_0607.png" alt="SPVSynchronization" />
</div>
<div class="title">Figure 7. SPVノードのブロックヘッダ同期</div>
</div>
<div class="paragraph"><p>SPVノードは関連あるトランザクションのみを取得するので、プライバシーリスクが生じてしまいます。フルブロックチェーンノードと違って、全てのトランザクションを取得するわけではなく関連あるデータだけを取得するためウォレットのBitcoinアドレスがもれてしまうのです。例えば、第三者のモニタリングツールはSPVノード上のウォレットからリクエストされたトランザクションを全て追跡することができ複数のBitcoinアドレスをウォレットのユーザと結びつけることができてしまいます。</p></div>
<div class="paragraph"><p>SPV/軽量ノードが導入された後少しして、Bitcoinの開発者たちは <em>bloom filters</em> と呼ばれるプライバシーを漏らさない機能を追加しました。bloom filtersは、SPVノードと関連あるBitcoinアドレスがどれかを漏らすことなくトランザクションの部分集合を取得する方法です。ただし、このフィルタリングメカニズムは正確なものではなく確率を利用したものです。</p></div>
</div>
<div class="sect2">
<h3 id="_bloom_filters">Bloom Filters</h3>
<div class="paragraph"><p>bloom filterは確率的探索フィルタで、欲しいパターンを正確に特定しなくてもよい方法です。bloom filterはプライバシーを漏らさないような探索パターンを作り、SPVノードに特定のパターンに合ったトランザクションが含まれているかを他のピアに確認することができるのです。</p></div>
<div class="paragraph"><p>前の節でのアナロジーとして、地図を持っていない観光客は人にある住所 "23 Church St." への方向を尋ねます。もし彼女がこのストリートへの方向を知らない人に尋ねたら、情報を得ることなくうっかり彼女が行こうとしているところを明かしてしまうことになるのです。bloom filterは「この近くにRCHで終わるストリートはありますか？」と尋ねるようなものです。このような質問をすることで、わずかだけ行きたいストリートの場所を知ることができます。このテクニックを使って、観光客は行きたい場所を特定していくことができるかもしれません。質問の仕方を変えることで正確な返答ではありませんが、観光客は住所を特定できる可能性のある多くの結果とプライバシーを守ることができるのです。もっと直接的に質問すれば、もっと少ない質問で行きたい場所に行けますが、プライバシーを失ってしまいます。</p></div>
<div class="paragraph"><p>bloom filtersは、この例と同じことをSPVノードがトランザクションを探すときに使えるようにし、正確性とプライバシーのバランスを取ることができるようにします。より正確なbloom filterは正確な結果を返しますが、どのBitcoinアドレスをウォレットが使っているかを明かすことでプライバシーを犠牲にします。代わりに、より粗いbloom filterはこのBitcoinノードに関係しないより多くのトランザクションに関する多くのデータを返しますが、プライバシーを保てるようにします。</p></div>
<div class="paragraph"><p>SPVノードは、bloom filterを"空"の状態で初期化しますが、この状態ではどんなパターンもマッチしません。次に、SPVノードはウォレットが持っている全てのBitcoinアドレスのリストを作成し、それぞれのBitcoinアドレスごとに探索パターンを作成します。通常、探索パターンは  pay-to-public-key-hash script です。これは、public-key-hash(Bitcoinアドレス)への支払いをするトランザクションに提供されるlocking scriptです。もしSPVノードが P2SH アドレスの残高をトラッキングしているのであれば、探索パターンはpay-to-public-key-hash script の代わりに pay-to-script-hash script になります。次に、SPVノードは、bloom filterが探索パターンを認識できるようにそれぞれのこれらの探索パターンをbloom filterに追加します。最後に、SPVノードはbloom filterをピアに送り、ピアは送られてきたbloom filterを使ってどのトランザクションが探索パターンにマッチするかを調べます。</p></div>
<div class="paragraph"><p>bloom filterはN個のビット列とM個のハッシュ関数で構成されています。ハッシュ関数はいつも1からNの間の値を生成するようになっており、この数はビット列の場所に対応しています。どのノードでも同じハッシュ関数を使い特定の入力に対して同じ結果を得られるように、ハッシュ関数は決定性的なものになっています。bloom filterの長さ(N)とハッシュ関数の数(M)として違ったものを選ぶことでbloom filterをチューニングすることができ、正確さのレベルおよびプライバシーの確保度合いを調整できます。</p></div>
<div class="paragraph"><p><a href="#bloom1">[bloom1]</a>図では、bloom filterがどのように動くかのデモンストレーションとしてとても小さい16個のビット列と3個のハッシュ関数を使っています。</p></div>
<div class="imageblock" id="bloom1">
<div class="content">
<img src="images/msbt_0608.png" alt="Bloom1" />
</div>
<div class="title">Figure 8. 16bitのフィールドと３つのハッシュ関数を持った極端にシンプルにしたbloom filterの例</div>
</div>
<div class="paragraph"><p>bloom filterはまず全てのビット列が0のなるように初期化されます。bloom filterにパターンを追加するために、パターンをそれぞれのハッシュ関数で次々にハッシュ化しbloom filterに追加していきます。インプットパターンを最初のハッシュ関数に通して1からNまでの間の数を得ます。この数に対応したビット列(1からNまでのindexが振ってある)のビットを見つけ <tt>1</tt> を立てます。次のハッシュ関数に対しても同様に行いM個のハッシュ関数全てに対して行うと、ビットが <tt>0</tt> から <tt>1</tt> に変わった模様としてトランザクションに対する探索パターンがbloom filterに "記録" されます。</p></div>
<div class="paragraph"><p><a href="#bloom2">[bloom2]</a>図はパターン"A"を<a href="#bloom1">[bloom1]</a>図のbloom filterに記録した例です。</p></div>
<div class="paragraph"><p>２つ目のパターンを追加するプロセスは、１つ目のプロセスを繰り返すだけです。２つ目に対してもそれぞれのハッシュ関数を使ってハッシュ化し、ビット列の特定の場所のビットに <tt>1</tt> を立てることでパターンを記録します。多くのパターンを記録していくにつれて、すでに <tt>1</tt> のビットが立っている場所をもう一度 <tt>1</tt> に立てようとするかもしれませんが、この場合このビットは変化しません。本質的に、bloom filterに多くのパターンを記録すればするほど <tt>1</tt> が立っている場所が増え飽和していき、bloom filterの正確さは衰えていきます。これが、bloom filterが確率的なデータ構造、パターンを追加すればするほど正確性が失われる、になっている理由です。正確さはパターンの数が多くなればなるほど減り、逆に、ビット列の大きさ(N)とハッシュ関数の数(M)が大きくなればなるほどこの減り度合いを抑制できます。より大きなビット列と多くのハッシュ関数を使うことで多くのパターンをより正確に記録できるのです。</p></div>
<div class="imageblock" id="bloom2">
<div class="content">
<img src="images/msbt_0609.png" alt="Bloom2" />
</div>
<div class="title">Figure 9. 前に示したシンプルなbloom filterにパターン"A"を与えた場合</div>
</div>
<div class="paragraph"><p><a href="#bloom3">[bloom3]</a>図はパターン"B"をbloom filterに記録する例です。</p></div>
<div class="imageblock" id="bloom3">
<div class="content">
<img src="images/msbt_0610.png" alt="Bloom3" />
</div>
<div class="title">Figure 10. 前に示したシンプルなbloom filterに２番目のパターン"B"を与えた場合</div>
</div>
<div class="paragraph"><p>あるパターンがbloom filterの一部にあるかどうかチェックするために、このパターンをそれぞれのハッシュ関数でハッシュ化し得られたビットパターンとbloom filterのビット列を比較します。あるパターンのビットパターンの中で <tt>1</tt> になっている場所がbloom filterのビット列でも <tt>1</tt> になっていれば、あるパターンが <em>おそらく</em> bloom filterに含まれているだろうと推察できます。bloom filterのビット列のあるビットは複数のパターンによる重複で <tt>1</tt> になっているかもしれないので、答えとしては確実ではないですが、むしろ確率的な答えになります。簡単に言うと、bloom filterは"たぶん、含まれる"と答えるだけです。</p></div>
<div class="paragraph"><p><a href="#bloom4">[bloom4]</a>図はパターン"X"がbloom filterに含まれているかチェックする例です。対応したビットは <tt>1</tt> になっており、よっておそらくパターン"X"を含むということになります。</p></div>
<div class="imageblock" id="bloom4">
<div class="content">
<img src="images/msbt_0611.png" alt="Bloom4" />
</div>
<div class="title">Figure 11. bloom filterを使ってパターン"X"が存在するかチェック。その結果は確率的な陽性、つまり"たぶんある"。</div>
</div>
<div class="paragraph"><p>逆に、あるパターンがbloom filterに含まれていないということをチェックする場合は、対応したbloom filterのビット列のどれか１つが <tt>0</tt> であることを確認すればよく、このことであるパターンがbloom filterには含まれていないということを証明することができます。含まれていないというチェックに対しては確率的ではなく、確実なものです。簡単に言うと、bloom filterは"絶対に含まれない！"と答えることができます。</p></div>
<div class="paragraph"><p><a href="#bloom5">[bloom5]</a>図はパターン"Y"がbloom filterに含まれているかチェックする例です。対応したビットの１つが <tt>0</tt> になっており、よってパターン"Y"は全体に含まれないということになります。</p></div>
<div class="imageblock" id="bloom5">
<div class="content">
<img src="images/msbt_0612.png" alt="images/msbt_0612.png" />
</div>
<div class="title">Figure 12. bloom filterを使ってパターン"Y"が存在するか確認。その結果は正確な陰性、つまり"確実にない！"。</div>
</div>
<div class="paragraph"><p>bloom filterのBitcoinでの実装は Bitcoin Improvement Proposal 37 (BIP0037) に記述されています。<a href="#appdxbitcoinimpproposals">[appdxbitcoinimpproposals]</a>を参照するか、または <a href="http://bit.ly/1x6qCiO">GitHub</a> に行ってみてください。</p></div>
</div>
<div class="sect2">
<h3 id="_bloom_filtersとinventory更新">Bloom FiltersとInventory更新</h3>
<div class="paragraph"><p>bloom filterはSPVノードが受け取るトランザクション(およびそれらを含んでいるブロック)をフィルタリングするために使われます。SPVノードはSPVノードのウォレットにあるBitcoinアドレスのみにマッチするフィルタを作成します。SPVノードはbloom filterを含んでいる <tt>filterload</tt> messageをピアに送ります。bloom filterが送られると、ピアはそれぞれのトランザクションのアウトプットを送られてきたbloom filterでチェックします。bloom filterにマッチしたトランザクションだけがSPVノードに送られます。</p></div>
<div class="paragraph"><p><tt>getdata</tt> messageに対するレスポンスとして、ピアはbloom filterにマッチしたブロックのヘッダとマッチしたトランザクションそれぞれに対するmerkle  path(<a href="#merkle_trees">[merkle_trees]</a>参照)を含む <tt>merkleblock</tt> message をSPVノードに送ります。ピアはまたbloom filterにマッチしたトランザクションを含む <tt>tx</tt> messages も送ります。</p></div>
<div class="paragraph"><p>SPVノードが新たにパターンを増やす場合は  <tt>filteradd</tt> message をピアに送ることでパターンをbloom filterに追加できます。またbloom filterを削除するためには、 <tt>filterclear</tt> message をピアに送ります。bloom filterからあるパターンだけを削除することはできないので、この場合SPVノードは一度bloom filterを削除してから新しいbloom filterを送り直します。</p></div>
</div>
<div class="sect2">
<h3 id="transaction_pools">トランザクションプール</h3>
<div class="paragraph"><p>Bitcoinネットワーク上のほとんどのノードは <em>メモリプール</em> または <em>トランザクションプール</em> と呼ばれる未検証トランザクションの一時リストを持っています。ノードはこのプールを使ってBitcoinネットワークに伝わっていてもまだブロックチェーンに含まれていないトランザクションをトラッキングしています。例えば、ウォレットを持っているノードは、Bitcoinネットワークに伝わっていてもまだ検証されていないウォレットへの入金トランザクションを一時的にこのトランザクションプールに保持しています。</p></div>
<div class="paragraph"><p>トランザクションが到着したり検証されたりすると、これらはトランザクションプールに追加されたり隣接ノードに中継されBitcoinネットワーク上を伝搬していったりします。</p></div>
<div class="paragraph"><p>いくつかのノードはまた孤児になっているトランザクションを入れておく別のプールも持っています。もしトランザクションインプットがまだノードが知らないトランザクションを参照していた場合、親トランザクション(トランザクションインプットにあるトランザクション)が到着するまでorphanトランザクションは一時的にorphanプールに保存されます。</p></div>
<div class="paragraph"><p>トランザクションがトランザクションプールに追加されるとき、ノードはorphanプールにあるトランザクションが、トランザクションプールに追加されるトランザクションアウトプットを参照していないかチェックします。もし参照していれば、orphanプールから削除してトランザクションプールに追加されます。このプロセスはorphanプールにあるトランザクション全てに対して行われ、トランザクションが到着することを起点にして全トランザクションのチェーンが再構築されていきます。</p></div>
<div class="paragraph"><p>トランザクションプールもorphanプール(もし実装されていれば)もローカルメモリに保持され、永続的なストレージには保存されません。むしろこれらは常にBitcoinネットワークからmessageが届くごとに書き変わっていくためローカルメモリのほうがよいのです。ノードが起動するときどちらのプールも空になっていて、Bitcoinネットワークからトランザクションが届くと次第に混み合ってきます。</p></div>
<div class="paragraph"><p>いくつかのBitcoinクライアントの実装ではUTXOデータベースまたはUTXOプールも管理されています。このプールはブロックチェーン上の全ての未使用アウトプットを集めたものです。"UTXOプール"という名前の響きがトランザクションプールと似ていますが、別のデータの集まりです。トランザクションプールやorphanプールと違って、UTXOプールの初期状態は空ではなく最初から数百万個の未使用トランザクションアウトプット(2009年からのトランザクションアウトプット)を持っています。UTXOプールはローカルメモリまたは永続ストレージのデータベースに保持されています。</p></div>
<div class="paragraph"><p>トランザクションプールとorphanプールはそれぞれのノードでの状態が異なりノードがいつ起動したか再起動したかによって変わってきますが、UTXOプールはBitcoinネットワーク内で合意されたものであり、ノードごとの違いはわずかです。さらに、トランザクションプールとorphanプールは未検証トランザクションのみを含み、UTXOプールは検証済アウトプットのみを含みます。</p></div>
</div>
<div class="sect2">
<h3 id="_アラートメッセージ">アラートメッセージ</h3>
<div class="paragraph"><p>アラートメッセージは稀にしか使われない機能ですが、それにも関わらずほとんどのノードに実装されています。アラートメッセージはBitcoinの"緊急放送システム"で、コアのBitcoin開発者たちが緊急メッセージを全てのBitcoinノードに送れます。この機能を使うことで、コアのBitcoin開発者たちがBitcoinネットワーク内の重大な問題を全てのBitcoinユーザに通知できるようになっています。例えばユーザが何らかのアクションをとらなければならないクリティカルなバグのようなものを通知するためです。このアラートシステムはほんの数回だけしか使われておらず、最も大きなものとしては2013年初期にあったクリティカルなデータベースバグのときで、ブロックチェーンの分岐が起きてしまったときに使用されています。</p></div>
<div class="paragraph"><p>アラートメッセージは <tt>alert</tt> messageによって伝搬されます。アラートメッセージは以下にあるフィールドを含んでいます。</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
ID
</dt>
<dd>
<p>
アラートを一意に指定するID
</p>
</dd>
<dt class="hdlist1">
Expiration
</dt>
<dd>
<p>
アラートが失効するまでの時間
</p>
</dd>
<dt class="hdlist1">
RelayUntil
</dt>
<dd>
<p>
アラートが中継されなくなるまでの時間
</p>
</dd>
<dt class="hdlist1">
MinVer, MaxVer
</dt>
<dd>
<p>
アラートが適用されるBitcoinプロトコルバージョンの範囲
</p>
</dd>
<dt class="hdlist1">
subVer
</dt>
<dd>
<p>
アラートが適用されるクライアントバージョン
</p>
</dd>
<dt class="hdlist1">
Priority
</dt>
<dd>
<p>
アラートの優先レベル、現在使用されていない
</p>
</dd>
</dl></div>
<div class="paragraph"><p>アラートは公開鍵で暗号学的に署名されています。公開鍵に対応した秘密鍵は何人かの選ばれたコア開発メンバーによって保持されています。このデジタル署名によってBitcoinネットワークを嘘のアラートが伝搬しないようになっています。</p></div>
<div class="paragraph"><p>アラートメッセージを受け取ったノードはそれを検証し、有効期間をチェックし、全てのピアにアラートメッセージを伝搬します。このため、Bitcoinネットワーク上をすばやく伝搬することができるようになっています。</p></div>
<div class="paragraph"><p>Bitcoin Coreクライアント内に、このアラートを表示することができるコマンドラインオプション <tt>-alertnotify</tt> があり、アラートを受け取ったときに実行するコマンドを指定できます。アラートメッセージは <tt>alertnotify</tt> コマンドにパラメーターとして渡されます。よくある設定は、 <tt>alertnotify</tt> コマンドにノードの管理者にアラートメッセージを含むEメールを送る設定です。このアラートはまたグラフィカルなユーザインターフェイス(bitcoin-Qt)が動いていればポップアップダイアログとしても表示されます。</p></div>
<div class="paragraph"><p>Bitcoinプロトコルの他の実装では、アラートを別の形で受け取られているかもしれません。多くのハードウェアに埋め込まれたBitcoinマイニングシステムではアラートメッセージ機能は実装されていません。というのは、ユーザインターフェイスがないためです。このようなマイニングシステムを動作させているマイナーは、マイニングプールオペレーターを通してアラートを受け取るか、アラートのためだけに軽量ノードを動作させておくことを強く推奨します。</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-07-15 16:58:22 UTC
</div>
</div>
</body>
</html>
