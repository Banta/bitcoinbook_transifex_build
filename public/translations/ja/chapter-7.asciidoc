[[blockchain]]
== ブロックチェーン

=== はじめに

((("blockchains", id="ix_ch07-asciidoc0", range="startofrange")))ブロックチェーンはトランザクションを内包するブロックが数珠つなぎに並べられ、それぞれがひとつ前のブロックに向けたリンクを持つ構造をとります。 ブロックチェーンはファイルまたはシンプルなデータベース内に保持されます。 ビットコイン・コアクライアントの場合((("LevelDB database (Google)")))GoogleのLevelDBにブロックチェーンのメタデータが保持されます。 ブロックはそれぞれ、数珠つなぎになったひとつ前のブロックへのリンクを持つため、しばしば垂直にブロックが積み重ねられ、一番下のブロックがその上にあるブロックの土台となっているような形で例えられます。このような垂直に積み重ねていく例えから、あるブロックの最初のブロックからの距離を表現するのに「高さ」という言葉を使い、一番最後のブロックを「トップ」または「頂点」というような言葉で表します。 

ブロックチェーン内のそれぞれのブロックは、そのヘッダ情報にSHA256暗号学的ハッシュアルゴリズムを適用することで得られるハッシュ値をIDとして持ちます。また、それぞれのブロックは、そのヘッダー内の"previous block hash"のフィールド内に((("parent blocks")))_親_ブロックと知られる一つ前のブロックのハッシュ値を持つことで親ブロックを参照しています。親ブロックへの参照によりリンクされ、それが親の親、さらにその親に数珠つなぎに連なり、最終的にはビットコインが始まって最初に生成された((("genesis block"))) _ジェネシス・ブロック_と呼ばれるブロックにまで連なります。 

ブロックは必ずたった一つの親ブロックを持ちますが、一時的に一つの親ブロックに複数の子ブロックができるケースがあります。その場合、それぞれの子ブロックのヘッダ内の"previous block hash"フィールドに同一の親ブロックのハッシュ値が格納されている状態です。このようなケースは複数の採掘者がほぼ同時に新しいブロックを採掘した場合に発生し、この時ブロックチェーンは一時的に「分岐」することになります（詳細は <<forks>>項参照）。しかし最終的には複数の子ブロックの中の１つが選択されブロックチェーンを構成するブロックとなり分岐は解消されます。繰り返しになりますが、ブロックは複数の子ブロックを持つことはありえますが、それぞれのブロックの親ブロックは必ず１つであり、それはヘッダ内の"previous block hash"フィールドに単一の親ブロック情報が入っているためです。 

"previous block hash"フィールドとして親ブロックのハッシュ値が子ブロックのヘッダ内にあるため、なんらか理由で親ブロックのハッシュ値が変更された場合は子ブロックのハッシュ値にも影響します。子ブロックの"previous block hash" フィールドは親ブロックを参照しているため、親ブロックのハッシュ値が変更された場合、その変更に合わせて"previous block hash"フィールドの値を変更する必要があり、結果、子ブロックのハッシュ値も変化します。同様に子ブロックのハッシュ値が変更されることで孫ブロック、孫の変更で曾孫のハッシュ値が変更というように続きます。 ((("security","immutability of blockchain and")))つまり、多くの世代が後に続くブロックの内容をなんらかの理由で変更するためには、その後の世代の全てのハッシュ値を再計算しないといけないということになります。この再計算は非常に時間を要するために、古い世代のブロックは誰にも変更が出来ず、この変更不可能性こそがビットコインの安全性の鍵となっています。 

ブロックチェーンは地面や氷河のコア試料と似ているといえます。表層部分は季節や気候の変化によって変化しやすいものの、十数センチ下の層では状態はより安定し、さらに数十メートル下の層では数百万年前の状態がそのままのかたちで残っているのが見て取れます。ブロックチェーンでも同様です。最も最近の数ブロックは表層部分に似て分岐などによる再計算等の影響で変更される可能性があり安定しません。しかし６世代まで遡ると地面の十数センチ下の層のように不変的になります。さらに過去のブロックチェーンに遡れば遡るほど不変性は増してきます。100世代まで遡ると採掘した際に新たにコインが発行されたトランザクション（コインベース・トランザクション）の使うことが許されるほど不変性が高くなります。A few thousand blocks back (a month) and the blockchain is settled history, for all practical purposes. While the protocol always allows a chain to be undone by a longer chain and while the possibility of any block being reversed always exists, the probability of such an event decreases as time passes until it becomes infinitesimal.

=== ブロックの構造

((("blocks","structure of")))ブロックは、公開元帳であるブロックチェーンに収録するために、幾つかのトランザクションを集積したコンテナー型のデータ構造をとります。ブロックはメタデータを含むヘッダと、ブロックのサイズの大半を占める大量のトランザクション情報のリストによって構成されます。ブロックのヘッダサイズは80バイトである一方、１つのトランザクション情報のサイズは最低でも250バイトあり、平均して500トランザクションが１つのブロックに内包されます。つまりブロック全体のサイズは、ヘッダ・サイズの1,000倍程度になります。 <<block_structure1>>にブロックの構造を示します。

[[block_structure1]]
.ブロック構造
[options="header"]
|=======
|サイズ| フィールド名 | 説明
| 4バイト | Block Size | このフィールド以降のブロックサイズ（バイト単位）。
| 80バイト| Block Header | 幾つかのフィールドがこのヘッダフィールドに内包されています。
| 1-9バイト（VarInt） | Transaction Counter | 本ブロック内に含まれるブロック数
| 不定| Transactions | 本ブロック内に記録されるブロックのリスト
|=======

[[block_header]]
=== ブロック・ヘッダ

((("block headers")))((("blocks","headers")))ブロックのヘッダには３種類のメタデータで構成されています。１つ目は親ブロックのハッシュ値であり、ブロックチェーンの中で親ブロックを示す情報になります。２つ目は((("difficulty target","in block header")))((("nonce,","in block header")))((("timestamping blocks","in block header"))) _難易度_、_タイムスタンプ_、_ノンス_といった採掘競争に関係するメタデータです。採掘については<<ch8>>に詳しく述べます。そして３つ目は、ブロック内の全トランザクションデータを効率的に要約するためのマークル木のルートハッシュです。 <<block_header_structure_ch07>> にブロック・ヘッダの構造を示します。
 
        
[[block_header_structure_ch07]]
.ブロック・ヘッダ構造
[options="header"]
|=======
|サイズ| フィールド名 | 説明
| 4バイト | Version | ソフトウェア/プロトコル バージョン番号
| 32バイト| Previous Block Hash | 親ブロックのハッシュ値
| 32バイト| Merkle Root | 本ブロック内の全トランザクションに関するマークル木のルートハッシュ
| 4バイト| Timestamp | 本ブロックの生成時刻（Unix時間）
| 4バイト| Difficulty Target | 本ブロック生成時のプルーフ・オブ・ワークの難易度値
| 4バイト| Nonce | プルーフ・オブ・ワークで用いたノンス値
|=======

採掘の過程で使われる、ノンス、難易度値、タイムスタンプの詳細については<<ch8>>章で述べます。

[[block_hash]]
=== ブロック識別子：ブロック・ヘッダー・ハッシュとブロック高

((("blocks","header hash")))((("blocks","height")))((("blocks","identifiers")))最も重要なブロックの識別子はブロック・ヘッダーに対してSHA256アルゴリズムを２回適用して生成される暗号学的ハッシュ、つまりデジタル・フィンガープリントです。この32バイトのハッシュ値は((("block hash")))((("block header hash"))) _ブロックハッシュ_ または、より正確に_ブロック・ヘッダ・ハッシュ_, pass:[<phrase role="keep-together">と呼ばれます。これはハッシュ値の計算にヘッダのデータのみ利用されていることによります。 例えば</phrase>] +000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f+ は一番最初に生成されたブロックのブロック・ハッシュです。ブロック・ハッシュは各ブロックにユニークに与えらえる識別子であり各ブロックのヘッダのみの情報から計算される識別子となっています。 

ネットワーク内で伝送される際も、ブロックチェーンとしてストレージ内に格納される場合にも、ブロックがそのデータ構造内に自身のブロック・ハッシュを持たないことに注意してください。代わりにブロックを受け取った各ノードが、その受け取ったブロックのブロック・ハッシュを計算します。ブロック・ハッシュは各ノード内で、ブロック情報の取り出しを高速化するための索引情報として別テーブルに保持されることがあります。

ブロックを識別するもう一つの方法は、((("block height"))) pass:[<phrase role="keep-together"><emphasis>ブロック高</emphasis>であり、これはロックチェーン内での位置を示します。最初に作られたブロックのブロック高は0（ゼロ）であり、これは先ほど+000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f+というブロック・ハッシュ値で参照したブロック</phrase>] pass:[<phrase role="keep-together">と同一のブロックを指し示します。</phrase>] つまり一つのブロックはブロック・ハッシュと、ブロック高の２通りの方法で識別することが可能です。後続のブロックは最初のブロックの上に積み重ねられ、積み重ねられる度にブロック高は１つ高くなっていきます。2014年１月1日現在でブロック高は約278,000であり、これは2009年の１月に最初のブロックが生成されて以来278,000個のブロックが生成されたことを意味します。 

ブロックハッシュと違って、ブロック高はユニークな識別子ではありません。１つのブロックは特定のブロック高が割り当てられていますが、逆は真ではありません。２つまたはもっと多くのブロックが同じブロック高を持っているかもしれないからです。これは、ブロックチェーン内の同じ場所をマイナーが競争して取得しようとしているためです。どのようにしてこれが起こるのかについては<<forks>>の節で詳細に説明します。ブロック高はまたブロックのデータの一部でもありません。それぞれのノードは、Bitcoinネットワークからブロックを受け取ったときにこのブロックがブロックチェーン内のどこの位置(ブロック高)にあるのかをブロック高を使うことなくブロックハッシュから動的に特定します。ただこのブロック高は、ブロックチェーンからすばやくブロック情報を取得する目的でデータベースにメタデータとして保存されている可能性はあります。 
    
[TIP]
====
ブロックの _ブロックハッシュ_ は常に1つのブロックを一意に指定します。ブロックはまた常に特定の _ブロック高_ を持っています。しかし、常に特定のブロック高は1つのブロックを指定できるというわけではないのです。これは、２つまたはもっと多くのブロックがブロックチェーン内の１つ位置の取り合いをしているかもしれないためです。 
====

=== genesisブロック

((("blockchains","genesis block")))((("genesis block")))ブロックチェーンの一番最初のブロックは起源ブロックと呼ばれており、これは2009年に作られたものです。これはブロックチェーンにある全てのブロックの祖先であり、どんなブロックからスタートしてチェーンを過去にさかのぼっていっても結局起源ブロックにぶつかります。 

全てのノードは１つのブロックのブロックチェーンからいつも始まります。というのは、起源ブロックは変更できないようにBitcoinクライアントにハードコーディングされているためです。全てのノードは起源ブロックのハッシュとデータ、作成された日時、１つのトランザクションが含まれていることを"知って"おり、これにより信頼されたブロックチェーンを構築するときの安全な"根幹"を持つことができるのです。 

((("Bitcoin Core client","genesis block in")))Bitcoin Coreクライアントの内部にハードコーディングされた起源ブロックを見るには、 http://bit.ly/1x6rcwP[chainparams.cpp] を参照してみてください。

以下のハッシュが起源ブロックのハッシュです。 

----
000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
----

blockchain.infoのようなブロック探索サイトでブロックハッシュを検索することができ、以下のハッシュを含むURLを参照することで起源ブロックの内容が書かれたページを見ることができます。

https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f

https://blockexplorer.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f

Bitcoin Core参照クライアントの以下のコマンドを実行することでも起源ブロックの内容を確認することができます。


----
$ bitcoind getblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f
----
[source,json]
----
{
    "hash" : "000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f",
    "confirmations" : 308321,
    "size" : 285,
    "height" : 0,
    "version" : 1,
    "merkleroot" : "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b",
    "tx" : [
        "4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b"
    ],
    "time" : 1231006505,
    "nonce" : 2083236893,
    "bits" : "1d00ffff",
    "difficulty" : 1.00000000,
    "nextblockhash" : "00000000839a8e6886ab5951d76f411475428afc90947ee320161bbf18eb6048"
}
----

起源ブロックには隠されたメッセージが含まれています。coinbaseトランザクションインプットには"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks."(リーマンショックの影響を受けた銀行へのイギリス政府からの資金援助に関する記事)という文章が記載されています。このメッセージはイギリスの新聞 _タイムズ紙_ のヘッドラインを参照することで起源ブロックが2009年1月3日以前になかったことの証明になっています。また、皮肉にも銀行と独立した重要な通貨システムであるBitcoinが稼働し始め、前例のない全世界共通通貨の稼働という決定的な出来事が起きたリマインダーにもなっているのです。このメッセージはBitcoinの創造者であるSatoshi Nakamotoによって最初のブロックに埋め込まれたものです。 

=== ブロックチェーン内でのブロック連結

((("blockchains","linking blocks to")))((("blocks","linking to blockchain")))Bitcoin full nodeは、起源ブロックから始まるブロックチェーンのローカルコピーを保持しています。このブロックチェーンのローカルコピーは、新しいブロックが見つかりチェーンが拡張されるたびに定期的にアップデートされます。ノードがBitcoinネットワークからブロックを受け取ったとき、これらのブロックの検証を行いすでに保持しているブロックチェーンにこれらを連結します。連結するために、ノードは受け取ったブロックヘッダを調べ"previous block hash"を探します。

例として、あるノードが277,314個のブロックをブロックチェーンのローカルコピーに持っていると仮定してみましょう。ノードが知っている一番最後のブロックはブロック277,314で、ブロックヘッダのハッシュは +00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249+ です。 

Bitcoinノードは新しいブロックをBitcoinネットワークから受け取りました。このブロックは以下のようなものです。

[source,json]
----
{
    "size" : 43560,
    "version" : 2,
    "previousblockhash" : 
        "00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249",
    "merkleroot" : 
        "5e049f4030e0ab2debb92378f53c0a6e09548aea083f3ab25e1d94ea1155e29d",
    "time" : 1388185038,
    "difficulty" : 1180923195.25802612,
    "nonce" : 4215469401,
    "tx" : [
        "257e7497fb8bc68421eb2c7b699dbab234831600e7352f0d9e6522c7cf3f6c77",

 #[... 中略 ...]

        "05cfd38f6ae6aa83674cc99e4d75a1458c165b7ab84725eda41d018a09176634"
    ]
}
----

このノードはこの新しいブロックを参照し、親ブロックのハッシュを含む +previousblockhash+ フィールドを見つけます。調べてみると、この +previousblockhash+ フィールドにあるハッシュが、ノードが持っているブロックチェーンの一番最後のブロック高 277,314 のハッシュであったため、ノードはこの新しいブロックが一番最後のブロックの子ブロックであることが分かり、ローカルのブロックチェーンを拡張しました。最終的に、このノードは新しいブロックをブロックチェーンの最後に追加し、新しいブロック高 277,315 を持ったブロックチェーンを作りました。


[[merkle_trees]]
=== Merkle Trees

((("blockchains","merkle trees and", id="ix_ch07-asciidoc1", range="startofrange")))((("merkle trees", id="ix_ch07-asciidoc2", range="startofrange")))ブロックチェーンのそれぞれのブロックには _merkle tree_ を使ったブロックに含まれる全てのトランザクションのサマリが含まれています。

_merkle tree_ は ((("binary hash tree")) _二分ハッシュ木_ と呼ばれるもので、効率的に大きなデータをまとめ、データ全体を検証できるようにしています。merkle treeは暗号学的なハッシュを含む二分木です。"tree"という言葉は、コンピュータサイエンスの分野で使われる枝葉を持つデータ構造を表す言葉として使われています。しかし、これらの木はあとで出てくる例で見るように通常上下が逆の状態で表され、上方向が"根っこ"で下方向が葉になっています。

[[chain_of_blocks]]
.ブロックヘッダにあるprevious block hashの参照によってチェーン内で連結されているブロック。
image::images/msbt_0701.png[]

merkle treeはブロックに含まれている全てのトランザクションをまとめるために使われ、トランザクション全体のデジタルフィンガープリントを作り出し、あるトランザクションがブロックに含まれているかどうかを確認するとても効率的な方法を提供します。((("Merkle trees","constructing"))) merkle treeは再帰的に葉ノードのペアから１つのハッシュ値を計算し、ハッシュが１つだけ残るまで続けます。この残ったハッシュを _root_ または _merkle root_ と呼びます。Bitcoinのmerkle treeに使われている暗号学的なハッシュアルゴリズムはSHA256を２回適用したもので、double-SHA256とも呼ばれています。 

N個のデータ要素がハッシュ化されmerkle treeの中にまとめられているとき、多くても +2*log~2~(N)+ 回の計算をすることであるデータ要素がmerkle treeに含まれているかどうかを知ることができます。  

merkle treeは底部から作られていきます。次の例で見るように、A、B、C、Dの４つのトランザクションから始めてみましょう。これらは<<simple_merkle>>図に示されている通りmerkle treeの _葉_ を構成するものです。

----
H~A~ = SHA256(SHA256(Transaction A))
----

葉ノードの隣同士のペアは、ペアそれぞれのハッシュをくっつけたもののハッシュを取り親ノードにまとめられます。例えば、親ノード H~AB~ を作るためには２つの子ノードの32バイトハッシュをくっつけて64バイトの文字列を作ります。この後この文字列は２回ハッシュ化され親ノードのハッシュが作り出されます。

----
H~AB~ = SHA256(SHA256(H~A~ + H~B~))
----

このプロセスはノードが１つになるまで続けられ、この最後の１つのノードを merkle root と呼びます。32バイトハッシュはブロックヘッダに保存され、４つの全トランザクションのデータがmerkle rootのハッシュにまとめられます。

[[simple_merkle]]
.merkle tree内での各ノードのハッシュ値計算
image::images/msbt_0702.png["merkle_tree"]

merkle treeは二分木であるため、葉ノードが偶数個になる必要があります。もしトランザクションの数が奇数個である場合は、最後のトランザクションハッシュは自分自身とくっつけてハッシュを作りバランス木として知られている偶数個の葉ノードができるようにします。これは<<merkle_tree_odd>>図に示されており、トランザクションCが二重になっています。

[[merkle_tree_odd]]
.1つのデータ要素を二重で使うことで偶数個のデータ要素を持ったmerkle treeを構成
image::images/msbt_0703.png["merkle_tree_odd"]

４つのトランザクションから木を作る方法は、どんなサイズの木にも一般化できます。Bitcoinでは、１つのブロックに数百から千個以上のトランザクションを持つことはよくあり、さきほどの方法と全く同じ方法でmerkle rootの32バイトハッシュとしてまとめられます。<<merkle_tree_large>>図には、１６個のトランザクションからなるmerkle treeが書かれています。図の中でmerkle rootは葉ノードよりも大きく見えますが、厳密に同じサイズで32バイトです。ブロックの中に１つのトランザクションしかないのか、１０万個のトランザクションがあるのかに関わらず、merkle rootは常に32バイトのハッシュにまとめられます。 

特定のトランザクションがブロックに含められていることを証明するために、Bitcoinノードはたった +log~2~(N)+ 個の32バイトハッシュを作り出すだけでよく、これにより特定のトランザクションをmerkle tree rootに繋ぐ ((("authentication path")))((("merkle path"))) _authentication path_ または _merkle path_ を構成します。これはブロックに含まれるトランザクションの数が多くなるにつれて特に重要になっていきます。というのは、トランザクション数の２を底とする対数はトランザクション数が増えてもほとんど大きくならないからです。このことで、データサイズが数MBにもなるブロックに含まれる千個以上のトランザクションから１個のトランザクションを特定するためのmerkle pathを、たった10個から12個のハッシュ(320-384バイト)で効率的に作り出すことができるのです。 

[[merkle_tree_large]]
.多くのデータ要素をまとめているmerkle tree
image::images/msbt_0704.png["merkle_tree_large"]

<<merkle_tree_path>>図にある通り、Bitcoinノードはたった４つの32バイトハッシュ(全部で128バイト)を使ったmerkle pathを作り出すことで、あるトランザクションKがブロックに含まれていることを証明できるのです。このmerkle pathは４つのハッシュ H~L~ 、 H~IJ~ 、 H~MNOP~ 、 H~ABCDEFGH~ から構成されます(これらハッシュは<<merkle_tree_path>>図に青い四角で記されています)。これらの４つのハッシュがauthentication pathとして提示されると、あらゆるBitcoinノードは H~K~ (<<merkle_tree_path>>図に緑の四角で表示)がmerkle rootに含まれているということを対となる追加の４つのハッシュ、H~KL~ 、 H~IJKL~ 、 H~IJKLMNOP~ 、 merkle tree root を計算することで示すことができます(<<merkle_tree_path>>図に点線で縁取られた四角で表示)。 

[[merkle_tree_path]]
.データ要素が含まれていることの証明に使われるmerkle path
image::images/msbt_0705.png["merkle_tree_path"]


<<merkle_example>>にあるコードは、葉ノードからmerkle rootまでのmerkle treeを作り出すプロセスをデモンストレーションであり、いくつかの補助関数でlibbitcoinライブラリを使っています。

++++
<?hard-pagebreak?>
++++

[[merkle_example]]
.マークル木の構築
====
[source, cpp]
----
include::code/merkle.cpp[]
----
====

<<merkle_example_run>>にさきほどのコードをコンパイルし実行した結果を示します。

[[merkle_example_run]]
.merkle例コードのコンパイルと実行
====
[source,bash]
----
$ # Compile the merkle.cpp code
$ g++ -o merkle merkle.cpp $(pkg-config --cflags --libs libbitcoin)
$ # Run the merkle executable
$ ./merkle
Current merkle hash list:
  32650049a0418e4380db0af81788635d8b65424d397170b8499cdc28c4d27006
  30861db96905c8dc8b99398ca1cd5bd5b84ac3264a4e1b3e65afa1bcee7540c4

Current merkle hash list:
  d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3

Result: d47780c084bad3830bcdaf6eace035e4c6cbf646d103795d22104fb105014ba3

----
====

merkle treeの効率性はブロックのデータサイズスケールが大きくなるほど明らかになります。<<block_structure2>>は、ブロックのデータサイズ、ブロック内トランザクション数に応じて必要なmerkle pathの大きさを示しています。

[[block_structure2]]
.merkle treeの効率性
[options="header"]
|=======
|トランザクション数| ブロック平均データサイズ | パスサイズ (ハッシュ数) | パスサイズ (bytes)
| 16 トランザクション | 4 kilobytes | 4 ハッシュ | 128 bytes
| 512 トランザクション | 128 kilobytes | 9 ハッシュ | 288 bytes
| 2048 トランザクション | 512 kilobytes | 11 ハッシュ | 352 bytes
| 65,535 トランザクション | 16 megabytes | 16 ハッシュ | 512 bytes
|=======

表から分かるように、ブロックのデータサイズが急速に大きく(16個のトランザクションの時は4KBですが、65,535個のトランザクションだと16MB)なっていっても、merkle pathのデータサイズはトランザクション数が大きくなるよりもゆっくり大きくなります(128バイトから512バイトにしか増えない)。merkle treeとともに、Bitcoinノードはブロックヘッダ(１ブロックあたり80バイト)だけをダウンロードします。Bitcoinノードはfull nodeから小さなmerkle pathを取得することでブロックの中にあるトランザクションが含まれているかを知ることができます。これには、数GBもあるブロックチェーンの大半を保存したり、また受け渡してもらう必要もありません。simplified payment verification(SPVノード)と呼ばれるフルブロックチェーンを持っていないBitcoinノードは、merkle pathを使うことで全てのブロックをダウンロードすることなくトランザクションを検証しています。(((range="endofrange", startref="ix_ch07-asciidoc2")))(((range="endofrange", startref="ix_ch07-asciidoc1")))

=== merkle treeとSimplified Payment Verification (SPV)

((("merkle trees","SPV and")))((("Simplified Payment Verification (SPV) nodes","merkle trees and")))merkle treeはSPVノードによってよく利用されます。SPVノードは全てのトランザクションを持たず完全なブロックチェーンをダウンロードすることもありません。SPVノードはauthentication pathまたはmerkle pathを使って、あるトランザクションがブロックに含まれているかどうか確認します。 

例として、ウォレット内にあるBitcoinアドレスへの支払いにだけ関心のあるSPVノードを考えてみましょう。SPVノードは、ウォレット内のBitcoinアドレスを含むトランザクションだけを取得するためピアにbloom filterを送ります。ピアはbloom filterに合致するトランザクションを確認し、((("merkleblock message"))) +merkleblock+ messageを使ってブロック情報を送り返します。この +merkleblock+ messageにはブロックヘッダとmerkle pathが含まれており、このmerkle pathはSPVノードにとって関心のあるトランザクションからmerkle rootへの経路です。SPVノードはこのmerkle pathを使って関心のあるトランザクションを参照しブロック内に含まれていることを確認し、またブロックヘッダを使いブロックをブロックチェーンの残りと結びつけます。２つの連結の組み合わせ、トランザクションとブロック、ブロックとブロックチェーン、を使うことでこのトランザクションがブロックチェーンに記録されているということを確認します。SPVノードはブロックヘッダに対するデータとmerkle pathに関するデータという1KB以下のデータを受け取ることになり、full nodeと比べて１０００分の１以下のデータを保持するだけで済むことになります(現在だと1MB程度)。(((range="endofrange", startref="ix_ch07-asciidoc0")))