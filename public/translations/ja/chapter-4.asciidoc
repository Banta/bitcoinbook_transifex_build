[[ch04_keys_addresses_wallets]]
== キー、アドレス、ウォレット

=== イントロダクション

((("bitcoin","establishing ownership of")))bitcoinの所有権は、 _デジタルキー_ 、 _Bitcoinアドレス_ 、 _デジタル署名_ で規定されます。デジタルキーはBitcoinネットワークの中では保持されておらず、デジタルキーはユーザによって作成され個々のユーザのファイルの中、または _ウォレット_ という簡単なデータベースの中に保持されます。ユーザのウォレットの中にあるデジタルキーは完全にBitcoinプロトコルとは独立しており、ブロックチェーンへの参照またはインターネットへのアクセスを必要とすることなくユーザのウォレットで生成および管理できるようになっています。このキーによってBitcoinの多くの興味深い性質を可能にしており、この性質には分散型信頼やコントロール、所有権の証明、暗号学的証明によるセキュリティモデルが含まれます。 


全てのBitcoinトランザクションには、トランザクションをブロックチェーンに含めるための有効な署名が必須であり、有効な署名は有効なデジタルキーのみによって生成できます。よって、このデジタルキーのコピーを持つ人であればどんな人でも、このデジタルキーに紐づく口座にあるbitcoinをコントロールできます。銀行の口座番号と似た公開鍵と、銀行のPINコードに似た秘密鍵、また小切手への署名について考えてみましょう。これらのデジタルキーをごく稀にユーザが確認することがありますが、ほとんどの場合ウォレットのファイルの内部に格納されウォレットによって管理されるため見ることはありません。 

In the payment portion of a bitcoin transaction, the recipient's public key is represented by its digital fingerprint, called a((("addresses, bitcoin","defined"))) _bitcoin address_, which is used in the same way as the beneficiary name on a check (i.e., "Pay to the order of"). In most cases, a bitcoin address is generated from and corresponds to a public key. However, not all bitcoin addresses represent public keys; they can also represent other beneficiaries such as scripts, as we will see later in this chapter. This way, bitcoin addresses abstract the recipient of funds, making transaction destinations flexible, similar to paper checks: a single payment instrument that can be used to pay into people's accounts, pay into company accounts, pay for bills, or pay to cash. The bitcoin address is the only representation of the keys that users will routinely see, because this is the part they need to share with the world.

この章では、暗号学的キーを含むウォレットを紹介します。どのように鍵が生成され、格納され、管理されているのかを見ていき、秘密鍵や公開鍵、Bitcoinアドレス、scriptアドレスを表すいろいろなエンコード形式をレビューします。最後に、メッセージに署名したり所有権を証明したり文字列指定のあるBitcoinアドレスやペーパーウォレットを作成したりするためのキーの特別な使用方法を見ていきます。 

==== 公開鍵暗号と暗号通貨

((("keys", id="ix_ch04-asciidoc0", range="startofrange")))((("cryptocurrency")))((("keys","cryptocurrency and")))((("keys","public")))((("public key cryptography")))((("public key cryptography","implementation of")))公開鍵暗号は1970年代に発明され、計算機および情報セキュリティ分野の数学的基礎になっていました。

公開鍵暗号が発明されてから、いくつかの適した数学的関数が発見されていきました。この数学的関数は、 ((("prime number exponentiation"))) 素数のべき乗や楕円曲線乗算などです。これらの数学的関数は現実な時間で考えると不可逆ものになっています。不可逆とは、一方向への計算は簡単でも、逆方向の計算は実行不可能なことを言います。これらの数学的関数に基づく暗号は、デジタル秘密や偽造不可能なデジタル署名の生成を可能にしています。Bitcoinは公開鍵暗号として楕円関数乗算を使っています。  
 
Bitcoinでは、bitcoinへのアクセスコントロールをするキーペアを生成するために公開鍵暗号を使っています。このキーペアは秘密鍵とこの秘密鍵から一意に生成される公開鍵で構成されています。この公開鍵はbitcoinを受け取るために使われ、秘密鍵はbitcoinを使用するトランザクションに署名するのに使われます。

メッセージ上への署名生成に使われる秘密鍵と公開鍵の間には数学的な関係があります。この署名は秘密鍵を公開することなく公開鍵だけで検証できるようになっています。

bitcoinを使うとき、現在のbitcoin所有者は彼女の公開鍵と署名(生成するごとに異なるものになりますが、同じ秘密鍵から生成されるもの)をbitcoinを使うトランザクション内に提供します。この公開鍵と署名の提供を通して、Bitcoinネットワークの中の全ての人はこのトランザクションが有効なものであると検証でき、bitcoinを送った人が送る時点でこのbitcoinを所有しているかどうか確認できるのです。 

[TIP]
====
((("wallets","key pairs in")))ほとんどのウォレット実装では、利便性のため秘密鍵と公開鍵が _キーペア_ として一緒に保存されています。しかし、この公開鍵は秘密鍵から計算できるため、秘密鍵だけを保存しておくことも可能です。
====

[[private_public_keys]]
==== 秘密鍵と公開鍵

((("keys","public/private")))((("keys","in wallets")))((("public keys")))((("wallets","public/private keys in")))Bitcoinウォレットにはキーペアのコレクションを持っており、それぞれのキーペアは秘密鍵と公開鍵で構成されています。秘密鍵(k)は数値で、通常ランダムに選ばれます。秘密鍵から不可逆関数である楕円曲線乗算を用いて公開鍵(K)を生成します。公開鍵(K)から不可逆ハッシュ関数を用いてBitcoinアドレス(A)を生成します。この節では、秘密鍵の生成から始めて、公開鍵の生成に使われる楕円曲線の数学を見ていき、最後にBitcoinアドレスを公開鍵から生成します。秘密鍵と公開鍵、Bitcoinアドレスの関係は<<k_to_K_to_A>>図に書かれています。

[[k_to_K_to_A]]
.公開鍵、秘密鍵、Bitcoinアドレス
image::images/msbt_0401.png["privk_to_pubK_to_addressA"]

[[private_keys]]
==== 秘密鍵

((("keys","private", id="ix_ch04-asciidoc1", range="startofrange")))((("private keys", id="ix_ch04-asciidoc2", range="startofrange")))秘密鍵は単に数値で、ランダムに選ばれます。秘密鍵を通した所有権管理はBitcoinアドレスに結びついた全ての資金の根幹をなします。秘密鍵は署名を生成するときに使われ、この署名は資金を使うときに所有権の主張に必要となります。秘密鍵は何時でも極秘に保っておかなければいけません。これは、もし他者に秘密鍵が漏れると、秘密鍵に対応したBitcoinアドレスの資金のコントロールを他者に与えることになってしまうためです。秘密鍵はバックアップや偶発的な紛失からの保護もしておかなければいけません。というのは、もし秘密鍵をなくしてしまうと、秘密鍵を復元することはできず、秘密鍵によってセキュリティを担保していた資金も永遠に失ってしまいます。 

[TIP]
====
((("private keys","creating by hand")))Bitcoin秘密鍵は単なる数値です。あなたはコインや鉛筆、紙だけを使ってランダムに秘密鍵を選ぶことができます。例えば、コインを256回投げてBitcoinウォレットで使うランダムな秘密鍵の二進数を作り出すことができます。公開鍵はこの秘密鍵から生成することができます。
====

===== ランダムな数値からの秘密鍵の生成

((("private keys","generating from random numbers", id="ix_ch04-asciidoc3", range="startofrange")))キーを生成する上で重要かつ一番最初にしなればいけないことは、キー生成の安定的なエントロピー源、または十分なランダムさを確保することです。Bitcoinキーを作ることは、"1から 2^256^ までの間の数字を選ぶ"ということと本質的に同じです。数字を選ぶ厳格な方法は、予測可能であったり再現可能性があったりしない方法です。Bitcoinソフトウェアは、256bitのエントロピー(ランダムさ)を作り出すOSのランダム値生成器を使っています。通常OSのランダム値生成器は人間を元にしたランダムさを使って初期化されます。数秒間だけマウスを小刻みに動かしてくださいとOSからお願いされたことがある方もいるかもしれないですが、それはこのランダム値生成が理由です。

さらに正確に言うと、秘密鍵は +1+ と +n - 1+ の間の任意の整数で、nはBitcoinで使われている楕円曲線の位数として定義されている定数です(n = 1.158 * 10^77^で2^256^ よりわずかに小さい)(<<elliptic_curve>>図参照)。このようなキーを作るために、256bitの数値からランダムに数値を選び、選んだ数値が +n - 1+ より小さいかをチェックしています。プログラミング用語で言うとこれは通常、暗号学的に安定なランダムさ源から集められた任意の長さを持ったより大きい文字列を取得し、256bitの数値を作る便利なSHA256ハッシュアルゴリズムに放り込むことで達成できます。もし結果が +n - 1+ よりも小さかった場合、それが適切な秘密鍵です。もしそうでなければ、単にもう一度別のランダムな数値を取得してうまくいくまで同じことを繰り返します。 
	
[TIP]
====
自身でランダムな数値を作り出すコードを書いたり、使っているプログラミング言語が提供している"簡単な"ランダム数値生成器を使ったりしないでください。十分なエントロピー源からのシードを伴った((("cryptographically secure pseudo-random number generator (CSPRNG)")))暗号学的に安全な擬似乱数生成器(CSPRNG)を使ってください。あなたが選んだ乱数生成器ライブラリのドキュメントを勉強して暗号学的に安全かどうかを確認してください。CSPRNGの正しい実装はキーのセキュリティにとって決定的な部分になります。
====

以下はランダムに生成された秘密鍵(k)で、16進数形式(それぞれ4bitずつ64個の16進数整数で表されている256bit整数)になっています。

----
1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
----


[TIP]
====
Bitcoinの秘密鍵スペースのサイズは 2^256^ であり、途方もなく大きな数字です。十進数で約 10^77^ になります。この数字の比較として、観測可能な宇宙には 10^80^ 個の原子があると見積もられています。
====

Bitcoin Coreクライアントで新しいキーを生成するために前に説明した ((("getnewaddress command (bitcoin-cli)"))) +getnewaddress+ コマンドを使います(<<ch03_bitcoin_client>>図参照)。セキュリティのため、公開鍵だけを表示しており秘密鍵は表示していません。((("dumpprivkey command (bitcoin-cli)")))((("private keys","exposing with bitcoind"))) bitcoindに秘密鍵を表示させるには、 +dumpprivkey+ コマンドを使ってください。 +dumpprivkey+ コマンドは _Wallet Import Format_ (WIF) と呼ばれるBase58エンコード形式で秘密鍵を表示します。この詳細については<<priv_formats>>図で説明します。 +getnewaddress+ コマンドと +dumpprivkey+ コマンドを使った秘密鍵の生成例と表示例を以下に示します。

----
$ bitcoind getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

+dumpprivkey+ コマンドはウォレットを開き、さきほどの +getnewaddress+ コマンドで生成された秘密鍵を抽出します。このウォレットに秘密鍵と公開鍵の両方が格納されていなければ、bitcoindが秘密鍵を公開鍵から知ることはできません。 

[TIP]
=====================================================================
+dumpprivkey+コマンドは公開鍵から秘密鍵を生成しているわけではありません。これは不可能だからです。このコマンドは単にウォレットがすでに知っている秘密鍵を表示しているだけで、この秘密鍵はgetnewaddressコマンドで生成されたものです。 
=====================================================================

また、秘密鍵を生成および表示するためにBitcoin Explorerコマンドラインツール(<<libbitcoin>>図参照)の((("Bitcoin Explorer","seed command")))((("seed command (bx)"))) +seed+ コマンド、((("Bitcoin Explorer","ec-new command")))((("ec-new command (bx)"))) +ec-new+ コマンド、((("Bitcoin Explorer","ec-to-wif command")))((("ec-to-wif command (bx)"))) +ec-to-wif+ コマンドを使うこともできます。(((range="endofrange", startref="ix_ch04-asciidoc3")))(((range="endofrange", startref="ix_ch04-asciidoc2")))(((range="endofrange", startref="ix_ch04-asciidoc1")))

----
$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

[[pubkey]]
==== 公開鍵

((("keys","public")))((("public keys","generating")))公開鍵は楕円曲線上のスカラー倍算を使って秘密鍵から計算されるもので、この処理は不可逆な処理になっています。latexmath:[\(K = k * G\)] 但し _k_ は秘密鍵、 _G_　は _ベースポイント_ と呼ばれる定点、 _K_ は結果として出てくる公開鍵です。逆操作は、離散対数問題 - __K__ を知っていたときに _k_ を導出する問題 - として知られ、この難しさは +k+ の全ての可能な値を総当たりで調べるのと同じくらい時間がかかる問題です。秘密鍵から公開鍵を生成する方法を説明する前に、楕円曲線暗号をもうちょっと細かく見てみましょう。 


[[elliptic_curve]]
==== 楕円曲線暗号

((("elliptic curve cryptography", id="ix_ch04-asciidoc4", range="startofrange")))((("public key cryptography","elliptic curve cryptography", id="ix_ch04-asciidoc5", range="startofrange")))((("ECC", see="elliptic curve cryptography")))楕円曲線暗号は、楕円曲線上の点に対する加法とスカラー倍算で表現される離散対数問題をベースに作られた非対称型暗号方式または公開鍵暗号方式です。 

<<ecc-curve>>図はBitcoinで使われているものと似ている楕円曲線の例です。

[[ecc-curve]]
.楕円曲線
image::images/msbt_0402.png["ecc-curve"]

Bitcoinは特別な楕円曲線を使っており、((("National Institute of Standards and Technology (NIST)"))) National Institute of Standards and Technology (NIST)で標準化された ((("secp256k1 curve standard"))) +secp256k1+ と呼ばれる集合を使っています。 +secp256k1+ 曲線は次のような関数で定義されており、この関数は楕円曲線になっています。

[latexmath]
++++
\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}
++++

または 

[latexmath]
++++
\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}
++++

_mod p_ (素数pを法とした剰余)とは、この曲線が位数が素数_p_の有限体をなしていることを示しており、latexmath:[\(\mathbb{F}_p\)] 但し p = 2^256^ – 2^32^ – 2^9^ – 2^8^ – 2^7^ – 2^6^ – 2^4^ – 1(とても大きい素数) のようにも書かれます。 

この曲線は実数ではなく素数位数の有限体をなしているため、二次元に散りばめられたドットパターンのように見えます。しかし、この数学は実数上に定義された楕円曲線の数学と同等です。例として>、<<ecc-over-F17-math>>図はより小さい位数17の有限体をなす楕円曲線を示していて、グリッド上のドットパターンになっています。 +secp256k1+ Bitcoin楕円曲線は、底が知れないほど大きなグリッド上にもっと複雑に描かれたドットパターンと考えることができます。 

[[ecc-over-F17-math]]
.楕円曲線暗号: p=17のときの楕円曲線F(p)を可視化したもの
image::images/msbt_0403.png["ecc-over-F17-math"]

例えば、以下は +secp256k1+ 曲線上の点Pです。これが +secp256k1+ 曲線上にあることは以下のPythonコードを使ってあなた自身で確かめることができます。
----
P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424) 
----

====
[source, pycon]
----
Python 3.4.0 (default, Mar 30 2014, 19:23:13)
[GCC 4.2.1 Compatible Apple LLVM 5.1 (clang-503.0.38)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> p = 115792089237316195423570985008687907853269984665640564039457584007908834671663
>>> x = 55066263022277343669578718895168534326250603453777594175500187360389116729240
>>> y = 32670510020758816978083085130507043184471273380659243275938904335757337482424
>>> (x ** 3 + 7 - y**2) % p
0
----
====

楕円曲線では、((("point at infinity (ECC)"))) "無限遠点"と呼ばれる点があります。この点は簡単に言って足し算での0に対応しています。コンピュータ上では、ときどき x = y = 0 と表現されます(これは楕円曲線方程式を満たしていませんが、簡単な特別な場合として確かめることができる解です)。

((("+ operator")))((("elliptic curve cryptography","addition operator"))) pass:[+] 演算子は加法と呼ばれ、小学校で習う実数に対する加法と似たいくつかの性質を持ちます。楕円曲線上にある２つの点 P~1~ と P~2~ が与えられたとき、３つ目の点 P~3~ = P~1~ + P~2~ があり楕円曲線上にあります。

幾何学的には、３つ目の点 P~3~ は P~1~ と P~2~ を通る直線を描くことによって計算されます。この直線は必ず楕円曲線と別のところで交差します。この交差した点を P~3~' = (x, y) とすると、 P~3~ はX軸に対して反転したところにある点 P~3~ = (x, –y) になります。

無限遠点に関して２つ説明しなければいけない特別な場合があります。

もし P~1~ と P~2~ が同じ点だったとすると、 P~1~ と P~2~ を"通る"直線は P~1~ で曲線に接する接線となるはずです。この接線は曲線と新しい点と必ず交わります。接線の傾きを決めるのに微積分のテクニックを使うことができます。奇妙にも、実数ではなく整数座標で構成される曲線にしたとしても微積分のテクニックはうまくいくのです！

いくつかの場合( P~1~ と P~2~ が同じX座標を持ちY座標が違う場合など)、接線は厳密に垂直となり P3 は無限遠点となります。

もし P~1~ が無限遠点である場合、和は P~1~ + P~2~ = P~2~ となります。同様に、もし P~2~ が無限遠点である場合、P~1~ + P~2~ = P~1~ となります。これが示していることは、無限遠点が0の役割をしているということです。

pass:[+] が (A pass:[+] B) pass:[+] C = A pass:[+] (B pass:[+] C) という結合則を満たすことがわかります。これは括弧をなくても何のあいまいさもなく A pass:[+] B pass:[+] C と書けることを意味します。 

加法が定義されたので、加法を拡張する標準的な方法に沿ってスカラー倍算を定義できます。楕円曲線上の点Pに対して、もしkが整数だとすると、kP = P + P + P + ... + P (k回)。この場合、紛らわしいことにkがときどきべき指数と呼ばれるのです。(((range="endofrange", startref="ix_ch04-asciidoc5")))(((range="endofrange", startref="ix_ch04-asciidoc4"))) 

[[public_key_derivation]]
==== 公開鍵の生成 

((("keys","public, generating", id="ix_ch04-asciidoc6", range="startofrange")))((("public keys","generating", id="ix_ch04-asciidoc7", range="startofrange")))秘密鍵をランダムに生成された数値 _k_ とすると、あらかじめ決められた ((("generator point")))((("secp256k1 curve standard","generator point definition in"))) _ベースポイント_ _G_ を _k_ に掛けることで楕円曲線上のもう１つの点を得ます。このもう１つの点は公開鍵 _K_ に対応するものです。ベースポイントは +secp256k1+ 標準で決められており、Bitcoinでの全ての公開鍵に対して常に同じです。 

[latexmath]
++++
\begin{equation}
{K = k * G}
\end{equation}
++++

但し、kは秘密鍵、Gはベースポイント、Kは結果として出てくる公開鍵で楕円曲線上にある点です。ベースポイントはどのBitcoinユーザでの同じであるため、秘密鍵kが同じであれば公開鍵は同じになります。kとKの関係は固定されていますが、kからKという一方向でのみ計算できます。これは、(Kから得られる)Bitcoinアドレスがどの人にも共有され得るからで、Bitcoinアドレスから秘密鍵kを知ることはできません。 

[TIP]
====
秘密鍵は公開鍵に変換できますが、公開鍵は秘密鍵に戻すことはできません。これは秘密鍵から公開鍵への変換プロセスが一方向だけにしか使えないからです。 
====

((("elliptic curve multiplication"))) 楕円曲線上のスカラー倍算を実装すると、前に生成した秘密鍵kをベースポイントGに掛けることで公開鍵Kが得られます。

----
K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G
----

Public Key K is defined as a point +K = (x,y)+:

----
K = (x, y) 

但し

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

点への整数のスカラー倍算を可視化するために、数理的な構造が同じ実数に対する簡単な楕円曲線を使います。ゴールは、ベースポイントGで決められるkGを見つけることです。これは、GにG自身をk回足すことと同じです。楕円曲線で自分自身に足すとは、点に接する接線をを描きその接線がもう一度楕円曲線に交わる点、X軸に対して対称な点、を見つけることです。 

<<ecc_illustrated>>図は、楕円曲線上で幾何学的な操作を繰り返すことでG, 2G, 4Gを導きだすプロセスを表しています。

[TIP]
====
ほとんどのBitcoin実装では、((("OpenSSL cryptographic library"))) http://bit.ly/1ql7bn8[OpenSSL 暗号学的ライブラリ]を使って楕円曲線での数学の計算をしています。例えば、公開鍵を導出するために関数 +EC_POINT_mul()+ が使われています。(((range="endofrange", startref="ix_ch04-asciidoc7")))(((range="endofrange", startref="ix_ch04-asciidoc6")))(((range="endofrange", startref="ix_ch04-asciidoc0")))
====

[[ecc_illustrated]]
.楕円曲線暗号: 楕円曲線上での整数 k によるベースポイント G へのスカラー倍算を可視化したもの
image::images/msbt_0404.png["ecc_illustrated"]

=== Bitcoinアドレス

((("addresses, bitcoin", id="ix_ch04-asciidoc8", range="startofrange")))((("addresses, bitcoin","generally", id="ix_ch04-asciidoc9", range="startofrange")))Bitcoinアドレスは、あなたにお金を送りたい人誰にでも共有されえる、数値と文字で構成された文字列です。公開鍵から作られるBitcoinアドレスは数値と文字による文字列になっており、1からはじまるものです。以下はBitcoinアドレスの例です。

----
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
----


Bitcoinアドレスは、資金の受取人としてトランザクションに共通に現れるものです。もし小切手とBitcoinトランザクションを比べたとすると、Bitcoinアドレスは"Pay to the order of"のあとに書かれる受益者名です。小切手上では、この受益者は時々銀行口座を持っている人の名前になりますが、または企業名や機関名、現金にさえなります。小切手では口座を特定する必要はないので、むしろ資金の受取人として口座を指す抽象名を使います。この抽象名は小切手での支払いを使いやすくしています。BitcoinトランザクションではBitcoinアドレスという似た抽象名を使い、Bitcoinトランザクションを使いやすいものにしています。Bitcoinアドレスは秘密鍵/公開鍵の所有者を表し、または<<p2sh>>にある支払いscriptのような他の何かを表すものです。とりあえずBitcoinアドレスが公開鍵を表し、またBitcoinアドレスが公開鍵から生成される簡単な場合から説明していきましょう。

Bitcoinアドレスは一方向暗号学的ハッシュ化を使うことで公開鍵から生成されます。"ハッシュ化アルゴリズム"または簡単に"ハッシュアルゴリズム"は、フィンガープリントまたは任意のサイズの"ハッシュ"を作り出す一方向関数です。暗号学的ハッシュ関数は、Bitcoin、Bitcoinアドレス、scriptアドレス、proof-of-workマイニングアルゴリズムの中で使われます。公開鍵からBitcoinアドレスを作るときに使うアルゴリズムは、 ((("Secure Hash Algorithm (SHA)"))) Secure Hash Algorithm (SHA) と ((("RACE Integrity Primitives Evaluation Message Digest (RIPEMD)"))) RACE Integrity Primitives Evaluation Message Digest (RIPEMD) で、中でも ((("RIPEMD160")))((("SHA256"))) SHA256 と RIPEMD160 が使われます。 

公開鍵KのSHA256ハッシュを計算し、さらにこの結果のRIPEMD160ハッシュを計算することで、160bit(20byte)の数字を作り出します。
[latexmath]
++++
\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}
++++
但し、Kは公開鍵、Aは結果として出てきたBitcoinアドレスです。 


[TIP]
====
((("addresses, bitcoin","public keys vs.")))((("public keys","bitcoin addresses vs.")))Bitcoinアドレスは公開鍵と同じでは _ありません_ 。Bitcoinアドレスは公開鍵から一方向関数を使って導出されるものです。 
====

Bitcoinアドレスは、((("addresses, bitcoin","Base58 encoding", id="ix_ch04-asciidoc10", range="startofrange")))((("addresses, bitcoin","Base58Check encoding", id="ix_ch04-asciidoc11", range="startofrange")))((("Base58 encoding", id="ix_ch04-asciidoc12", range="startofrange")))((("Base58Check encoding", id="ix_ch04-asciidoc13", range="startofrange"))) "Base58Check" と呼ばれる形にエンコードされた状態でほぼ常に使われます(<<base58>>参照)。"Base58Check"では、58個の文字(Base58)とチェックサムを使いますが、これは人間にとって読みやすくしたり、曖昧さを避けたり、転写時のエラーを防いだりするためです。Base58Checkはまた、Bitcoinで他の用途でも使われます。Bitcoinアドレス、秘密鍵、暗号化されたキー、scriptハッシュなど、ユーザが読む必要があったり、数字を正しく転写しなければいけなかったりするときはいつでもです。次の節では、Base58Checkのエンコード、デコードの仕組みと結果として出てくる表現を説明します。<<pubkey_to_address>>図は公開鍵からBitcoinアドレスへの変換を説明しています。(((range="endofrange", startref="ix_ch04-asciidoc13")))

[[pubkey_to_address]]
.公開鍵からBitcoinアドレスへ: 公開鍵をBitcoinアドレスに変換するプロセス 
image::images/msbt_0405.png["pubkey_to_address"]

[[base58]]
==== Base58とBase58Checkエンコード


大きな数字をコンパクトに表すために、多くのコンピュータではいくつかの記号を使うことで10以上を基数とするアルファベットと数字を混ぜた表現を使っています。例えば、伝統的な１０進数では0から9までの10個の数字を使う一方、１６進数ではAからFの文字を使うことで16個の数字を使います。１６進数で表される数字は十進数で表すよりも短くなります。((("Base-64 representation"))) Base-64 では、26個の小文字、26個の大文字、10個の数字、バイナリデータをemailのようなテキストベースの通信で送るための"\+" や "/" のような２種類の文字を使います。Base-64 はemailにバイナリデータを添付するのによく使われます。Base58 はBitcoinで使うために開発されたテキストベースのエンコード形式で、他の暗号通貨でも使われています。これはコンパクトな表現、可読性、エラー発見および防止のためです。Base58はBase64の部分集合でアルファベットの大文字小文字、数字が使われます。しかし、あるフォントで表示したときに同じように見えて、よく間違えてしまういくつかの文字は省かれています。Base58はBase64から0(数字の0)、O(大文字o)、l(小文字L)、I(大文字i)、記号"\+"や"/"を除いたもの、つまり、(0, O, l, I)を除いたアルファベットの大文字小文字、数字の集合になっています。

[[base58alphabet]]
.BitcoinにおけるBase58のアルファベット
====
----
123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
----
====


書き間違いや転写間違いをさらに防ぐため、Base58CheckはBase58エンコード形式になっていて、Base58エンコードはBitcoinでエラーチェックコードとして頻繁に使われています。チェックサムは、エンコードされようとしているデータの最後に追加される4byteです。このチェックサムはエンコードされたデータのハッシュから作られ、転写間違いやタイピング間違いを検出したり防いだりするのに使われます。Base58Checkでエンコードされたデータが与えられた場合、デコードソフトウェアはエンコードされようとしているデータのチェックサムを計算し、含まれているチェックサムと比較します。もし２つが一致しなかった場合、これはエラーが混入してしまったかBase58Checkデータが無効だということを示しています。これによって、例えば、ウォレットが有効な送り先だと判断して受け付けてしまった打ち間違いBitcoinアドレスを無効と判断し、資金を失ってしまうということを防ぐことができます。

((("data, converting to Base58Check")))数値データをBase58Check形式に変換するために、まずデータの先頭に"version byte"と呼ばれている文字を追加します。このversion byteは、簡単にエンコードされたデータの種類を特定できるように付加されています。例えば、Bitcoinアドレスの場合先頭はゼロ(１６進数で0x00)で、一方秘密鍵をエンコードするときは先頭は128(１６進数で0x80)です。共通に使われているversion byteのリストは<<base58check_versions>>を参照してください。

次に、"double-SHA"チェックサムを計算してみましょう。これは、SHA256ハッシュアルゴリズムを前の結果(prefixとデータ)に２回適用するという意味です。
 
----
checksum = SHA256(SHA256(prefix+data)) 
----

結果として出てくる32byteハッシュ(ハッシュのハッシュ)から最初の4byteだけを取り出します。これら4byteをエラーチェックコードとして、または((("checksum"))) チェックサムとして使用されます。このチェックサムは最後に付加されます。 

結果は３つの部分、prefix、データ、チェックサムによって構成されていて、前に書いたBase58のアルファベットを使ってエンコードされています。<<base58check_encoding>>図はBase58Checkエンコードのプロセスを説明しています。

[[base58check_encoding]]
.Base58Checkエンコーディング: 曖昧さなくBitcoinデータをエンコードするために、version byte、チェックサム付加しBase58変換をしたフォーマット
image::images/msbt_0406.png["Base58CheckEncoding"]

Bitcoinでは、データをコンパクトにするためや読みやすくするため、エラーを検知しやすくするために、ユーザに渡されるほとんどのデータをBase58Checkエンコードにしています。Base58Checkでのversion prefixは、簡単に形式を区別するために使われており、Base58でエンコードされるときにBase58Checkエンコードpayloadの最初に特定の文字を付けられています。これらの文字は、どんな種類のデータをエンコードしたのか、データをどう使うのかを人間が分かるようにしています。1から始まるものはBase58CheckエンコードされたBitcoinアドレス、5から始まるものはBase58Checkエンコードされた秘密鍵WIF形式です。

++++
<?hard-pagebreak?>
++++

[[base58check_versions]]
.Base58Checkのversion prefixとエンコードされた結果の例
[options="header"]
|=======
|Type| Version prefix (hex)| Base58 result prefix
| Bitcoin Address | 0x00 | 1 
| Pay-to-Script-Hash Address | 0x05 | 3 
| Bitcoin Testnet Address | 0x6F | m or n 
| Private Key WIF |  0x80 | 5, K or L 
| BIP38 Encrypted Private Key | 0x0142 | 6P 
| BIP32 Extended Public Key | 0x0488B21E | xpub  
|=======


Bitcoinアドレスを生成する完全な手順を見てみましょう。秘密鍵から始まって、公開鍵(楕円曲線上の点)を作り、二重ハッシュ化アドレスを作り、最後にBase58Checkエンコードします。<<addr_example>>にあるC++コードは、秘密鍵からBase58Checkエンコード済みBitcoinアドレスまでの完全な逐一手順を示しています。このサンプルコードは、いくつかの補助関数のために<<alt_libraries>>で紹介したlibbitcoinライブラリを使っています。((("Base58Check encoding","bitcoin address, complete code for")))

[[addr_example]]
.秘密鍵からのBase58CheckエンコードされたBitcoinアドレスの作成
====
[source, cpp]
----
include::code/addr.cpp[]
----
====

このコードは事前に決められた秘密鍵を使っており、動作させるたびに毎回同じBitcoinアドレスが生成されるようになっています。具体的な動かし方は<<addr_example_run>>に示されている通りです。

[[addr_example_run]]
.このaddrコードのコンパイルと実行
====
[source,bash]
----
# Compile the addr.cpp code
$ g++ -o addr addr.cpp $(pkg-config --cflags --libs libbitcoin)
# Run the addr executable
$ ./addr
Public key: 0202a406624211f2abbdc68da3df929f938c3399dd79fac1b51b0e4ad1d26a47aa
Address: 1PRTTaJesdNovgne6Ehcdu1fpEdX7913CK
----
====

==== キーフォーマット

((("addresses, bitcoin","key formats", id="ix_ch04-asciidoc14", range="startofrange")))((("keys","formats of", id="ix_ch04-asciidoc15", range="startofrange")))秘密鍵も公開鍵も多くの違った形式で表現されています。見た目が違っていたとしても、これらの表現は全て同じ数値にエンコードされます。これらの形式は基本的に人々が読みやすくなる、間違うことなく転写できるようになるために使われます。

[[priv_formats]]
===== 秘密鍵フォーマット

((("private keys","format")))((("sx tools","modifying private key formats with")))秘密鍵は多くの違った形式で表現されていて、これらは全て同じ256bitの数値に対応しています。<<table_4-2>>に秘密鍵を表現するために使われる３つの形式を示します。

[[table_4-2]]
.秘密鍵の表現一覧(エンコーディングフォーマット
[options="header"]
|=======
|種類|接頭語|説明
| １６進数 | None | 64個の１６進数
| WIF |  5 | Base58Checkエンコーディング: 128のversion prefixと、32bitチェックサムを伴ったBase58
| 圧縮WIF | K または L | 上にあるように、エンコード前にsuffix 0x01 が追加されています
|=======

<<table_4-3>>は、これら３つの形式で生成された秘密鍵を示しています。

++++
<?hard-pagebreak?>
++++

[[table_4-3]]
.例: 同じキーを違ったフォーマットで表現
[options="header"]
|=======
|フォーマット | 秘密鍵
| Hex | 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd 
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======

これら全ての表現は、同じ数値、同じ秘密鍵を表す違った形式になっています。ぱっと見は違っていますが、どれも他の形式に簡単に変換できます。 

Bitcoin Explorer(<<libbitcoin>>参照)の ((("Bitcoin Explorer","wif-to-ec command")))((("wif-to-ec command (bx)"))) +wif-to-ec+ コマンドをを使うことでさきほどの両方のWIFキーが同じ秘密鍵を表すことを示すことができます。
----
$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
----

===== Base58Checkからのデコード

((("Base58Check encoding","decoding to hex")))Bitcoin Explorerコマンド(<<libbitcoin>>参照)は、Bitcoinキーやアドレス、トランザクションを操作するシェルスクリプトやコマンドラインの "パイプライン" を簡単に書けるようにするツールです。Bitcoin Explorerを使うとコマンドラインでBase58Checkをデコードできます。

((("Bitcoin Explorer","base58check-decode command")))((("base58check-decode command (bx)"))) +base58check-decode+ コマンドを使うことで圧縮されていないキーをデコードできます。
----
$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}
----

出力された結果には、payloadとしてのキーとWallet Import Format (WIF)のversion prefix 128、チェックサムが含まれています。

圧縮されたキーの"payload"にはsuffix +01+ が追加されており、出力された公開鍵が圧縮されたものであることを表しています。
----
$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}
----

===== １６進数からBase58Checkエンコード

((("Base58Check encoding","from hex")))Base58Checkにエンコード(前のコマンドの逆)するために、Bitcoin Explorer の((("Bitcoin Explorer","base58check-encode command")))((("base58check-encode command (bx)"))) +base58check-encode+ コマンド(<<libbitcoin>>参照)に１６進数秘密鍵を与えると、((("Base58Check encoding","WIF prefix for")))((("Wallet Import Format (WIF)"))) Wallet Import Format (WIF)のversion prefix 128が返ってきます。
----
bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
----

===== １６進数(圧縮されたキー)からBase58Checkへのエンコード

((("compressed keys","encoding/decoding from Base58Check")))"圧縮された"秘密鍵としてBase58Checkにエンコードする(<<comp_priv>>参照)ためには、１６進数キーの末尾に +01+ を追加し上記のようにエンコードします。
----
$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
----

生成されたWIF圧縮形式は"K"から始まります。これは、元の秘密鍵の最後に"01"が付いていることを意味し、圧縮された公開鍵のみを生成するために使われます(<<comp_pub>>参照)。

===== 公開鍵フォーマット

((("public keys","formats of")))公開鍵もまた違った形で表現され、 _圧縮された_ 公開鍵または _圧縮されていない_ 公開鍵があります。 

前に見たように、公開鍵は楕円曲線上の点であり、+(x,y)+ というペアの形で構成されます。これは普通prefixに((("Wallet Import Format (WIF)","for uncompressed keys"))) +04+ が伴って表されます。この +04+ のあとに256bitの２つの数字、１つは _x_ 座標、もう１つは _y_ 座標、が続きます。prefix +04+ は圧縮されていない公開鍵を圧縮された公開鍵と区別するために使われます。圧縮された公開鍵は +02+ 、+03+ から始まります。

ここで、さきほど作った秘密鍵から公開鍵を生成してみましょう。以下に +x+ 座標と +y+ 座標を示します。

----
x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

以下は、520bitの数値(130桁の１６進数整数)として表したさきほどと同じ公開鍵です。これは +04+ のprefixが付いており、そのあとに +04 x y+ のように +x+ 座標と +y+ 座標が続きます。

----
K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A<?pdf-cr?>07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB
----

[[comp_pub]]
===== 圧縮された公開鍵

pass:[<?dbhtml orphans="4"?>] 圧縮された公開鍵は、トランザクションのサイズの削減やブロックチェーンを保持しているBitcoinノード上のディスクスペースの保護のためにBitcoinに導入されました。ほとんどのトランザクションは、所有者の証明書を検証したりbitcoinを使うために公開鍵を含んでいます。それぞれの圧縮されていない公開鍵は520bit(prefix \+ x \+ y)を必要とするため、ブロックごとに数百トランザクション、１日に数万トランザクションというトランザクションを重ねると巨大なデータがブロックチェーンに追加されていくことになってしまいます。((("compressed public keys", id="ix_ch04-asciidoc16", range="startofrange")))((("public keys","compressed", id="ix_ch04-asciidoc17", range="startofrange")))

<<pubkey>>で見てきたように、公開鍵は楕円曲線上の点 (x,y) です。楕円曲線は数学的な関数として表現されるため、楕円曲線上の点は<<pubkey>>にある方程式の解であり、もし _x_ 座標が分かるとすると _y_ 座標は y^2^ mod p = (x^3^ + 7) mod p を解くことで計算できます。このため、公開鍵の点として単に _x_ 座標だけを保持すればよく、 _y_ 座標を省略してキーのサイズと256bitを保持するのに必要なスペースを削減することができます。これによりトランザクションのデータサイズにして50%弱の削減ができます。

圧縮されていない公開鍵が +04+ から始まるのに対して、((("Wallet Import Format (WIF)","for compressed keys")))圧縮されている公開鍵は +02+ または +03+ から始まります。なぜ２つのprefixがあるのかというと、方程式の左側にはy^2^があるので、x座標からy座標を導こうとするとyの解は正負それぞれの符号を持った平方根になってしまい１つに決めることができません。イメージ的には、 _y_ 座標がx軸の上側と下側の両方の値を取り得ることを意味します。<<ecc-curve>>図にある楕円曲線から分かるように、楕円曲線はx軸に対して鏡のように折り返す操作に対して対称です。このため、 _y_ 座標の絶対値は省略できてもy座標の _符号_ は省略できず保存しておく必要があります。別のいい方をすると、これら符号はそれぞれ違った点、違った公開鍵を表すので、点がx軸の上にあったか下にあったかを覚えておかなければいけません。素数位数pの有限体上で二進数演算を用いて楕円曲線を計算すると、 _y_ 座標は偶数または奇数になり、これらはさきほど説明した正/負に対応しています。よって、yの２つの可能な値を区別するには、 +y+ が偶数なら +02+ を圧縮された公開鍵の先頭に付与、 +y+ が奇数なら+03+を先頭に付与するようにします。これによって、ソフトウェアは _y_ 座標を _x_ 座標から正しく導くことができ、公開鍵を圧縮することができるのです。公開鍵の圧縮は<<pubkey_compression>>図で説明されています。 

[[pubkey_compression]]
.公開鍵の圧縮
image::images/msbt_0407.png["pubkey_compression"]

((("public keys","compression")))前に生成した公開鍵と同じものを以下に示します。以下は、 _y_ 座標が奇数であることを示している+03+をprefixとして持つ264bit(66桁の１６進数)の圧縮された公開鍵です。

----
K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
----

((("addresses, bitcoin","converting compressed keys to")))((("compressed keys","converting to bitcoin addresses")))圧縮されていない公開鍵と違うように見えますが、この圧縮された公開鍵は同じ秘密鍵から生成されたものです。重要なこととして、もし圧縮された公開鍵を二重ハッシュ化関数 (+RIPEMD160(SHA256(K))+) を使ってBitcoinアドレスに変換したとすると、_違った_ Bitcoinアドレスが生成されるでしょう。これは１つの秘密鍵が２つの形式(圧縮と非圧縮)の公開鍵を生成し、それぞれの公開鍵を用いて別々のBitcoinアドレスを生成してしまうためですが、これは混乱させる元になってしまいます。

((("blockchains","size of, and compressed public keys")))圧縮された公開鍵は次第にBitcoinクライアントでデフォルトになりつつあります。圧縮された公開鍵に対応することで、トランザクションのサイズおよびブロックチェーンのサイズを削減することに十分なインパクトがあるのです。しかし、全てのクライアントが圧縮された公開鍵に対応している訳ではありません。圧縮された公開鍵に対応している最近のクライアントは圧縮された公開鍵に対応していない古いクライアントから来たトランザクションを解釈しなければいけません。これはウォレットがもう１つのウォレットから秘密鍵をインポートするときに特に重要です。というのは、新しいウォレットがインポートされた秘密鍵に対応したトランザクションを見つけるためにブロックチェーンをスキャンしなければいけないためです。ウォレットはどのBitcoinアドレスをスキャンするべきでしょうか？圧縮されていない公開鍵から生成されたBitcoinアドレスでしょうか？それとも、圧縮された公開鍵から生成されたBitcoinアドレスでしょうか？両方とも有効なアドレスで、両方とも秘密鍵で署名されますが、これらは異なったBitcoinアドレスです！

((("Wallet Import Format (WIF)","newer bitcoin wallets and")))この問題を解決するために、秘密鍵をウォレットからエクスポートする場合、今までと異なり最近のウォレットではWallet Import Formatで出力されます。Wallet Import Formatは、 _圧縮された_ 公開鍵が秘密鍵から作られたということを示しており、Bitcoinアドレスは _圧縮された_ ものということが分かるのです。これによって、インポートされる側のウォレットは古いウォレットから来た秘密鍵か新しいウォレットから来た秘密鍵かを区別でき、公開鍵が圧縮されていてもいなくても公開鍵に対応したBitcoinアドレスが含まれているトランザクションをブロックチェーンから探し出すことができます。次の節で、どのようにこれが動いているのか詳細を見てみましょう。(((range="endofrange", startref="ix_ch04-asciidoc17")))(((range="endofrange", startref="ix_ch04-asciidoc16"))) 

[[comp_priv]]
===== 圧縮された秘密鍵

((("compressed private keys")))((("private keys","compressed")))皮肉にも、"圧縮された秘密鍵"という言葉は誤解を与えてしまいます。というのは、秘密鍵がWIF圧縮形式でエクスポートされた場合、実際には"圧縮されていない"秘密鍵より１byte _長い_ からです。これは、01を秘密鍵の最後に付加しているためで、01は秘密鍵が新しいウォレットから来たこと、秘密鍵から圧縮された公開鍵を生成すべきであることを意味しています。秘密鍵自体は圧縮されておらず、また圧縮することはできません。"圧縮された秘密鍵"という言葉は、本当は"圧縮された公開鍵を生成するために使うべき秘密鍵"という意味です。WIF圧縮形式やWIF形式をエクスポートをするときの形式という意味でのみ使うべきで、混乱を避けるために、"圧縮された"という言葉を秘密鍵に対して使うべきではないのです。

WIF圧縮形式とWIF形式は片方しか使えないということを覚えておいてください。圧縮された公開鍵を実装した新しいウォレットでは、秘密鍵はWIF圧縮形式(先頭がKまたはL)としてのみエクスポートされます。もしウォレットが古い実装のもので圧縮された公開鍵が使えないものであれば、秘密鍵はWIF形式(先頭が5)としてのみエクスポートされます。ここでのゴールは、圧縮された公開鍵またはBitcoinアドレスでブロックチェーンを探索しなければいけないか、圧縮されていないもので探索しなければいけないかをウォレットに教えることです。

もしウォレットが圧縮された公開鍵を実装していれば、全てのトランザクションで圧縮された方の方法を使うでしょう。秘密鍵は楕円曲線上の公開鍵点を導出し、この公開鍵は圧縮されます。圧縮された公開鍵はBitcoinアドレスを生成することに使われ、Bitcoinアドレスはトランザクションの中で使われます。圧縮された公開鍵を実装した新しいウォレットから秘密鍵をエクスポートするとき、Wallet Import Formatは秘密鍵の最後に1byteの +01+ が付加される形に修正されます。結果として出力されるBase58Checkエンコード秘密鍵は"圧縮されたWIF形式"と呼ばれ、古いウォレットでのWIF形式(非圧縮)の場合の"5"の代わりにKまたはLから始まります。 

<<table_4-4>>は同じキーを表しており、WIF形式とWIF圧縮形式でエンコードされています。

[[table_4-4]]
.例: 同じキーを違ったフォーマットで表現
[options="header"]
|=======
|フォーマット | 秘密鍵
| Hex | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD
| WIF | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| Hex-compressed | 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD_01_
| WIF-compressed | KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
|=======


[TIP]
====
"圧縮された秘密鍵"は誤った名称です！これらは圧縮されていません。むしろ、WIF圧縮形式は圧縮された公開鍵やこれに対応したBitcoinアドレスを導出するためのみ使われるべきということを表しています。皮肉にも、"WIF圧縮形式"にエンコードされた秘密鍵は1byteだけ長いです。というのは、"圧縮されていない"秘密鍵と区別するために 01 接尾語が追加されているためです。(((range="endofrange", startref="ix_ch04-asciidoc15")))(((range="endofrange", startref="ix_ch04-asciidoc14")))(((range="endofrange", startref="ix_ch04-asciidoc8")))
====

=== PythonでのキーとBitcoinアドレスの実装  

((("addresses, bitcoin","implementing in Python", id="ix_ch04-asciidoc18", range="startofrange")))((("keys","implementing in Python", id="ix_ch04-asciidoc19", range="startofrange")))((("pybitcointools", id="ix_ch04-asciidoc20", range="startofrange")))((("Python","implementing addresses in", id="ix_ch04-asciidoc21", range="startofrange")))((("Python","implementing keys in", id="ix_ch04-asciidoc22", range="startofrange")))Pythonで書かれた最も総合的なBitcoinライブラリは((("Buterin, Vitalik"))) Vitalik Buterin によって書かれた https://github.com/vbuterin/pybitcointools[pybitcointools] です。<<key-to-address_script>>の中で、pybitcointoolsライブラリ("bitcoin"としてimportされています)を使ってキーとBitcoinアドレスをいろいろな形式で生成しています。

[[key-to-address_script]]
.pybitcointoolsライブラリを使った、キーとアドレスの生成と各フォーマット生成
====
[source,python]
----
include::code/key-to-address-ecc-example.py[]
----
====

<<key-to-address_script_run>>はこのコードを実行した結果を示しています。

[[key-to-address_script_run]]
.key-to-address-ecc-example.pyの実行
====
++++
<screen>
$ python key-to-address-ecc-example.py 
Private Key (hex) is:  
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (decimal) is:  
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) is:  
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key Compressed (hex) is:  
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF-Compressed) is:  
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key (x,y) coordinates is: 
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L, 
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (hex) is: 
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec<?pdf-cr?>243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
Compressed Public Key (hex) is: 
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is: 
 1thMirt546nngXqyPEz532S8fLwbozud8
Compressed Bitcoin Address (b58check) is: 
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</screen>
++++
====


<<ec_math>> ((("elliptic curve cryptography","in Python")))((("Python ECDSA library"))) はもう１つのコード例です。このコードでは、楕円曲線での計算にPython ECDSAライブラリを使い、いかなる特別なBitcoinライブラリも使っていません。

[[ec_math]]
.Bitcoinのキー生成に使われる楕円関数数学のデモスクリプト
====
[source, python]
----
include::code/ec-math.py[]
----
====

<<ec_math_run>>はこのコードを実行した結果を示しています。(((range="endofrange", startref="ix_ch04-asciidoc22")))(((range="endofrange", startref="ix_ch04-asciidoc21")))(((range="endofrange", startref="ix_ch04-asciidoc20")))(((range="endofrange", startref="ix_ch04-asciidoc19")))(((range="endofrange", startref="ix_ch04-asciidoc18")))

[NOTE]
====
上記の例コードでは +os.urandom+ を使用しており、これは裏で動作しているオペレーティングシステムによって提供されている暗号学的に安全な乱数生成器(CSRNG)の値を反映しています。LinuxのようなUNIX-likeなオペレーティングシステムの場合これは +/dev/urandom+ から乱数を取得し、Windowsの場合 +CryptGenRandom()+ を呼び出すことで乱数を取得します。もし適した乱数発生源がない場合、+NotImplementedError+ が発生します。ここで使われている乱数生成器はデモ目的のものであり、十分なセキュリティを持ったように実装されていないので商用レベルのクオリティを持ったBitcoinキーを生成するには適切では _ありません_ 。
====

[[ec_math_run]]
.Python ECDSAライブラリのインストールとec_math.pyスクリプトの実行
====
----
$ # Install Python PIP package manager
$ sudo apt-get install python-pip
$ # Install the Python ECDSA library
$ sudo pip install ecdsa
$ # Run the script
$ python ec-math.py 
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873
----
====

=== ウォレット

((("wallets", id="ix_ch04-asciidoc23", range="startofrange")))ウォレットは秘密鍵のためのコンテナであり、通常構造化されたファイルまたは簡単なデータベースとして実装されています。 
キーを作るもう１つの方法は、((("deterministic key generation"))) _決定性キー生成_ です。ここでは、一方向ハッシュ関数を使って前に出てきた秘密鍵から順々に新しい秘密鍵を作ってみます。秘密鍵を再生成するために必要なのは最初のキー( _seed_ または _master_ keyとして知られているもの)だけです。この節では、キー生成の方法と決定性キーによって構築されたウォレットの構造を説明します。 

[TIP]
====
Bitcoinウォレットはキーを保持していますが、bitcoinは保持していません。それぞれのユーザはbitcoinではなくキーを含むウォレットを持つことになります。ウォレット自体は本当に秘密鍵/公開鍵のペアを含む単なるキーホルダーなのです(<<private_public_keys>>参照)。ユーザはトランザクションにキーを使って署名をし、トランザクションアウトプット(ユーザのbitcoin)を所有していることを証明します。このbitcoinはトランザクションアウトプット(よくvoutまたはtxoutと書かれます)の形でブロックチェーン上に保存されています。((("txout notation")))((("vout notation")))
====

[[random_wallet]]
==== 非決定性(ランダム)ウォレット

((("nondeterministic wallets")))((("random wallets")))((("Type-0 nondeterministic wallet")))((("wallets","nondeterministic")))((("wallets","random")))最初のBitcoinクライアントでは、ウォレットは単にランダムに生成された秘密鍵の集まりでした。このタイプのウォレットを _Type-0 非決定性ウォレット_ と呼びます。例えば、((("Just a Bunch Of Keys (JBOK) wallets")))Bitcoin Coreクライアントは、初回起動のときにあらかじめ１００個のランダムな秘密鍵を作成し、個々のキーは一度しか使われないためその後必要に応じてさらにキーを作ります。このタイプのウォレットは"Just a Bunch Of Keys"またはJBOKというニックネームがついています。ランダムなキーの不利な点は、もし多く生成したとするとそれら全てのコピーも保持しなければいけなくなる点です。つまり、ウォレットは頻繁にバックアップされなければならないということです。それぞれのキーはバックアップされなければならず、さもなければウォレットがアクセス不可能になって管理資金が永久に失われてしまうのです。トランザクションごとに１回だけBitcoinアドレスを使うことによるBitcoinアドレス再利用回避方法は直接問題にぶつかってしまいます。Bitcoinアドレスの再利用は、Bitcoinアドレスが多くのトランザクションに結びつくことでプライバシーの低下に繋がります。特にBitcoinアドレスの再利用を避けたいのであれば、Type-0 非決定性ウォレットを選ぶことはやめたほうがよいでしょう。多くのキーを管理することを意味し、頻繁にバックアップを作る必要が生じてしまうからです。Bitcoin CoreクライアントはType-0 ウォレットを含んでいますが、このウォレットの使用はBitcoin Coreの開発者たちから反対されています。<<Type0_wallet>>は非決定性ウォレットを示しており、ランダムなキーの緩い集まりを表現しています。

==== 決定性(Seeded)ウォレット

((("deterministic wallets")))((("seeded wallets")))((("wallets","deterministic")))((("wallets","seeded")))決定性または"seeded"ウォレットは、全て共通のシードから生成される秘密鍵を持っているウォレットです。共通のシードからの生成は一方向ハッシュ関数を使います。このシードはランダムに生成される数値で、この数値は指数または"chain code"(<<hd_wallets>>参照)のような秘密鍵を生成するためのその他のデータと結びついています。決定性ウォレットでは、このシードを使えば生成された全てのキーを復活できるため、このシードを生成した時点で一回バックアップを取っておけば十分です。このシードはまたウォレットのエクスポートやインポートでも重要で、異なったウォレットの間でのキーの移行を簡単にしてくれるのです。

[[Type0_wallet]]
.Type-0非決定性(ランダム)ウォレット: ランダムに生成されたキーのコレクション
image::images/msbt_0408.png["non-deterministic wallet"]

[[mnemonic_code_words]]
==== Mnemonic Code Words

((("deterministic wallets","mnemonic code words")))((("mnemonic code words")))((("seeded wallets","mnemonic code words")))mnemonic codeは、決定性ウォレットのシードとして使われるランダムな数値を表す(エンコードする)英単語の配列です。この英単語配列は、シードを再生成するために使われ、このシードからウォレットと全てのキーを再生成します。mnemonic codeを伴った決定性ウォレットを実装したウォレットは、ウォレットの初期設定時にユーザに12から24個の英単語の配列を示します。この英単語配列はウォレットのバックアップであり、全てのキーを復活させるまたは再生成するのに使用できます。mnemonic codeによってユーザはウォレットのバックアップを取りやすくなります。なぜなら、ランダムな数字と比べてこの英単語配列は読みやすく、また正確に転写できるからです。 

mnemonic codeは((("BIP0039"))) Bitcoin Improvement Proposal 39 (<<bip0039>>参照)で定義されており、現在草案段階にあります。BIP0039は草案段階提案であり、まだ標準ではないことに注意してください。特にどの英単語群を使うかについて異なる標準があり、((("Electrum wallet")))((("mnemonic code words","Electrum wallet and"))) ElectrumウォレットはBIP0039を元にして別の英単語群を使っています。BIP0039は((("mnemonic code words","Trezor wallet and")))((("Trezor wallet"))) Trezorウォレットやいくつかの他のウォレットでも使われていますが、Electrumの実装とは相容れないものになっています。 
    
BIP0039は以下のようにmnemoni codeとシードの生成を定義しています。

1. 128bitから256bitのランダムな配列(entropy)を生成
2. ランダムな配列のSHA256ハッシュの先頭4bitを取得し、ランダムな配列のチェックサムを生成
3. このチェックサムをランダムな配列の最後に付加
4. 2048個のあらかじめ決められた英単語の辞書のインデックスとして使うために、この配列を11bitずつの部分に分割
5. mnemonic codeを表す12から24個の英単語を生成

<<table_4-5>>はentropyデータのサイズとmnemoni codeの単語数の関係を示しています。

[[table_4-5]]
.Mnemonic codes: エントロピーと単語長
[options="header"]
|=======
|エントロピー (bits) | チェックサム (bits) | エントロピー+チェックサム | 単語数
| 128 | 4 | 132 | 12
| 160 | 5 | 165 | 15
| 192 | 6 | 198 | 18
| 224 | 7 | 231 | 21
| 256 | 8 | 264 | 24
|=======

mnemonic codeは128から256bitになっており、PBKDF2というキー拡張関数を使うことでmnemonic codeからより長いシード(512bit)が生成されます。結果として出てくるシードは決定性ウォレットと全てのキーを生成することに使われます。 

表 pass:[<xref linkend="table_4-6" xrefstyle="select: labelnumber"/>] と pass:[<xref linkend="table_4-7" xrefstyle="select: labelnumber"/>] に、mnemonic codeとそれらが作り出したシードのいくつかの例を示します。

[[table_4-6]]
.128bitエントロピーから得たmnemonic codeと出力されたシード
|=======
| *Entropy input (128 bits)*| 0c1e24e5917779d297e14d45f14e1a1a
| *Mnemonic (12 words)* | army van defense carry jealous true garbage claim echo media make crunch
| *Seed  (512 bits)* | 3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88
8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf7
|=======

[[table_4-7]]
.256bitエントロピーから得たmnemonic codeと出力されたシード
|=======
| *Entropy input (256 bits)* | 2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c
| *Mnemonic (24 words)* | cake apple borrow silk endorse fitness top denial coil riot stay wolf 
luggage oxygen faint major edit measure invite love trap field dilemma oblige
| *Seed (512 bits)* | 3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22
fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343 
|=======


[[hd_wallets]]
==== 階層的決定性ウォレット(BIP0032/BIP0044)

((("deterministic wallets","hierarchical", id="ix_ch04-asciidoc24", range="startofrange")))((("hierarchical deterministic wallets (HD wallets)", id="ix_ch04-asciidoc25", range="startofrange")))((("BIP0032", id="ix_ch04-asciidoc25a", range="startofrange")))((("BIP0044", id="ix_ch04-asciidoc25b", range="startofrange")))決定性ウォレットは１つの"シード"から多くのキーを生成しやすいようにするために開発されました。決定性ウォレットの最も進んだ形は、BIP0032で定義されている _階層的決定性ウォレット_ または _HDウォレット_ です。階層的決定性ウォレットはツリー構造をなしているキーを含んでいて、このツリー構造は親キーが子キー群を作り、それぞれの子キーが孫キー群を作り出すような感じに無限に続いていきます。<<Type2_wallet>>図でツリー構造を説明しています。((("hierarchical deterministic wallets (HD wallets)","tree structure for")))

[[Type2_wallet]]
.Type-2階層的決定性ウォレット: １つのシードから生成されたキーツリー
image::images/msbt_0409.png["HD wallet"]

[TIP]
====
もしBitcoinウォレットを実装するのであれば、BIP0032とBIP0044標準に従ったHDウォレットとして構築するべきです。 
====

HDウォレットは、ランダムな(非決定性)キーに比べて２つの主な利点があります。１つ目としては、ツリー構造は付加的な組織的意味を表すのに使うことができる点です。例えば、サブキーの特定のブランチを支払いを受け取ることに使う場合や、異なるブランチをおつりを受け取ることに使う場合です。キーのブランチはまた企業内の状況に合わせて使われます。例えば、部署ごと、課ごと、特定の機能集団ごと、口座種類ごとにブランチを割り当てるようなことです。 

２つ目の利点としては、ユーザが秘密鍵に触れることなく公開鍵を生成できる点です。それぞれのトランザクションごとに異なる公開鍵を発行することで、安全でないサーバや受信用にしかしていないサーバも使うことができるのです。公開鍵をあらかじめこれらのサーバに置いておいたり先に生成しておいたりする必要はありませんが、これらのサーバは資金を使うときに必要な秘密鍵を持つことはできません。 

===== シードからのHDウォレット作成

((("hierarchical deterministic wallets (HD wallets)","creation from seeds")))((("seeded wallets","HD wallets")))HDウォレットは単一の _ルートシード_ から作られ、ルートシードは128bit、256bit、512bitのランダムな数値です。HDウォレットにある他の全ては、決定性的にルートシードから導出され、このルートシードからHDウォレット全体を再生成できます。ルートシードだけを単にコピーすれば数千個、または数百万個のキーがあってもHDウォレットをバックアップ、リストア、エクスポートしやすくなるということです。ルートシードは前の節 <<mnemonic_code_words>> で書いたように_mnemonic word sequence_によってしばしば表現され、ルートシードを転写、保存をしやすくしています。

HDウォレットでマスターキーとマスターチェーンコードを生成するプロセスを<<HDWalletFromSeed>>を示します。

[[HDWalletFromSeed]]
.ルートシードからのmaster keyとchain codeの生成
image::images/msbt_0410.png["HDWalletFromRootSeed"]

ルートシードはHMAC-SHA512アルゴリズムに対するインプットであり、結果として出力されたハッシュは _マスター秘密鍵_ (m)と _マスターチェーンコード_ を生成するために使われます。マスター秘密鍵(m)は対応したマスター公開鍵(M)を生成し、このときこの章の最初に見た標準的な楕円曲線上のスカラー倍算プロセス +m * G+ が使われています。次の章で見るように、このチェーンコードは親キーから子キーを生成するプロセスの中でエントロピー(乱雑さ)を導入するために使われます。

===== プライベートchild key derivation

((("child key derivation (CKD) function")))((("child private keys")))((("hierarchical deterministic wallets (HD wallets)","CKD function and")))((("private keys","CKD function and")))((("seeded wallets","CKD function and")))階層的決定性ウォレットは_child key derivation_(CKD)関数を使って親キーから子キーを生成します。 

child key derivation関数は一方向ハッシュ関数をベースにしており、以下の組み合わせによって成っています。 

* 子秘密鍵または子公開鍵(ECDSA非圧縮キー)
* チェーンコード(256bit)と呼ばれるシード
* インデックス(32bit)

チェーンコードは表面的にランダムなデータを導入するのに使われます。このため、チェーンコードなくインデックスだけではその他の子キーを生成することはできません。子キーを保持していたとしても、もしチェーンコードも持っていなければ他の子キーを見つけることはできないのです。最初のチェーンコードシード(ツリー構造のルート)はランダムなデータから作られ、次のチェーンコードはそれぞれの親チェーンコードから作られます。 

以下のように、これらの３つの要素は組み合わされ子キーを生成するためにハッシュ化されます。

親公開鍵、チェーンコード、インデックスは組み合わされ、512bitハッシュを生成するためにHMAC-SHA512アルゴリズムでハッシュ化されます。出力されたハッシュは２つの部分に分けられます。右半分の256bitは子チェーンコードになり、左半分の256bitとインデックスは親秘密鍵となります。<<CKDpriv>>図は、インデックスが0のときの0番目の子を作り出す状況を表しています。

[[CKDpriv]]
.子秘密鍵を生成するための親秘密鍵拡張
image::images/msbt_0411.png["ChildPrivateDerivation"]

インデックスを変えることで、子0、子1、子2...と子を作り出していくことができ、それぞれの親キーは２０億個の子キーを持つことができます。 

このプロセスを繰り返すことで、ツリー構造を無限に下っていくことができ、それぞれの子が次々に親となり自身の子供を作っていきます。 

===== 生成された子キーの使用

((("child key derivation (CKD) function","using")))((("child private keys","using")))((("security","child private keys and")))それぞれ子秘密鍵たちは互いにどういう関係にあるかを知ることができません。HMAC-SHA512は一方向関数であるため、子キーは親キーを探すことができずまた、子キーは自分の兄弟を探すこともできません。もしn ~番目~ の子があったとしても、n-1番目の子やn+1番目の子、それ以外のいかなる子も探すことができません。ただ唯一親キーとチェーンコードだけが全ての子を作り出すことができます。もし子チェーンコードがないと、子キーは孫キーを作ることもできません。子秘密鍵と子チェーンコードの両方があって初めて孫を作り出すことができるのです。 

子秘密鍵は何のために使われるのでしょうか？子秘密鍵は公開鍵とBitcoinアドレスを作ることに使われます。また、支払いに使われるトランザクションに署名をするときにも使われます。  

[TIP]
====
子秘密鍵、これに対応した公開鍵およびBitcoinアドレスは、HDウォレットではない全てランダムに生成されたキーやアドレスと見分けがつきません。これらが生成列の一部であるということは自分自身からは分からず、これらを生成するHDウォレットの関数の外側から見なければいけません。これらが一度生成されると、"普通"のキーと全く同じように使えます。 
====

===== 拡張キー

((("extended keys")))((("hierarchical deterministic wallets (HD wallets)","extended keys")))((("keys","extended")))前に見たように、キー導出関数は子供を作ることに使われ、キー、チェーンコード、インデックスという３つのインプットに基づき計算されます。本質的に必要なインプットはキーとチェーンコードで、これらを組み合わせたものは _拡張キー_ と呼ばれています。拡張キーという言葉はまた、"拡張可能キー"と呼ばれることもあります。なぜなら、このキーで子供を生成できるからです。 

拡張キーは単に256bitのキーと256bitのチェーンコードを単にくっつけて512bitにしたものです。拡張キーには２つの種類があります。拡張秘密鍵は秘密鍵とチェーンコードの組み合わせで、子秘密鍵(そして、これから子公開鍵も)を生成することに使われます。拡張公開鍵は公開鍵とチェーンコードの組み合わせで、子公開鍵を生成することに使われます。詳細については<<public_key_derivation>>に記載しています。

張キーをツリー構造のブランチのルートと考えてみましょう。ブランチのルートを使って、ブランチの残りを生成することができます。拡張秘密鍵は完全なブランチを作ることができますが、一方拡張公開鍵は公開鍵のブランチしか作ることができません。

[TIP]
====
拡張キーは秘密鍵または公開鍵、チェーンコードで構成されています。拡張キーは子供を生成し、ツリー構造の中に子供自身のブランチを作り出していくことができます。拡張キーを共有することで、ブランチ全体を参照することができます。 
==== 

((("Base58Check encoding","extended keys and")))拡張キーはBase58Checkでエンコードされ、BIP0032互換ウォレットの間でエクスポートとインポートを簡単に行うことができます。拡張キーのBase58Checkはprefixとして"xprv"と"xpub"という特別なversion byteを使います。拡張キーは512または513bitなので、前に見たBase58Checkエンコード文字列よりも長くなっています。

ここにBase58Checkでエンコードされた拡張秘密鍵の例を示します。

----
xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c
----

以下はこの拡張秘密鍵に対応した拡張公開鍵です。これもBase58Checkでエンコードされています。

----
xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9
----


[[public__child_key_derivation]]
===== パブリックchild key derivation

((("child key derivation (CKD) function","public")))((("hierarchical deterministic wallets (HD wallets)","public child key derivation")))((("public child key derivation")))前に書いたように、階層的決定性ウォレットには秘密鍵を使うこと _なく_ 公開親キーから公開子キーを作り出せるというとても有用な特徴を持っています。この性質から、子公開鍵を作る方法に２種類あることが分かります。子公開鍵を子秘密鍵から作るか、親公開鍵から作るかです。 

このため、拡張公開鍵は全ての _公開_ 鍵(そして公開鍵のみ)を生成することができます。

((("private keys","deployments without")))これにより、拡張公開鍵のコピーだけを持ち全く秘密鍵を持たないサーバやアプリケーションで、とても安全な公開鍵のみの生成ができるようになります。この仕組みを使うと、制限なく公開鍵とBitcoinアドレスを作り出すことができますが、これらのBitcoinアドレスに送られるお金を使うことができません。一方、より安全なサーバでは拡張秘密鍵を使ってさきほどのBitcoinに対応した秘密鍵を生成でき、トランザクションに署名することでお金を使うことができます。 

((("ecommerce servers, keys for")))((("shopping carts, public keys for")))この応用として、Eコマースを提供するwebサーバに拡張公開鍵を置く場合が考えられます。webサーバは公開鍵の生成関数を使ってBitcoinアドレスをトランザクションごと(例えば顧客のショッピングカートごと)に新しいBitcoinアドレスを作ることができます。しかし、このwebサーバは盗難の攻撃を受けやすい秘密鍵を持っていません。HDウォレットを使わない場合、これを実行する唯一の方法は、切り離された安全なサーバで数千のBitcoinアドレスを生成し、あらかじめEコマースサーバ上にBitcoinアドレスを読み込んでおく方法です。この方法は扱いにくく、Bitcoinアドレスをあらかじめ読み込むために定期的なメンテナンスが必要となってしまいます。

((("cold-storage wallets","public child key derivation and")))((("hardware wallets","public child key derivation and")))別の応用としては、コールドストレージまたはハードウェアウォレットへの応用です。この応用では、拡張秘密鍵はペーパーウォレットまたはハードウェアデバイス(例えば、((("Trezor wallet","public key derivation and"))) Trezor hardware wallet)に保存されます。一方、拡張公開鍵はオンライン上に保持されます。ユーザは"受け取り用"のBitcoinアドレスを自由に作ることができますが、秘密鍵は安全にオフラインに保存されます。資金を使うには、ユーザはオフラインの署名用Bitcoinクライアント上で秘密鍵を使って行うか、ハードウェアウォレットデバイス上でトランザクションに署名するかをしなければいけません。<<CKDpub>>図は親公開鍵から子公開鍵を生成するメカニズムを説明しています。 

[[CKDpub]]
.子公開鍵を生成するための親公開鍵拡張
image::images/msbt_0412.png["ChildPublicDerivation"]

===== 強化child key derivation

((("child key derivation (CKD) function","hardened")))((("hardened child key derivation")))((("hierarchical deterministic wallets (HD wallets)","hardened child key derivation")))((("security","extended public keys and")))((("security","hardened child key derivation")))拡張公開鍵から公開鍵のブランチを生成する方法はとても有用ですが、潜在的リスクも持っています。拡張公開鍵にさわれても子秘密鍵にはさわれません。しかし、拡張公開鍵はチェーンコードを含んでいるため、もし子秘密鍵が知られているまたは漏洩してしまった場合、このチェーンコードを使ってその他全ての子秘密鍵を導けてしまうのです。親チェーンコードを伴った１つの子秘密鍵の漏洩により、全ての子供の秘密鍵が明らかになってしまいます。悪いことに、親チェーンコードを伴った子秘密鍵は親秘密鍵を推測することに使われえます。 

このリスクへの解決策として、HDウォレットは _強化生成_ と呼ばれるもう１つの生成関数を使っています。この関数は、親公開鍵と子チェーンコードの間の関係を"壊す"ものです。強化生成関数は親公開鍵の代わりに親秘密鍵を使って子チェーンコードを生成します。これは親秘密鍵または兄弟秘密鍵が漏洩しないようなチェーンコードを使って親と子の間に"ファイヤーウォール"を作ります。強化生成関数は通常のchild key derivationとほとんど同じように見えますが、<<CKDprime>>図に示すように親公開鍵の代わりに親秘密鍵がハッシュ関数のインプットとして使われる点が異なります。

[[CKDprime]]
.子キーの強化生成: 親公開鍵の省略
image::images/msbt_0413.png["ChildHardPrivateDerivation"]

強化プライベート生成関数で出力される子秘密鍵とチェーンコードは、通常の生成関数から得られる結果とは完全に異なります。結果として出てくるキーの"ブランチ"は脆弱ではない拡張公開鍵を生成します。なぜなら、この拡張公開鍵に含まれているチェーンコードは、いかなる秘密鍵も攻撃できないようになっているからです。よって、強化生成は拡張公開鍵が使われる階層よりも上のツリーに行けないようにする"ギャップ"を作り出すのです。 

簡単にいうと、もし拡張公開鍵の利便性を使いたくて、しかもチェーンコードの漏洩リスクを回避したいのであれば、通常の親ではなく強化された親から拡張公開鍵を生成すべきです。ベストプラクティスとしては、マスターキーの１階層目の子供を常に強化生成を通して生成されるようにしておくことがよいでしょう。 

===== 通常および強化生成のインデックス

((("hardened child key derivation","indexes for")))((("public child key derivation","indexes for")))生成関数で使われているインデックスは32bitの整数です。通常の生成関数を通して得られたキーと強化された生成関数を通して得られたキーを簡単に区別するために、このインデックスを２つの範囲に分けておきます。((("child private keys","index numbers for")))0から2^31^-1(0x0 から 0x7FFFFFFF)までのインデックスは通常の生成関数に _のみ_ 使われます。2^31^から2^32-1(0x80000000 から 0xFFFFFFFF)は強化生成関数に _のみ_ 使われます。よって、もしインデックスが2^31 より小さければ、子は通常の生成関数から生成されたもの、一方もしインデックスが2^31^と等しいかそれより上であれば、子は強化された生成関数から生成されたものです。 

読んだり表示したりしやすいように、強化された子供に対するインデックスは0から始まるダッシュ付きの数字で表されます。最初の通常生成関数による子キーは0と表示され、一方最初の強化生成関数による子キー(インデックス 0x80000000)はpass:[<markup>0'</markup>]と表示されます。次に、二番目の強化キーはインデックス 0x80000001 を持ち 1' を表示されます。HDウォレットのインデックス i' を見たときは、これは2^31^+iを表していると考えてください。

===== HDウォレットキー識別子(path)

((("hierarchical deterministic wallets (HD wallets)","identifier for")))((("hierarchical deterministic wallets (HD wallets)","paths for")))HDウォレットにあるキーは、"path"命名規則を使って一意に指定されます。このpath命名規則は、ツリーの階層をスラッシュ(/)で区切って表します(<<table_4-8>>参照)。マスター秘密鍵から得られた秘密鍵は"m"から始まります。マスター公開鍵から得られた公開鍵は"M"から始まります。このため、マスター秘密鍵の最初の子秘密鍵はm/0で、最初の子公開鍵はM/0、最初の子の二番目の孫はm/0/1などとなります。 
 
キーの"先祖"をたどるには右から左に読み、それが得られたマスターキーに到達するまで読んでいきます。例えば、識別子 m/x/y/z はz番目の m/x/y の子キーを表し、また m/x/y は m/x のy番目の子キー、m/x は m のx番目の子キーを表します。

[[table_4-8]]
.HDウォレットのpath例
[options="header"]
|=======
|HD path | 説明
| m/0 | マスター秘密鍵(m)から生成された最初(0)の子秘密鍵
| m/0/0 | 最初の子供(m/0)の最初の孫秘密鍵 
| m/0'/0 | 最初の _強化された_ 子供(m/0')の最初のノーマルな孫秘密鍵
| m/1/0 | 二番目の子供(m/1)の最初の孫秘密鍵
| M/23/17/0/0 | 24番目の子供の、18番目の孫の、最初の曽孫の、最初の玄孫公開鍵
|=======

===== HDウォレットツリー構造をたどってみよう

((("BIP0043")))((("hierarchical deterministic wallets (HD wallets)","navigating")))((("hierarchical deterministic wallets (HD wallets)","tree structure for")))HDウォレットツリー構造は非常に大きな柔軟性を持っています。それぞれの親拡張キーは40億個の子供を持つことができます(20億個の通常の子供と20億個の強化された子供)。それぞれの子供は、もう１つ40億個の子供を持つことができ、これがどんどん続きます。ツリーは好きなだけ深くすることができ、制限なく世代を作っていくことができます。制限なく作っていくことはできますが、しかし、無限のツリーをたどろうとするととても時間がかかってしまします。特にHDウォレットを他のウォレットに移そうとするときとても大変です。 

この複雑さを解決する２つのBitcoin Improvement Proposals (BIPs)が提案されています。１つ目のBIP0043は、ツリー構造の"目的"が明確化された特別な識別子を最初の拡張された子インデックスとして使うということを提案しています。BIP0043に基づけば、HDウォレットはツリーの１階層目に１つだけブランチを持ち、その他の階層は目的が定義された構造や名前空間を持つインデックスを伴うはずです。例えば、１階層目にm/i'/ のブランチだけを持っているHDウォレットは特定の目的に沿ったウォレットとして使われることを想定されており、この目的はインデックス "i" で指定される目的になります。

((("multiaccount structure")))この提案を拡張することで、BIP0044はBIP0043の元での"目的"を表す数字 +44'+ を定義しており、これは複数の口座を保持する目的を表すものです。ウォレットがBIP0044の構造に従っているかどうかは、１階層目が m/44'/だけになっていることから確認できます。 

BIP0044では、以下のように５つの事前に定義された階層構造を提案しています。

+m / purpose' / coin_type' / account' / change / address_index+

((("coin type level (multiaccount structure)")))((("purpose level (multiaccount structure)")))最初の階層"purpose"は常に +44'+ になります。第２階層"coin_type"は暗号通貨コインの種類を表し、個々の通貨が第２階層以下に独自のサブツリーを持つような複数の通貨を扱えるHDウォレットを作ることができるようになっています。現在は３つの通貨が定義されており、Bitcoinは m/44'/0'、Bitcoin Testnetは pass:[<markup>m/44'/1'</markup>]、Litecoinはpass:[<markup>m/44'/2'</markup>]になっています。 

((("account level (multiaccount structure)")))第３階層"account"は、ユーザが複数の口座を使えるようにし、会計や組織的な目的で使えるようにしています。例えば、HDウォレットは２つのBitcoin "口座" pass:[<markup>m/44'/0'/0'</markup>]、pass:[<markup>m/44'/0'/1'</markup>] を持つかもしれません。それぞれの口座はそれぞれ自身のサブツリーのルートになっています。 

((("change level (multiaccount structure)")))第４階層"charge"では、HDウォレットは２つのサブツリーを持つことができ、１つは受取用アドレスで１つはおつり用アドレスです。前の階層では強化生成が使われたのですが、この階層では通常の生成が使われています。これは、拡張公開鍵を安全ではない環境で使うようにするためです。使うことのできないアドレスが第４階層の子供としてHDウォレットから生成され、第５階層"address_index"を作ります。例えば、最初の口座の三番目のbitcoin受け取り用アドレスはM/44'/0'/0'/0/2になります。<<table_4-9>>にいくつかの例を示します。

[[table_4-9]]
.BIP0044のHDウォレット構造例
[options="header"]
|=======
|HD path | 説明
| M/44'/0'/0'/0/2 | 最初のBitcoin口座に対する三番目の受信公開鍵
| M/44'/0'/3'/1/14 | ４番目のBitcoin口座に対する１５番目のおつり用公開鍵
| m/44'/2'/0'/0/1 | トランザクションに署名するための、Litecoinメイン口座の二番目の秘密鍵
|=======

===== Bitcoin Explorerを使ったHDウォレットの実験

((("hierarchical deterministic wallets (HD wallets)","Bitcoin Explorer and")))((("Bitcoin Explorer","HD wallets and")))<<ch03_bitcoin_client>>で紹介したBitcoin Explorerコマンドラインツールを使うと、異なった形式での表現と同時にBIP0032決定性キーを生成したり拡張したりする実験をしてみることができます。((("Bitcoin Explorer","seed command")))((("seed command (bx)")))((("Bitcoin Explorer","hd-seed command")))((("hd-seed command (bx)")))((("Bitcoin Explorer","hd-public command")))((("hd-public command (bx)")))((("Bitcoin Explorer","hd-private command")))((("hd-private command (bx)")))((("Bitcoin Explorer","hd-to-address command")))((("hd-to-address command (bx)")))((("Bitcoin Explorer","hd-to-wif command")))((("hd-to-wif command (bx)"))): (((range="endofrange", startref="ix_ch04-asciidoc25b")))(((range="endofrange", startref="ix_ch04-asciidoc25a")))(((range="endofrange", startref="ix_ch04-asciidoc25")))(((range="endofrange", startref="ix_ch04-asciidoc24")))(((range="endofrange", startref="ix_ch04-asciidoc23")))

====
[source, bash]
----
$ bx seed | bx hd-new > m # create a new master private key from a seed and store in file "m"
$ cat m # show the master extended private key
xprv9s21ZrQH143K38iQ9Y5p6qoB8C75TE71NfpyQPdfGvzghDt39DHPFpovvtWZaRgY5uPwV7RpEgHs7cvdgfiSjLjjbuGKGcjRyU7RGGSS8Xa
$ cat m | bx hd-public # generate the M/0 extended public key
xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9
$ cat m | bx hd-private # generate the m/0 extended private key
xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c
$ cat m | bx hd-private | bx hd-to-wif # show the private key of m/0 as a WIF
L1pbvV86crAGoDzqmgY85xURkz3c435Z9nirMt52UbnGjYMzKBUN
$ cat m | bx hd-public | bx hd-to-address # show the bitcoin address of M/0
1CHCnCjgMNb6digimckNQ6TBVcTWBAmPHK
$ cat m | bx hd-private | bx hd-private --index 12 --hard | bx hd-private --index 4 # generate m/0/12'/4
xprv9yL8ndfdPVeDWJenF18oiHguRUj8jHmVrqqD97YQHeTcR3LCeh53q5PXPkLsy2kRaqgwoS6YZBLatRZRyUeAkRPe1kLR1P6Mn7jUrXFquUt
----
====

=== 最近のキーとアドレスの進展

次の節では、暗号化秘密鍵、scriptとマルチシグネチャーアドレス、文字列指定のあるBitcoinアドレス(vanity address)、ペーパーウォレットなどキーとアドレスの最近の進展を見ていきます。

==== 暗号化秘密鍵(BIP0038)

((("BIP0038")))((("encrypted private keys")))((("private keys","encrypted")))((("security","encrypted private keys")))((("security","of private keys")))秘密鍵は極秘にしておかなければいけません。ただ秘密鍵の _機密性_ は、実用上達成することが大変難しいことはよく知られていることです。というのは、機密性といつでも安全に使えることの両立が難しいためです。((("security","of wallet backups")))秘密鍵を秘密に保つことは、秘密鍵のバックアップを保持し紛失を避けるようにするとさらに難しくなります。ウォレットにあるパスワードで暗号化された秘密鍵は安全かもしれませんが、ウォレットはバックアップしておかなければいけないのです。ときどき、例えばウォレットをアップグレードする、または別のウォレットに変えるために、ユーザはキーを１つのウォレットから別のウォレットに移動する必要が出てきます。秘密鍵のバックアップもまた紙(<<paper_wallets>>参照)、またはUSBフラッシュメモリのような外部ストレージに保存されるかもしれません。しかし、バックアップそのもが盗まれたり紛失してしまったらどうなるでしょうか？これらの両立が難しいセキュリティ問題を解決するために、持ち出し可能で便利な暗号化秘密鍵が考案されました。この暗号化秘密鍵は、多くのウォレットやBitcoinクライアントに実装されており、Bitcoin Improvement Proposal 38またはBIP0038(<<bip0038>>参照)で標準化されています。 
    
BIP0038は、安全なバックアップメディアへの保存およびウォレット間の転送ができるように、またキーが晒される可能性のある状況にも対応できるように、パスフレーズで秘密鍵を暗号化しさらにBase58Checkでエンコードする標準規格を提案しています。この暗号化基準は、((("Advanced Encryption Standard (AES)"))) Advanced Encryption Standard (AES)を採用しています。AESはNational Institute of Standards and Technology (NIST)によって開発され、商用または軍用アプリケーションの暗号化実装に広く使われているものです。 

((("Wallet Import Format (WIF)","from BIP0038 encryption")))BIP0038暗号化スキームでは、インプットとしてBitcoin秘密鍵を取り、通常prefix "5" を伴ったBase58Checkを使いWallet Import Format (WIF)にエンコードされます。さらにBIP0038暗号化スキームでは、アルファベットと数字が混ざった複雑な文字列で構成されるパスコードという長いパスワードを使います。BIP0038暗号化スキームの結果として、 +6P+ から始まるBase58Checkでエンコードされた暗号化秘密鍵が得られます。もしキーが +6P+ から始まっていれば、それは暗号化されており、どのウォレットでも使えるWIF形式秘密鍵( +5+ から始まる)に戻すためにはパスフレーズが必要だということが分かります。現在多くのウォレットはBIP0038暗号化秘密鍵を実装しており、キーをインポートし復号化するときにパスフレーズを求められるでしょう。非常に使いやすいブラウザベースの http://bitaddress.org[Bit Address] (Wallet Details tab) などのサードパーティーのアプリケーションでもBIP0038キーを復号化することができます。 

((("paper wallets","BIP0038 encryption and")))BIP0038暗号化キーの最も多くの利用用途は、秘密鍵を紙にバックアップするときです。ユーザが協力なパスフレーズを選んでいる限りBIP0038暗号化秘密鍵を伴ったペーパーウォレットは非常に安全で、オフラインBitcoinストレージ("コールドウォレット"と呼ばれてもいます)を作るための最高の方法です。

パスフレーズを入れることでどのように復号化されたキーを得るかを理解するために ((("bitaddress.org"))) bitaddress.org を使って<<table_4-10>>にある暗号化されたキーをテストしてみてください。

[[table_4-10]]
.BIP0038暗号化秘密鍵の例 
|=======
| *Private Key (WIF)* | 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
| *Passphrase* | MyTestPassphrase
| *Encrypted Key (BIP0038)* | 6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ
|=======


[[p2sh_addresses]]
==== Pay-to-Script Hash (P2SH) とマルチシグネチャーアドレス 

((("addresses, bitcoin","multi-signature addresses")))((("addresses, bitcoin","Pay-to-Script Hash (P2SH)")))((("multi-signature addresses")))((("Pay-to-Script Hash (P2SH)")))知っての通り、初期から使われているBitcoinアドレスは“1”から始まり、秘密鍵から得られた公開鍵から得られます。誰もがbitcoinを“1”から始まるBitcoinアドレスに送れますが、このbitcoinは対応する秘密鍵署名と公開鍵ハッシュを使うことでのみ使用できます。 

“3”から始まるBitcoinアドレスはpay-to-script hash (P2SH)アドレスであり、ときどき間違ってマルチシグネチャーアドレスまたはマルチシグアドレスと呼ばれます。これらではBitcoinトランザクションの受取人を、公開鍵の所有者の代わりにscriptのハッシュを使って指定します。この特徴は、2012年にBitcoin Improvement Proposal 16または BIP0016 (<<bip0016>>参照)で導入され、幅広く採用されています。というのは、この特徴により、アドレス自体に機能を追加することができるようになったためです。“1”から始まるBitcoinアドレスに資金を“送る”トランザクション(((("BIP0016")))((("Pay-to-Public-Key-Hash (P2PKH)"))) pay-to-public-key-hash (P2PKH)とも呼ばれる)と違って、“3”で始まるBitcoinアドレスに送った資金のトランザクションでは、公開鍵ハッシュと秘密鍵署名以外の別のものも要求されます。要求されるものはBitcoinアドレスを作ったときにscriptの中で指定され、このBitcoinアドレスへの全てのインプットでそれらが要求されます。
    
pay-to-scriptハッシュアドレスはトランザクションscriptから生成され、トランザクションアウトプットを誰が使えるかということを定義しています(詳細については<<p2sh>>参照)。pay-to-scriptハッシュアドレスのエンコードはBitcoinアドレスを生成するときに使われる二重ハッシュ関数と同じ関数を使って行われ、公開鍵の代わりにscriptにのみ適用されます。
    
----
script hash = RIPEMD160(SHA256(script))
----
    
((("script hashes")))出力された"script hash"はversion prefix 5でBase58Checkエンコーディングされ、これは +3+ から始まるものになっています。P2SHアドレスの例は、+32M8ednmuyZ2zVbes4puqe44NZumgG92sM+ で、これはBitcoin Explorerコマンド((("Bitcoin Explorer","script-encode command")))((("script-encode command (bx)"))) +script-encode+ 、 ((("Bitcoin Explorer","sha256 command")))((("sha256 command (bx)"))) +sha256+ 、 ((("Bitcoin Explorer","ripemd160 command")))((("ripemd160 command (bx)"))) +ripemd160+ 、 ((("Bitcoin Explorer","base58check-encode command")))((("base58check-encode command (bx)"))) +base58check-encode+ (<<libbitcoin>>参照) を使って生成することができます。

----
$ echo dup hash160 [ 89abcdefabbaabbaabbaabbaabbaabbaabbaabba ] equalverify checksig > script
$ bx script-encode < script | bx sha256 | bx ripemd160 | bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM
----

[TIP]
====
P2SHはマルチシグネチャーの標準トランザクションというわけでありません。P2SHアドレスは _ほぼ常に_ マルチシグネチャーscriptを表しますが、他のトランザクションタイプのscriptを表す可能性もあるのです。 
====

===== マルチシグネチャーアドレスとP2SH

現在、P2SHの最も一般的な実装は、マルチシグネチャーアドレスscriptです。この名前が示しているように、scriptは所有権を証明し資金を利用するために１つ以上の署名を要求します。Bitcoinマルチシグネチャーは、N個のキーから作られるM個の署名(“threshold”とも呼ばれます)を要求し、これはM-of-N multi-sigと呼ばれています。ここで、MはNと等しいか小さい数です。例えば、<<ch01_intro_what_is_bitcoin>>に出てきたコーヒーショップのオーナーのボブは、彼のキーと彼の奥さんのキーから作られる1-of-2 シグネチャーを要求するマルチシグネチャーアドレスを使うことができ、このアドレスに紐づいたトランザクションアウトプットを使うには彼または奥さんのどちらか一方のキーで署名すればよいのです。Gopesh(ボブのウェブサイトを作ったウェブデザイナ)がビジネス用に2-of-3マルチシグネチャーアドレスを持っていたとすると、少なくともビジネスパートナーの２人がトランザクションに署名しなければこのアドレスに紐づく資金を使うことができません。 

<<transactions>>で、P2SH(とマルチシグネチャー)でのトランザクションの作成方法について説明します。

==== Vanity Addresses

((("addresses, bitcoin","vanity", id="ix_ch04-asciidoc26", range="startofrange")))((("vanity addresses", id="ix_ch04-asciidoc27", range="startofrange")))文字列指定のあるBitcoinアドレス(Vanity Address)は人間が読むことができるメッセージを含んだBitcoinアドレスです。例えば、+1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33+ には、最初の四文字に"Love"という単語が含まれています。Vanity addressでは、Bitcoinアドレスに望んだパターンが出るまで何回も秘密鍵を生成しチェックしなければいけません。vanity addressを生成するいくつかの効率的な方法があるものの、基本的に秘密鍵をランダムに生成して公開鍵、Bitcoinアドレスを導出、vanityパターンに合っているかチェックするということを数十億回繰り返す必要があります。 

一度望んだパターンを含むvanity addressが見つかると、それを導出した秘密鍵はvanity address以外のときと全く同じ方法でbitcoinの使用に使われます。vanity addressの安全性は他のアドレスと全く変わりません。vanity address以外のときと同じように安全性はElliptic Curve Cryptography (ECC)とSecure Hash Algorithm (SHA)に依っています。vanity addressはこれ以外のアドレスよりも作ることが難しいのです。

<<ch01_intro_what_is_bitcoin>>でフィリピンで子供たちのチャリティー活動を行っているEugeniaを紹介しました。Eugeniaがbitcoinによる寄付を募るためにvanity addressを作りたいと考えているとしましょう。Eugeniaは"1Kids"から始まるvanity addressを作ることにしました。どのようにvanity addressが作られ、Eugeniaのチャリティー活動のセキュリティにどう影響するか見ていきましょう。 

===== vanity addressの生成

((("vanity addresses","generating", id="ix_ch04-asciidoc28", range="startofrange")))BitcoinアドレスはBase58文字で表されている数字であるため、"1Kids"のようなパターンの探索は、 +1Kids11111111111111111111111111111+ から +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+ の範囲に入るアドレスを探すことになります。近似的に58^29^(約1.4 * 10^51^)個のアドレスがこの範囲にあり、全て"1Kids"から始まっています。<<table_4-11>>は1Kidsから始まるアドレスの範囲を示しています。

[[table_4-11]]
."1Kids"から始まるvanityアドレスの範囲
|=======
| *From* | +1Kids11111111111111111111111111111+
| | +1Kids11111111111111111111111111112+
| | +1Kids11111111111111111111111111113+
| | +...+
| *To* | +1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz+
|=======

特別なハードウェアではなく一般的なデスクトップパソコンでだいたい秒間100,000個のキーを探すことができると想定すると、どれくらいの時間で望んだパターンを含むBitcoinアドレスが現れるでしょうか(<<table_4-12>>参照)。

[[table_4-12]]
.vanityパターン(1KidsCharity)の出現頻度と、デスクトップPCでの平均探索時間
[options="header"]
|=======
| Length | Pattern | Frequency | Average search time
| 1 | 1K | 1 in 58 keys | < 1 milliseconds
| 2 | 1Ki| 1 in 3,364 | 50 milliseconds 
| 3 | 1Kid | 1 in 195,000 | < 2 seconds
| 4 | 1Kids | 1 in 11 million | 1 minute
| 5 | 1KidsC | 1 in 656 million | 1 hour
| 6 | 1KidsCh | 1 in 38 billion | 2 days
| 7 | 1KidsCha | 1 in 2.2 trillion | 3–4 months
| 8 | 1KidsChar | 1 in 128 trillion | 13–18 years
| 9 | 1KidsChari | 1 in 7 quadrillion | 800 years
| 10 | 1KidsCharit | 1 in 400 quadrillion | 46,000 years
| 11 | 1KidsCharity | 1 in 23 quintillion | 2.5 million years
|=======


このように、たとえ数千台のコンピュータが使えたとしてもEugeniaは"1KidsCharity"を含むvanity addressをすぐに作ることはできないでしょう。望むパターンの文字数が１個増えると見つける難しさは58倍になります。７文字より多いパターンだと通常特別に設計されたハードウェアが必要になり、複数の((("graphical processing units (GPUs)"))) graphical processing units (GPUs)を積んだカスタムデスクトップが必要になります。特別に設計されたハードウェアとして、Bitcoinマイニングではもう利益を生まなくなったBitcoin mining "rigs"をvanity address生成に転用することがよくあります。GPUで組まれたものを使うと、汎用CPUに比べてはるかに速く計算できるのです。 

((("vanity-miners")))vanity addressを見つけるもう１つの方法は、vanityマイナープールに依頼することです。例えば、http://vanitypool.appspot.com[Vanity Pool] です。これはGPUハードウェアを使ってvanity addressを見つけ出すことで儲けを出そうとしている集団です。少ない費用(0.01bitcoin、この執筆段階では約$5)でEugeniaは７文字のパターンを持つvanity addressの探索を外注に出すことができ、数時間後に結果を得ることができるようになります。 

vanity addressの生成は、１つずつを確認していく総当たり方式です。１個１個ランダムにキーを作ってみて、望んだパターンに合っているか確認します。<<vanity_miner_code>> は"vanityマイナー"の例で、C++で書かれたvanity addressを探すプログラムです。例では<<alt_libraries>>で紹介した((("libbitcoin library","finding vanity addresses with"))) libbitcoinライブラリを使っています。

[[vanity_miner_code]]
.vanityアドレスマイナー
====
[source,cpp]
----
include::code/vanity-miner.cpp[]
----
====

[NOTE]
====
上記の例コードでは +std::random_device+ を使用しており、これは裏で動作しているオペレーティングシステムによって提供されている暗号学的に安全な乱数生成器(CSRNG)の値を反映しています。LinuxのようなUNIX-likeなオペレーティングシステムの場合だとこれは +/dev/urandom+ から乱数を取得しています。ここで使われている乱数生成器はデモ目的のものであり、十分なセキュリティを持ったように実装されていないので商用レベルのクオリティを持ったBitcoinキーを生成するには適切では _ありません_ 。
====

この例コードでは、C++コンパイラとlibbitcoinライブラリを使ってコンパイルする必要があります。例コードを動作させるには、 ++vanity-miner++ 実行ファイルを引数なしで実行(<<vanity_miner_run>>参照)し、実行すると"1kid"から始まるvanity addressを見つけ始めます。

[[vanity_miner_run]]
.vanity-minerコード例のコンパイルと実行
====
[source,bash]
----
$ # Compile the code with g++
$ g++ -o vanity-miner vanity-miner.cpp $(pkg-config --cflags --libs libbitcoin)
$ # Run the example
$ ./vanity-miner
Found vanity address! 1KiDzkG4MxmovZryZRj8tK81oQRhbZ46YT
Secret: 57cc268a05f83a23ac9d930bc8565bac4e277055f4794cbd1a39e5e71c038f3f
$ # Run it again for a different result
$ ./vanity-miner
Found vanity address! 1Kidxr3wsmMzzouwXibKfwTYs5Pau8TUFn
Secret: 7f65bbbbe6d8caae74a0c6a0d2d7b5c6663d71b60337299a1a2cf34c04b2a623
# Use "time" to see how long it takes to find a result
$ time ./vanity-miner
Found vanity address! 1KidPWhKgGRQWD5PP5TAnGfDyfWp5yceXM
Secret: 2a802e7a53d8aa237cd059377b616d2bfcfa4b0140bc85fa008f2d3d4b225349

real	0m8.868s
user	0m8.828s
sys	0m0.035s
----
====

例コードは３文字のパターン"kid"と合うBitcoinアドレスを探すのに数秒かかります。これはUnixコマンド +time+ で計測したものです。ソースコードの中にある +search+ パターンを変えて、４文字または５文字パターンにするとどれくらい処理に時間がかかるようになるかやってみてください！(((range="endofrange", startref="ix_ch04-asciidoc28")))

===== Vanity addressのセキュリティ

((("security","of vanity addresses")))((("security","vanity addresses and")))((("vanity addresses","security and")))vanity addressはセキュリティを増す方向に _も_ 下げる方向にも働きます。まさに諸刃の剣なのです。セキュリティを改善する方向に使われるとすると、特色があり見て分かりやすいアドレスであるため、悪意ある者があなたのお客さんをだまし自身のアドレスに支払いをさせることが難しくなります。他方セキュリティを下げる方向に使われるとすると、vanity addressでは誰でも似たアドレスを作ることができるため、似たアドレスを使ってお客さんをだますこともできてしまいます。 

Eugeniaは、ランダムに生成されたBitcoinアドレス(例えば、+1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+)を使って寄付を募ることもできます。また、1Kidsから始まるvanity addressを作って、区別しやすいアドレスにすることもできます。 

どちらの場合でも、１つだけのアドレス(寄付者ごとに区分けされたアドレスではなく)を使うことのリスクの１つは、侵入者があなたのウェブサイトに侵入しBitcoinアドレスを侵入者のBitcoinアドレスに置き換えてしまうことです。もし寄付用のBitcoinアドレスをすでに多くの場所に貼り出しているとしたら、寄付者は寄付をする前に、前にウェブサイトやメール、チラシで見たBitcoinアドレスと同じであるかを確認するかもしれません。+1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy+のようなランダムなBitcoinアドレスを使っている場合、大方の人はおそらく最初の数文字、"1J7mdg" だけを見てBitcoinアドレスが合っているか判断するでしょう。vanity addressを使っていると、見た目が似ているBitcoinアドレスですりかえようとしている誰かが、最初の数文字だけ合っているBitcoinアドレスをすばやく作ることができてしまいます。

[[table_4-13]]
.ランダムなアドレスに先頭が一致するvanityアドレスの生成
|=======
| *Original Random Address* | 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
| *Vanity (4 character match)* | 1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy
| *Vanity (5 character match)* | 1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n
| *Vanity (6 character match)* | 1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX
|=======

vanity addressはセキュリティを向上させるのでしょうか？Eugeniaがvanity address +1Kids33q44erFfpeXrmDSz7zEqG2FesZEN+ を作ったとすると、人々はvanityパターンの単語 _と次の数文字_ だけを見て正しいかどうかを見ます。例えば、"1Kids33"だけです。悪意ある者は最初の６文字か８文字だけ合っているvanity addressを作りますが、２文字多く一致しているvanity addressを生成する労力はEugeniaが4文字のvanity addressを作るために使った労力の3,364倍(58 &#x00D7; 58)です。本質的に、Eugeniaがつぎ込んだ(またはvanityプールにアドレス生成を頼んだ)労力が多ければ、この悪意ある者はさらに長いvanityパターンの作成を"強いられる"ことになります。もしEugeniaが8文字のvanity addressの生成を頼んでいたとすると、この悪意ある者は10文字のvanity addressを作らなければ いけません。これはパーソナルコンピュータ上では実行できずカスタマイズされたvanity-mining rigやvanityプールでさえ高価になってしまいます。特にもし詐欺を行うことで悪意ある者が得られる報酬がvanity addressの生成コストをカバーするほど高くないなら、Eugeniaには入手可能なアドレスでもこの攻撃者には入手不可能になります。(((range="endofrange", startref="ix_ch04-asciidoc27")))(((range="endofrange", startref="ix_ch04-asciidoc26"))) 

[[paper_wallets]]
==== ペーパーウォレット

((("backups","paper wallets", id="ix_ch04-asciidoc29", range="startofrange")))((("cold-storage wallets","paper wallets as", id="ix_ch04-asciidoc30", range="startofrange")))((("paper wallets", id="ix_ch04-asciidoc31", range="startofrange")))((("wallets","paper", id="ix_ch04-asciidoc32", range="startofrange")))ペーパーウォレットは秘密鍵を紙の上に印刷したものです。よくペーパーウォレットは利便性のため秘密鍵に対応するBitcoinアドレスも含んでいます。しかし、Bitcoinアドレスは秘密鍵から導出できるためこれは必須ではありません。ペーパーウォレットはバックアップやオフラインBitcoinストレージを作るとても効率的な方法で、"コールドストレージ"とも呼ばれています。ペーパーウォレットはハードドライブの破損、盗難、また間違ってデータを削除してしまった場合などによるキーの紛失に対するバックアップとして機能します。もしペーパーウォレットのキーがオフラインで生成されてコンピュータ上に保存されていないとすると、ペーパーウォレットはハッカーやキーロガー、その他のオンライン上の脅威などに対する安全性が増す"コールドストレージ"として機能します。 

ペーパーウォレットにはいろいろな形、大きさ、デザインがありますが、基本的に秘密鍵とBitcoinアドレスが紙に印刷されているだけのものです。<<table_4-14>>は最も簡単なペーパーウォレットを示しています。

[[table_4-14]]
.ペーパーウォレットの最もシンプルな形-Bitcoinアドレスと秘密鍵の印刷
[options="header"]
|=======================
|Public Address|Private Key (WIF)
|1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x|5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
|=======================


((("bitaddress.org","paper wallets, generating")))ペーパーウォレットは _bitaddress.org_ でのクライアント側JavaScriptツールなどを使って簡単に作ることができます。このページには、インターネットに接続していなくてもペーパーウォレットが作れるコードが含まれています。それを使うために、HTMLページをローカルドライブ、または外部USBフラッシュドライブに保存してください。インターネットから切り離された状態で、ブラウザで保存したHTMLページを開いてみてください。より最適な状況を作り出すためには、CD-ROMで起動できるLinux OSのようなもっと簡素なオペレーティングシステムを使って起動し直してください。ツールを使って生成したどんなキーでもUSBケーブル(無線ではなく)で繋がれたローカルプリンタで印刷することができます。これにより、オンラインから切り離されたペーパーウォレットを作ることができます。これらのペーパーウォレットを耐火金庫に入れ、bitcoinをペーパーウォレット上のBitcoinアドレスに"送り"ます。ペーパーウォレットはとてもシンプルですが、極めて効果的な"コールドストレージ"です。

[[paper_wallet_simple]]
.bitaddress.orgから持ってきたシンプルなペーパーウォレットの例
image::images/msbt_0414.png[]

簡単なペーパーウォレットの不利な点は、盗難される可能性があることです。盗難者は紙を盗む、またはペーパーウォレットの写真を撮ることでこれらのキーに紐づいているbitcoinをコントロールできるようになります。より洗練されたペーパーウォレットストレージはBIP0038暗号化秘密鍵を使う方法です。ペーパーウォレットに印刷されたキーは、所有者が記憶しているパスフレーズによって守られています。パスフレーズなしでは、暗号化されたキーを使うことはできません。暗号化秘密鍵を使ったペーパーウォレットは単なるパスフレーズで保護されたウォレットよりも安全です。というのは、オンラインに晒されることがないということと、金庫またはその他の安全なストレージから物理的に取り出さなければいけないということがあるためです。<<paper_wallet_encrypted>>図はbitaddress.org上で作られた暗号化秘密鍵(BIP0038)によるペーパーウォレットを示しています。 

[[paper_wallet_encrypted]]
.bitaddress.org.から持ってきた暗号化されたペーパーウォレットの例。パスフレーズは"test"。
image::images/msbt_0415.png[]

[WARNING]
====
((("paper wallets","spending")))((("private keys","exposing with paper wallets")))何回かペーパーウォレットに資金を預けることはできますが、ペーパーウォレットから引き出すときは全ての資金を一度に引き出すべきです。これは、資金のロックを解除して使用するプロセスでいくつかのウォレットはおつり用のアドレスを生成するかもしれないからです。さらに、もしトランザクションに署名するために使ったコンピュータに脆弱性があった場合、秘密鍵が漏洩してしまうかもしれません。ペーパーウォレットの残高全てを一度に使うことによってキーが漏洩してしまうリスクを減らすことになります。もし小さい額だけ必要なのであれば、同じトランザクション内で新しいペーパーウォレットに残りの資金を送ってください。
====

ペーパーウォレットは多くのデザイン、大きさがあり、また多くの異なる特徴をそれぞれ持っています。いくつかはギフトとして使われることを想定したものであり、クリスマスや新年など季節ごとのテーマを持ったデザインが施されています。また、他のいくつかは銀行の格納庫、または金庫に置くことを想定されたもの、削るスクラッチがついたものなどがあります。図 pass:[<xref linkend="paper_wallet_bpw" xrefstyle="select: labelnumber"/>] から 図 pass:[<xref linkend="paper_wallet_spw" xrefstyle="select: labelnumber"/>] はいろいろな種類のペーパーウォレットを紹介しています。

[[paper_wallet_bpw]]
.折りたたみ部分に秘密鍵が置かれた bitcoinpaperwallet.com ペーパーウォレット例
image::images/msbt_0416.png[]

[[paper_wallet_bpw_folded]]
.秘密鍵部分が覆われて見えないようになっている bitcoinpaperwallet.com ペーパーウォレット
image::images/msbt_0417.png[]

他のデザインでは、チケットのように切り離し可能になっていて、火事や洪水など自然災害があってもいいようにキーとBitcoinアドレスの複数のコピーが持てるようになっているものもあります。(((range="endofrange", startref="ix_ch04-asciidoc32")))(((range="endofrange", startref="ix_ch04-asciidoc31")))(((range="endofrange", startref="ix_ch04-asciidoc30")))(((range="endofrange", startref="ix_ch04-asciidoc29"))) 

[[paper_wallet_spw]]
.バックアップ用の"切り離し部分"にキーのコピーがあるペーパーウォレットの例
image::images/msbt_0418.png[]



