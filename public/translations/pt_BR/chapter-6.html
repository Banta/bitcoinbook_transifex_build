<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.7" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="bitcoin_network_ch06">A Rede Bitcoin</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_a_arquitetura_de_rede_ponto_a_ponto">A Arquitetura de Rede Ponto-a-Ponto</h3>
<div class="paragraph"><p>O Bitcoin é estruturado como uma arquitetura de rede ponto-a-ponto em cima da Internet. O termo ponto-a-ponto, ou P2P (do inglês peer-to-peer), significa que os computadores que participam da rede são pontos uns para os outros, que eles são todos iguais, que não há nodos "especiais" e que todos os nodos compartilham o trabalho de fornecer serviços na rede. Os nodos da rede se interconectam em uma rede mesh com uma topologia "plana". Não há nenhum servidor, nenhum serviço centralizado ou hierarquia na rede. Os nodos em uma rede ponto-a-ponto tanto fornecem quanto consomem serviços ao mesmo tempo com a reciprocidade atuando como o incentivo para a participação. Redes ponto-a-ponto são inerentemente resilientes, descentralizadas e abertas. O exemplo proeminente de uma arquitetura de rede P2P foi a Internet em seu início, onde os nodos na rede IP eram iguais. A arquitetura de Internet hoje é mais hierárquica, mas o Protocolo da Internet ainda mantém sua essência de topologia plana. Além do bitcoin, a aplicação mais difundida e de maior sucesso das tecnologias P2P é o compartilhamento de arquivos, com o Napster sendo o pioneiro e o BitTorrent como a evolução mais recente da arquitetura.</p></div>
<div class="paragraph"><p>A arquitetura de rede P2P do Bitcoin é muito mais do que uma escolha de topologia. O bitcoin é projetado como um sistema de dinheiro digital ponto-a-ponto, e a arquitetura da rede é tanto um reflexo e uma base fundamental dessa característica chave. Descentralização do controle é um princípio chave do projeto e ela só pode ser obtida e mantida através de uma rede de consenso P2P descentralizada.</p></div>
<div class="paragraph"><p>O termo "rede bitcoin" refere-se à coleção de nodos executando o protocolo ponto-a-ponto (P2P) bitcoin. Além do protocolo P2P bitcoin, existem outros protocolos como o Stratum, que são usados para mineração e carteiras leves ou móveis. Esses protocolos adicionais são fornecidos por servidores de roteamento de gateway que acessam a rede bitcoin usando o protocolo P2P bitcoin, e então estendem essa rede aos nodos executando outros protocolos. Por exemplo, os servidores Stratum se conectam os nodos mineradores Stratum através do protocolo Stratum à rede bitcoin principal e fazem um bridge do protocolo Statum com o protocolo P2P bitcoin. Nós usamos o termo "rede bitcoin estendida" para referirmos à rede geral que inclui o protocolo P2P bitcoin, protocolos de mineração-pool, o protocolo Stratum e qualquer outros protocolos relacionados que conectem os componentes do sistema bitcoin.</p></div>
</div>
<div class="sect2">
<h3 id="_tipos_e_papéis_dos_nodos">Tipos e Papéis dos Nodos</h3>
<div class="paragraph"><p>Embora os nodos na rede P2P do bitcoin são iguais, eles podem assumir diferentes papéis dependendo da funcionalidade que eles estejam suportando. Um nodo bitocin é uma coleção de funções: roteamento, o banco de dados da blockchain, mineração e serviços de carteira. Um nodo completo com todas essas quatro funções é demonstrado em <a href="#full_node_reference">[full_node_reference]</a>.</p></div>
<div class="imageblock" id="full_node_reference">
<div class="content">
<img src="images/msbt_0601.png" alt="FullNodeReferenceClient_Small" />
</div>
<div class="title">Figure 1. Um nodo da rede Bitcoin com todas as quatro funções: carteira, minerador, banco de dados completo da blockchain e roteador da rede</div>
</div>
<div class="paragraph"><p>Todos os nodos incluem a função de roteamento para participar  na rede e podem incluir outras funcionalidades. Todos os nodos validam e propagam as transações e blocos, e descobrem e mantém conexões com os pontos. No exemplo do nodo completo em <a href="#full_node_reference">[full_node_reference]</a>, a função de roteamento é indicada por um círculo laranja chamado de "Nodo de Roteamento de Rede."</p></div>
<div class="paragraph"><p>Some nodes, called full nodes, also maintain a complete and up-to-date copy of the blockchain. Full nodes can autonomously and authoritatively verify any transaction without external reference. Some nodes maintain only a subset of the blockchain and verify transactions using a method called <em>simplified payment verification</em>, or SPV. These nodes are known as SPV or lightweight nodes. In the full-node example in the figure, the full-node blockchain database function is indicated by a blue circle named "Full Blockchain." In <a href="#bitcoin_network">[bitcoin_network]</a>, SPV nodes are drawn without the blue circle, showing that they do not have a full copy of the blockchain.</p></div>
<div class="paragraph"><p>Os nodos de mineração competem para criar novos blocos ao utilizarem hardware especializado para resolver os algoritmos de prova-de-trabalho. Alguns nodos de mineração também são nodos completos, mantendo uma cópia completa da blockchain, enquanto outros são nodos peso leve (lightweight) que participam de um pool de mineração e dependem de um servidor de pool para manter um nodo completo. A função de mineração é demonstrada no nodo completo como um círculo preto chamado de "Minerador."</p></div>
<div class="paragraph"><p>As carteiras de usuários podem fazer parte de um nodo completo, que é o que geralmente ocorre em clientes desktop do bitcoin. Cada vez mais as carteiras de usuário são nodos VSP, especialmente aquelas sendo executadas em dispositivos com poucos recursos como smartphones. A função carteira é demonstrada <a href="#full_node_reference">[full_node_reference]</a> em como um círculo verde chamado de "Carteira"</p></div>
<div class="paragraph"><p>Além dos tipos de nodos principais no protocolo P2P bitcoin, existem servidores e nodos executando outros protocolos, como protocolos especializados em mineração-pool e protocolos de acesso de clientes com aplicativos leves (lightweight).</p></div>
<div class="paragraph"><p><a href="#node_type_ledgend">[node_type_ledgend]</a> mostra os tipos mais comuns de nodos na rede bitcoin estendida.</p></div>
</div>
<div class="sect2">
<h3 id="_a_rede_bitcoin_estendida">A Rede Bitcoin Estendida</h3>
<div class="paragraph"><p>The main bitcoin network, running the bitcoin P2P protocol, consists of between 7,000 and 10,000 listening nodes running various versions of the bitcoin reference client (Bitcoin Core) and a few hundred nodes running various other implementations of the bitcoin P2P protocol, such as BitcoinJ, Libbitcoin, and btcd. A small percentage of the nodes on the bitcoin P2P network are also mining nodes, competing in the mining process, validating transactions, and creating new blocks. Various large companies interface with the bitcoin network by running full-node clients based on the Bitcoin Core client, with full copies of the blockchain and a network node, but without mining or wallet functions. These nodes act as network edge routers, allowing various other services (exchanges, wallets, block explorers, merchant payment processing) to be built on top.</p></div>
<div class="paragraph"><p>A rede bitcoin estendida inclui a rede executando o protocolo P2P bitcoin, descrita anteriormente, assim como nodos executando protocolos especializados. Ligados a essa rede P2P bitcoin principal existem vários servidores pool e gateways de protocolo que conectam nodos executando outros protocolos. Esses nodos usando outros protocolos são em sua maioria nodos de pool de mineração  (ver <a href="#ch8">[ch8]</a>)e clientes de carteira leves (lightweight), que não carregam uma cópia completa de blockchain.</p></div>
<div class="paragraph"><p><a href="#bitcoin_network">[bitcoin_network]</a> demonstra a rede bitcoin estendida com os vários tipos de nodos, servidores gateway, roteadores edge e clientes de carteira, além dos vários protocolos que eles usam para conectar-se uns com os outros.</p></div>
<div class="imageblock" id="node_type_ledgend">
<div class="content">
<img src="images/msbt_0602.png" alt="BitcoinNodeTypes" />
</div>
<div class="title">Figure 2. Diferentes tipos de nodos na rede bitcoin estendida</div>
</div>
<div class="imageblock" id="bitcoin_network">
<div class="content">
<img src="images/msbt_0603.png" alt="BitcoinNetwork" />
</div>
<div class="title">Figure 3. A rede bitcoin estendida mostrando vários tipos de nodos, gateways e protocolos</div>
</div>
</div>
<div class="sect2">
<h3 id="_descoberta_da_rede">Descoberta da Rede</h3>
<div class="paragraph"><p>Quando um novo nodo é ligado, ele deve descobrir outros nodos bitoins na rede para que possa participar. Para iniciar esse processo, um nodo novo deve descobrir pelo menos um nodo existente na rede para conectar-se a ele. A localização geográfica dos outros nodos é irrelevante; a topologia da rede bitcoin não é definida geograficamente. Logo, qualquer nodo bitcoin existente pode ser selecionado aleatoriamente.</p></div>
<div class="paragraph"><p>Para se conectar a um ponto conhecido, os nodos estabelecem uma conexão TCP, geralmente na porta 8333 (a porta geralmente conhecida como uma das usadas pelo bitcoin), ou a uma porta alternativa caso tenha sido fornecida. Ao estabelecer a conexão, o nodo iniciará um "aperto de mão" (ver <a href="#network_handshake">[network_handshake]</a>) ao transmitir uma mensagem de <tt>versão</tt>, que contém basicamente informações de identificação, incluindo:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
<tt>PROTOCOL_VERSION</tt>
</dt>
<dd>
<p>
Uma constante que define a versão do protocolo P2P do bitcoin através da qual o cliente se "comunica" (ex: 70002)
</p>
</dd>
<dt class="hdlist1">
<tt>nLocalServices</tt>
</dt>
<dd>
<p>
Uma lista dos serviços locais suportados pelo nodo, atualmente apenas <tt>NODE_NETWORK</tt>
</p>
</dd>
<dt class="hdlist1">
<tt>nTime</tt>
</dt>
<dd>
<p>
A hora atual
</p>
</dd>
<dt class="hdlist1">
<tt>addrYou</tt>
</dt>
<dd>
<p>
O endereço IP do nodo remoto da maneira que é visto por esse nodo
</p>
</dd>
<dt class="hdlist1">
<tt>addrMe</tt>
</dt>
<dd>
<p>
O endereço IP do nodo local, da maneira que é descoberto pelo nodo local
</p>
</dd>
<dt class="hdlist1">
<tt>subver</tt>
</dt>
<dd>
<p>
Uma sub-versão mostrando o tipo de software sendo executado nesse nodo (ex: "/Satoshi:0.9.2.1/")+
</p>
</dd>
<dt class="hdlist1">
<tt>BestHeight</tt>
</dt>
<dd>
<p>
A altura dos blocos da blockchain deste nodo
</p>
</dd>
</dl></div>
<div class="paragraph"><p>(Veja <a href="http://bit.ly/1qlsC7w">GitHub</a> para um exemplo da mensagem de rede <tt>version</tt>.)</p></div>
<div class="paragraph"><p>O nodo ponto responde com <tt>verack</tt> para reconhecer e estabelecer uma conexão, e opcionalmente envia sua própria mensagem <tt>versão</tt> caso ele desejar estabelecer uma conexão recíproca e se conectar como um ponto.</p></div>
<div class="paragraph"><p>How does a new node find peers? The first method is to query DNS using a number of "DNS seeds," which are DNS servers that provide a list of IP addresses of bitcoin nodes. Some of those DNS seeds provide a static list of IP addresses of stable bitcoin listening nodes. Some of the DNS seeds are custom implementations of BIND (Berkeley Internet Name Daemon) that return a random subset from a list of bitcoin node addresses collected by a crawler or a long-running bitcoin node.  The Bitcoin Core client contains the names of five different DNS seeds. The diversity of ownership and diversity of implementation of the different DNS seeds offers a high level or reliability for the initial bootstrapping process. In the Bitcoin Core client, the option to use the DNS seeds is controlled by the option switch <tt>-dnsseed</tt> (set to 1 by default, to use the DNS seed).</p></div>
<div class="paragraph"><p>De maneira alternativa, um nodo bootstrapping que não saiba nada da rede deve receber o endereço IP de pelo menos um nodo bitcoin, a partir do qual ele poderá estabelecer conexões através de novas introduções. O argumento de linha de comando <tt>-seednode</tt> pode ser usado para conectar a um nodo somente para introduções, utilizando-o como uma semente (seed). Após o nodo semente inicial ser usado para formar as introduções, o cliente irá se desconectar dele e usará os novos pontos recém-descobertos.</p></div>
<div class="imageblock" id="network_handshake">
<div class="content">
<img src="images/msbt_0604.png" alt="NetworkHandshake" />
</div>
<div class="title">Figure 4. O aperto de mãos inicial entre os pontos</div>
</div>
<div class="paragraph"><p>Assim que uma ou mais conexões são estabelecidas, o novo nodo irá enviar uma mensagem <tt>addr</tt> contendo seu próprio endereço IP para seus vizinhos. Seus vizinhos irão, por sua vez, retransmitir a mensagem <tt>addr</tt> para seus vizinhos, garantindo que os novos nodos conectados se tornem bem conhecidos e melhor conectados. Adicionalmente, o novo nodo conectado pode enviar <tt>getaddr</tt> para os vizinhos, solictando-os que retornem uma lista de endereços IP de seus pontos. Dessa maneira, um nodo pode encontrar pontos para conectar-se e divulgar sua existência na rede para que outros nodos o encontrem. <a href="#address_propagation">[address_propagation]</a> demonstra o protocolo de descoberta de endereço.</p></div>
<div class="imageblock" id="address_propagation">
<div class="content">
<img src="images/msbt_0605.png" alt="AddressPropagation" />
</div>
<div class="title">Figure 5. Propagação e descoberta do endereço</div>
</div>
<div class="paragraph"><p>A node must connect to a few different peers in order to establish diverse paths into the bitcoin network. Paths are not reliable—nodes come and go—and so the node must continue to discover new nodes as it loses old connections as well as assist other nodes when they bootstrap. Only one connection is needed to bootstrap, because the first node can offer introductions to its peer nodes and those peers can offer further introductions. It&#8217;s also unnecessary and wasteful of network resources to connect to more than a handful of nodes. After bootstrapping, a node will remember its most recent successful peer connections, so that if it is rebooted it can quickly reestablish connections with its former peer network. If none of the former peers respond to its connection request, the node can use the seed nodes to bootstrap again.</p></div>
<div class="paragraph"><p>Em um nodo executando o cliente Bitcoin Core, você pode listar as conexões com os peers através do comando <tt>getpeerinfo</tt>:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Para desativar a administração automática dos pontos e especificar uma lista de endereços IP, os usuários podem usar a opção <tt>-connect=&lt;EndereçoIP&gt;</tt> e especificar um ou mais endereços IP. Se essa opção for utilizada, o nodo irá conectar-se somente aos endereços IP selecionados, ao invés de automaticamente descobrir e manter conexões com pontos.</p></div>
<div class="paragraph"><p>Se não houver tráfico em uma conexão, os nodos irão periodicamente enviar uma mensagem para manter a conexão. Se um nodo não se comunicar em uma conexão por mais de 90 minutos, assume-se que ele esteja desconectado e um novo ponto será procurado. Logo, a rede dinamicamente ajusta-se aos nodos transitórios e aos problemas da rede, e pode crescer e diminuir organicamente conforme necessário, sem a necessidade de um controle central. </p></div>
</div>
<div class="sect2">
<h3 id="_nodos_completos">Nodos completos</h3>
<div class="paragraph"><p>Os nodos completos são nodos que mantém uma blockchain completa com todas as transações. Mais precisamente, eles provavelmente deveriam ser chamados de "nodos com a blockchain completa". Nos anos iniciais do bitcoin, todos os nodos eram nodos completos e atualmente o cliente Bitcoin Core é um nodo com a blockchain completa. Nos últimos dois anos, no entanto, novas formas de clientes bitcoins foram introduzidas que não precisam manter uma blockchain completa, mas são executandos como clientes leves ("lightweight"). Nós examinaremos esses clientes em mais detalhes na próxima seção.</p></div>
<div class="paragraph"><p>Os nodos com a blockchain completa mantém uma cópia completa e atualizada da blockchain do bitcoin com todas as transações, a qual eles independentemente construiram e verificaram, iniciando desde o primeiro bloco (bloco gênese) e adicionando até o último bloco conhecido da rede. O nodo com a blockchain completa pode verificar independentemente e com autoridade qualquer transação sem depender de qualquer outro nodo ou fonte de informação. O nodo completo depende da rede para receber atualizações sobre novos blocos de transações, as quais ele verifica e incorpora em sua cópia local da blockchain.</p></div>
<div class="paragraph"><p>Executar um nodo com a blockchain completa proporciona a experiência bitcoin pura: verificação independente de todas as transações, sem a necessidade de dependência ou confiança em qualquer outro sistema. É fácil dizer se você está executando um nodo completo porque ele requer mais de 20 gigabytes de armazenamento persistente (espaço em diasco) para armazenar a blockchain completa. Se você precisa de muito espaço e ele leva dois a três dias para sincronizar com a rede, você está executando um nodo completo. Esse é o preço que se paga para uma liberdade completa e total independência de uma autoridade central.</p></div>
<div class="paragraph"><p>Existem algumas poucas implementações alternativas dos clientes de bitcoin com a blockchain completa, construídas usando-se diferentes linguagens de programação e arquiteturas de software. No entanto, a implementação mais comum é o cliente de referência Bitcoin Core, também conhecido como o cliente Satoshi. Mais de 90% dos noso na rede bitcoin executam várias versões do Bitcoin Core. Ele é identificado como "Satoshi" na string sub-version enviada na mensagem <tt>version</tt> e é mostrado pelo comando <tt>getpeerinfo</tt> como nós vimos anteriormente; por exemplo, <tt>/Satoshi:0.8.6/</tt>.</p></div>
</div>
<div class="sect2">
<h3 id="_exchanging_inventory">Exchanging "Inventory"</h3>
<div class="paragraph"><p>A primeira coisa que um nodo completo fará assim que se conectar aos pontos é tentar construir uma blockchain completa. Se ele for um nodo recém criado que não tenha nenhuma parte da blockchain, ele só terá um bloco, o bloco gênese, que é incluído estaticamente no software do cliente. Iniciando com o bloco #0 (o bloco gênese), o novo nodo terá que fazer o download de centenas de milhares de blocos para sincronizar-se com a rede e re-estabelecer a blockchain completa.</p></div>
<div class="paragraph"><p>O processo de sincronização da blockchain é iniciado a partir da mensagem <tt>version</tt>, pois ela contém o <tt>BestHeight</tt>, a altura atual (número de blocos) da blockchain de um nodo. Ao ver a mensagem <tt>version</tt> de seus pontos, um nodo saberá quantos blocos cada um deles tem, e será capaz de comparar com o número de blocos que existem em sua própria blockchain. Os nodos pareados irão trocar uma mensagem <tt>getblocks</tt>, a qual contém o hash (impressão digital) do bloco mais alto de suas blockchains locais. A seguir, um ponto será capaz de identificar que o hash recebido pertence ao bloco que não está no topo, mas que pertence a um bloco antigo, logo deduzindo que sua blockchain local é mais comprida do que a de seus pontos.</p></div>
<div class="paragraph"><p>O ponto que tem a blockchain mais longa possui mais blocos que o outro nodo e pode identificar quais blocos o outro nodo precisa para ficar "em dia". Ele irá identificar os primeiros 500 blocos para compartilhar e transmitirá seus hashes usando uma mensagem  <tt>inv</tt> (inventory) . O nodo que estiver com esses blocos faltando irá então recebê-los ao emitir uma série de mensagens <tt>getdata</tt> solicitando os dados completos dos blocos e identificando os blocos solicitados usando os hashes da mensagem <tt>inv</tt>.</p></div>
<div class="paragraph"><p>Let&#8217;s assume, for example, that a node only has the genesis block. It will then receive an <tt>inv</tt> message from its peers containing the hashes of the next 500 blocks in the chain. It will start requesting blocks from all of its connected peers, spreading the load and ensuring that it doesn&#8217;t overwhelm any peer with requests. The node keeps track of how many blocks are "in transit" per peer connection, meaning blocks that it has requested but not received, checking that it does not exceed a limit (<tt>MAX_BLOCKS_IN_TRANSIT_PER_PEER</tt>). This way, if it needs a lot of blocks, it will only request new ones as previous requests are fulfilled, allowing the peers to control the pace of updates and not overwhelming the network. As each block is received, it is added to the blockchain, as we will see in <a href="#blockchain">[blockchain]</a>. As the local blockchain is gradually built up, more blocks are requested and received, and the process continues until the node catches up to the rest of the network.</p></div>
<div class="paragraph"><p>Esse processo de comparar a blockchain local com os pontos e adquirir quaisquer blocos em falta acontece sempre que um bloco fica offline por algum período de tempo. Tenha um nodo ficado offline por alguns minutos e esteja com alguns pouco blocos em falta, ou tenha ficado um mês offeline e esteja com milhares de blocos em falta, ele começa ao enviar <tt>getblocks</tt>, recebeuma resposta <tt>inv</tt> e inicia baixando os blocos remanescentes. <a href="#inventory_synchronization">[inventory_synchronization]</a>  demonstra o inventário e o protocolo de propagação dos blocos.</p></div>
</div>
<div class="sect2">
<h3 id="spv_nodes">Nodos de Verificação Simplificada de Pagamento (VSP)</h3>
<div class="paragraph"><p>Nem todos os nodos tem a habilidade de armazenar a blockchain completa. Muitos clientes bitcoin são projetados para serem executados em dispositivos com limitações de armazenamento e energia, como smartphones, tablets ou sistemas embutidos. Para esses dispositivos, um método de <em>verificação simplificada de pagamento</em> é usado para permití-los que operem sem terem que armazenar a blockchain completa. Esses tipos de clientes são chamados clientes VSP (em inglês, SPV) ou clientes leves. Conforme a adoação do bitcoin aumenta, o nodo VSP está se tornando a forma mais comum de nodo bitcoin, especialmente para carteiras bitcoin.</p></div>
<div class="paragraph"><p>Os nodos VSP baixam apenas os cabeçalhos dos blocos e não baixam as transações incluídas em cada bloco. A cadeia de blocos resultante, sem as transações, é 1.000 vezes menor do que a blockchain completa. Os nodos VSP não podem construir um figura completa de todas as UTXOs que estão disponíveis para serem gastas porque eles não conhecem todas as transações da rede. Os nodos VSP verificam as transações usando uma metodologia levemente diferente, a qual se baseia nos pontos que fornecem, sob demanda, consultas de apenas algumas partes relevantes da blockchain.</p></div>
<div class="imageblock" id="inventory_synchronization">
<div class="content">
<img src="images/msbt_0606.png" alt="InventorySynchronization" />
</div>
<div class="title">Figure 6. Nodo sincronizando a blockchain ao adquirir blocos de um ponto</div>
</div>
<div class="paragraph"><p>As an analogy, a full node is like a tourist in a strange city, equipped with a detailed map of every street and every address. By comparison, an SPV node is like a tourist in a strange city asking random strangers for turn-by-turn directions while knowing only one main avenue. Although both tourists can verify the existence of a street by visiting it, the tourist without a map doesn&#8217;t know what lies down any of the side streets and doesn&#8217;t know what other streets exist. Positioned in front of 23 Church Street, the tourist without a map cannot know if there are a dozen other "23 Church Street" addresses in the city and whether this is the right one. The mapless tourist&#8217;s best chance is to ask enough people and hope some of them are not trying to mug him.</p></div>
<div class="paragraph"><p>A verificação simplificada de pagamento verifica as transações através de referências às suas <em>profundidades</em> na blockchain, ao invés de sua <em>altura</em>. Enquanto um nodo com a blockchain completa irá construir uma cadeia completamente verificada de milhares de blocos e transações que siga pela blockchain (retrospectivamente no tempo) até o bloco gênese, um nodo de VSP irá verificar a cadeia de todos os blocos (mas não todas as transações) e irá ligar essa cadeia à transação de interesse.</p></div>
<div class="paragraph"><p>For example, when examining a transaction in block 300,000, a full node links all 300,000 blocks down to the genesis block and builds a full database of UTXO, establishing the validity of the transaction by confirming that the UTXO remains unspent. An SPV node cannot validate whether the UTXO is unspent. Instead, the SPV node will establish a link between the transaction and the block that contains it, using a <em>merkle path</em> (see <a href="#merkle_trees">[merkle_trees]</a>). Then, the SPV node waits until it sees the six blocks 300,001 through 300,006 piled on top of the block containing the transaction and verifies it by establishing its depth under blocks 300,006 to 300,001. The fact that other nodes on the network accepted block 300,000 and then did the necessary work to produce six more blocks on top of it is proof, by proxy, that the transaction was not a double-spend.</p></div>
<div class="paragraph"><p>An SPV node cannot be persuaded that a transaction exists in a block when the transaction does not in fact exist. The SPV node establishes the existence of a transaction in a block by requesting a merkle path proof and by validating the proof of work in the chain of blocks. However, a transaction&#8217;s existence can be "hidden" from an SPV node. An SPV node can definitely prove that a transaction exists but cannot verify that a transaction, such as a double-spend of the same UTXO, doesn&#8217;t exist because it doesn&#8217;t have a record of all transactions. This vulnerability can be used in a denial-of-service attack or for a double-spending attack against SPV nodes. To defend against this, an SPV node needs to connect randomly to several nodes, to increase the probability that it is in contact with at least one honest node. This need to randomly connect means that SPV nodes also are vulnerable to network partitioning attacks or Sybil attacks, where they are connected to fake nodes or fake networks and do not have access to honest nodes or the real bitcoin network.</p></div>
<div class="paragraph"><p>Para a maioria das funções práticas, os nodos VPS bem-conectados são seguros o suficiente, demonstrando um equilíbrio ideal entre necessidade de recursos, praticidade e segurança. Para segurança infalívil, no entanto, nada é superior do que executar um nodo com a blockchain completa.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Um nodo que tem a blockchain completa verifica a transação ao fazer uma pesquisa em sua cadeia inteira de milhares de blocos, para se certificar de que a UTXO já não foi gasta previamente, enquanto um nodo VSP verifica ao pesquisar quão profundo o bloco está "enterrado" sob os vários blocos acima dele.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>To get the block headers, SPV nodes use a <tt>getheaders</tt> message instead of <tt>getblocks</tt>. The responding peer will send up to 2,000 block headers using a single <tt>headers</tt> message. The process is otherwise the same as that used by a full node to retrieve full blocks. SPV nodes also set a filter on the connection to peers, to filter the stream of future blocks and transactions sent by the peers. Any transactions of interest are retrieved using a <tt>getdata</tt> request. The peer generates a <tt>tx</tt> message containing the transactions, in response. <a href="#spv_synchronization">[spv_synchronization]</a> shows the synchronization of block headers.</p></div>
<div class="imageblock" id="spv_synchronization">
<div class="content">
<img src="images/msbt_0607.png" alt="SPVSynchronization" />
</div>
<div class="title">Figure 7. Nodo SPV sincronizando os cabeçalhos dos blocos</div>
</div>
<div class="paragraph"><p>Because SPV nodes need to retrieve specific transactions in order to selectively verify them, they also create a privacy risk. Unlike full blockchain nodes, which collect all transactions within each block, the SPV node&#8217;s requests for specific data can inadvertently reveal the addresses in their wallet. For example, a third party monitoring a network could keep track of all the transactions requested by a wallet on an SPV node and use those to associate bitcoin addresses with the user of that wallet, destroying the user&#8217;s privacy.</p></div>
<div class="paragraph"><p>Logo após a introdução dos nodos VSP/peso leve, os desenvolvedores bitcoin adicionaram uma funcionalidade chamada <em>filtros bloom</em> para resolver os riscos de privacidade dos nodos VSP. Os filtros bloom permitem que os nodos VSP recebam um conjunto de transações sem que revelem precisamente quais endereços eles estão interessados, através de um mecanismo de filtros que utiliza probabilidades ao invés de padrões fixos.</p></div>
</div>
<div class="sect2">
<h3 id="_filtros_bloom">Filtros Bloom</h3>
<div class="paragraph"><p>Um filtro bloom é um filtro de busca probabilístico, uma maneira de descrever um padrão desejado sem especificá-lo exatamente. Os filtros bloom oferecem uma maneira eficiente de expressar um padrão de brusca enquanto protegem a privacidade. Eles são usados pelos nodos VSP para requisitar seus pontos por transações coincidindo com um padrão específico, sem revelar exatamente quais endereços eles estão procurando.</p></div>
<div class="paragraph"><p>In our previous analogy, a tourist without a map is asking for directions to a specific address, "23 Church St." If she asks strangers for directions to this street, she inadvertently reveals her destination. A bloom filter is like asking, "Are there any streets in this neighborhood whose name ends in R-C-H?" A question like that reveals slightly less about the desired destination than asking for "23 Church St." Using this technique, a tourist could specify the desired address in more detail as "ending in U-R-C-H" or less detail as "ending in H." By varying the precision of the search, the tourist reveals more or less information, at the expense of getting more or less specific results. If she asks a less specific pattern, she gets a lot more possible addresses and better privacy, but many of the results are irrelevant. If she asks for a very specific pattern, she gets fewer results but loses privacy.</p></div>
<div class="paragraph"><p>Os filtros bloom servem essa função ao permitir que um nodo VSP especifique um padrão de busca para transações que possa ser refinado de acordo com precisão ou privacidade. Um filtro bloom mais específico irá produzir resultados precisos, mas às custas de revelar quais endereços são usados na carteira do usuário. Um filtro bloom menos específico irá produzir mais dados sobre mais transações, muitas irrelevantes para o nodo, mas permitirá ao nodo que mantenha uma privacidade maior.</p></div>
<div class="paragraph"><p>An SPV node will initialize a bloom filter as "empty" and in that state the bloom filter will not match any patterns. The SPV node will then make a list of all the addresses in its wallet and create a search pattern matching the transaction output that corresponds to each address. Usually, the search pattern is a pay-to-public-key-hash script that is the expected locking script that will be present in any transaction paying to the public-key-hash (address). If the SPV node is tracking the balance of a P2SH address, the search pattern will be a pay-to-script-hash script, instead. The SPV node then adds each of the search patterns to the bloom filter, so that the bloom filter can recognize the search pattern if it is present in a transaction. Finally, the bloom filter is sent to the peer and the peer uses it to match transactions for transmission to the SPV node.</p></div>
<div class="paragraph"><p>Bloom filters are implemented as a variable-size array of N binary digits (a bit field) and a variable number of M hash functions. The hash functions are designed to always produce an output that is between 1 and N, corresponding to the array of binary digits. The hash functions are generated deterministically, so that any node implementing a bloom filter will always use the same hash functions and get the same results for a specific input. By choosing different length (N) bloom filters and a different number (M) of hash functions, the bloom filter can be tuned, varying the level of accuracy and therefore privacy.</p></div>
<div class="paragraph"><p>In <a href="#bloom1">[bloom1]</a>, we use a very small array of 16 bits and a set of three hash functions to demonstrate how bloom filters work.</p></div>
<div class="imageblock" id="bloom1">
<div class="content">
<img src="images/msbt_0608.png" alt="Bloom1" />
</div>
<div class="title">Figure 8. Um exemplo de um filtro bloom simplístico, com um campo de 16-bit e três funções hash</div>
</div>
<div class="paragraph"><p>The bloom filter is initialized so that the array of bits is all zeros. To add a pattern to the bloom filter, the pattern is hashed by each hash function in turn. Applying the first hash function to the input results in a number between 1 and N. The corresponding bit in the array (indexed from 1 to N) is found and set to <tt>1</tt>, thereby recording the output of the hash function. Then, the next hash function is used to set another bit and so on. Once all M hash functions have been applied, the search pattern will be "recorded" in the bloom filter as M bits that have been changed from <tt>0</tt> to <tt>1</tt>.</p></div>
<div class="paragraph"><p><a href="#bloom2">[bloom2]</a> é um exemplo da adição de um padrão "A" para o filtro bloom simples mostrado em <a href="#bloom1">[bloom1]</a>.</p></div>
<div class="paragraph"><p>Adding a second pattern is as simple as repeating this process. The pattern is hashed by each hash function in turn and the result is recorded by setting the bits to <tt>1</tt>. Note that as a bloom filter is filled with more patterns, a hash function result might coincide with a bit that is already set to <tt>1</tt>, in which case the bit is not changed. In essence, as more patterns record on overlapping bits, the bloom filter starts to become saturated with more bits set to <tt>1</tt> and the accuracy of the filter decreases. This is why the filter is a probabilistic data structure—it gets less accurate as more patterns are added. The accuracy depends on the number of patterns added versus the size of the bit array (N) and number of hash functions (M). A larger bit array and more hash functions can record more patterns with higher accuracy. A smaller bit array or fewer hash functions will record fewer patterns and produce less accuracy.</p></div>
<div class="imageblock" id="bloom2">
<div class="content">
<img src="images/msbt_0609.png" alt="Bloom2" />
</div>
<div class="title">Figure 9. Adicionando um padrão "A" para o nosso filtro bloom simples</div>
</div>
<div class="paragraph"><p><a href="#bloom3">[bloom3]</a> é um exemplo da adição de um segundo padrão "B" para o filtro bloom simples.</p></div>
<div class="imageblock" id="bloom3">
<div class="content">
<img src="images/msbt_0610.png" alt="Bloom3" />
</div>
<div class="title">Figure 10. Adicionando um segundo padrão "B" para o nosso filtro bloom simples</div>
</div>
<div class="paragraph"><p>Para testar se um padrão faz parte de um filtro bloom, o padrão é "hashado" por cada função hash e o padrão bit resultante é testado contra a bit array. Se todos os bits indexados pelas funções hash são definidas para <tt>1</tt>, então o padrão é <em>provavelmente</em> registrado no filtro bloom. Como os bits podem ser definidos devido a sobreposição de múltiplos padrões, a resposta não é certa, ao invés disso, ela é probabilística. Em termos simples, uma correspondência positiva em filtro bloom é um "Talvez, Sim."</p></div>
<div class="paragraph"><p><a href="#bloom4">[bloom4]</a> é um exemplo de teste da existência do padrão "X" no filtro bloom simples. Os bits correspondentes estão definidos como <tt>1</tt>, então o padrõa é provavelmente uma correspondência.</p></div>
<div class="imageblock" id="bloom4">
<div class="content">
<img src="images/msbt_0611.png" alt="Bloom4" />
</div>
<div class="title">Figure 11. Testando a existência de um padrão "X" no filtro bloom. O resultado é uma correspondência positiva probabilística, significando "Talvez."</div>
</div>
<div class="paragraph"><p>Por outro lado, se um padrão for testado contra um filtro bloom e qualquer um dos bits estiver definido como <tt>0</tt>, isso prova que o padrão não foi registrado no filtro bloom. O resultado negativo não é uma probabilidade, ele é uma certeza. Em termos simples, uma correspondência negativa em um filtro bloom é um "Definitivamente Não!"</p></div>
<div class="paragraph"><p><a href="#bloom5">[bloom5]</a> é um exemplo de um teste da existência do padrão "Y" em um filtro bloom simples. Um dos bits correspondentes está definido como <tt>0</tt>, então o padrão definitivamente não é uma correspondência.</p></div>
<div class="imageblock" id="bloom5">
<div class="content">
<img src="images/msbt_0612.png" alt="images/msbt_0612.png" />
</div>
<div class="title">Figure 12. Testando a existência do padrão "Y" no filtro bloom. O resultado é uma correspondência negativa definitica, significando "Definitivamente Não!"</div>
</div>
<div class="paragraph"><p>A implementação de filtros bloom do Bitcoin é descrita em Bitcoin Improvement Proposal 37 (BIP0037). Veja <a href="#appdxbitcoinimpproposals">[appdxbitcoinimpproposals]</a> ou acesse o <a href="http://bit.ly/1x6qCiO">GitHub</a>.</p></div>
</div>
<div class="sect2">
<h3 id="_bloom_filters_and_inventory_updates">Bloom Filters and Inventory Updates</h3>
<div class="paragraph"><p>Filtros Bloom são usados para filtrar as transações (e os blocos que as contém) que um nodo VPS recebe de seus pontos. Os nodos VPS irão criar um filtro que corresponde somente aos endereços contidos na carteira do nodo VPS. O nodo VPS irá então enviar uma mensagem <tt>filterload</tt> para o ponto, contendo o filtro bloom para ser usado na conexão. Após um filtro ser estabelecido, o ponto irá então etestar cada output da transação contra o filtro bloom. Somente as transações que correspondem ao filtro serão enviadas para o nodo.</p></div>
<div class="paragraph"><p>Em resposta a uma mensagem <tt>getdata</tt> vindo do nodo, os pontos irão enviar uma mensagem <tt>merkleblock</tt> que contém somente os cabeçalhos de bloco para os blocos correspondentes ao filtro e um caminho merkle (ver <a href="#merkle_trees">[merkle_trees]</a>) para cada transação correspondente. O ponto também enviará mensagens <tt>tx</tt> contendo as transações que correspondem ao filtro.</p></div>
<div class="paragraph"><p>O nodo definindo o filtro bloom pode adicionar padrões ao filtro de maneira interativa ao enviar uma mensagem <tt>filteradd</tt>. Para limpar o filtro bloom, o nodo pode enviar uma mensagem  <tt>filterclear</tt>. Como não é possível remover um padrão de um filtro bloom, um nodo tem que limpar e reenviar um novo filtro bloom se um padrão não é mais desejado.</p></div>
</div>
<div class="sect2">
<h3 id="transaction_pools">Pools de Transações</h3>
<div class="paragraph"><p>Quase todo nodo na rede bitcoin mantém uma lista temporária de transações não-confirmadas chamada de <em>pool de memória</em>, <em>mempool</em> ou <em>pool de transações</em>. Os nodos usam esse pool para manter um acompanhamento das transações que são conhecidas pela rede mas que ainda não foram incluídas na blockchain. Por exemplo, um nodo contendo uma carteira de usuário utilizará um pool de transação para acompanhar os pagamentos para essa carteira que foram recebidos na rede, mas que ainda não foram confirmados.</p></div>
<div class="paragraph"><p>As transações são recebidas e verificadas, sendo adicionadas ao pool de transações e transmitidas aos nodos vizinhos para serem propagadas para a rede.</p></div>
<div class="paragraph"><p>Algumas implementações de nodos também mantém um pool separado de transações órfãs. Caso um input de transação referir-se a uma transação que ainda não é conhecida, como um pai desconhecido, a transação órfã será armazenada temporariamente no pool órfão até que a transação pai chegue.</p></div>
<div class="paragraph"><p>When a transaction is added to the transaction pool, the orphan pool is checked for any orphans that reference this transaction&#8217;s outputs (its children). Any matching orphans are then validated. If valid, they are removed from the orphan pool and added to the transaction pool, completing the chain that started with the parent transaction. In light of the newly added transaction, which is no longer an orphan, the process is repeated recursively looking for any further descendants, until no more descendants are found. Through this process, the arrival of a parent transaction triggers a cascade reconstruction of an entire chain of interdependent transactions by re-uniting the orphans with their parents all the way down the chain.</p></div>
<div class="paragraph"><p> Tanto o pool de transação quanto o pool de órfãs (quando implementado) são armazenados na memória local e não são salvos em um armazenamento persistente; ao invés disso, eles são populados dinamicamente a partir das mensagens de rede que chegam. Quando um nodo é iniciado, ambas as pools são esvaziadas e são gradualmente populadas com as novas transações recebidas na rede.</p></div>
<div class="paragraph"><p>Some implementations of the bitcoin client also maintain a UTXO database or UTXO pool, which is the set of all unspent outputs on the blockchain. Although the name "UTXO pool" sounds similar to the transaction pool, it represents a different set of data. Unlike the transaction and orphan pools, the UTXO pool is not initialized empty but instead contains millions of entries of unspent transaction outputs, including some dating back to 2009. The UTXO pool may be housed in local memory or as an indexed database table on persistent storage.</p></div>
<div class="paragraph"><p>Whereas the transaction and orphan pools represent a single node&#8217;s local perspective and might vary significantly from node to node depending upon when the node was started or restarted, the UTXO pool represents the emergent consensus of the network and therefore will vary little between nodes. Furthermore, the transaction and orphan pools only contain unconfirmed transactions, while the UTXO pool only contains confirmed outputs.</p></div>
</div>
<div class="sect2">
<h3 id="_mensagens_de_alerta">Mensagens de Alerta</h3>
<div class="paragraph"><p>As mensagens de alerta são uma função raramente utilizada, mas mesmo assim são implementadas na maioria dos nodos. As mensagens de alerta são um "sistema de alerta de emergências" do bitcoin, um meio através do qual os desenvolvedores do bitcoin core podem enviar uma mensagem de texto de emergência para todos os nodos bitcoin. Essa funcionalidade foi implementada para permitir que a equipe de desenvolvedores do core possa notificar todos os usuários bitcoin de problemas graves na rede bitcoin, como um bug crítico que exija a ação do usuário para ser corrigido. O sistema de alerta só foi utilizado poucas vazes, mais notavelmente no início de 2013, quando um bug crítico de banco de dados causou uma bifurcação de múltiplos blocos na blockchain do bitcoin.</p></div>
<div class="paragraph"><p>As mensagens de alerta são propagadas pela mensagem <tt>alert</tt>. A mensagem de alerta contém vários campos, incluindo:</p></div>
<div class="dlist"><dl>
<dt class="hdlist1">
ID
</dt>
<dd>
<p>
Um identificação do alerta, de maneira que alertas duplicados possam ser detectados
</p>
</dd>
<dt class="hdlist1">
Expiration
</dt>
<dd>
<p>
Uma hora a partir da qual o alerta expira
</p>
</dd>
<dt class="hdlist1">
RelayUntil
</dt>
<dd>
<p>
Uma hora após a qual o alerta não deve mais ser transmitido
</p>
</dd>
<dt class="hdlist1">
MinVer, MaxVer
</dt>
<dd>
<p>
A faixa de versões do protocolo bitcoin a qual esse alerta se aplica
</p>
</dd>
<dt class="hdlist1">
subVer
</dt>
<dd>
<p>
A versão do software de cliente a qual esse alerta se aplica
</p>
</dd>
<dt class="hdlist1">
Priority
</dt>
<dd>
<p>
Um nível de prioridade para o alerta, atualmente não sendo utilizado
</p>
</dd>
</dl></div>
<div class="paragraph"><p>Os alertas são assinados criptograficamente por uma chave pública. A chave privada correspondente é controlada por alguns membros selecionados do time de desenvolvimento do core. A assinatura digital garante que alertas falsos não sejam propagados na rede.</p></div>
<div class="paragraph"><p>Cada nodo que receber essa mensagem de alerta irá verificá-la, checar pela expiração e propagá-la para todos os seus pontos, dessa maneira garantindo a rápida propagação através de toda a rede. Além de propagar o alerta, os nodos podem implementar uma função de interface de usuário para apresentar o alerta para o usuário.</p></div>
<div class="paragraph"><p>No cliente Bitcoin Core, o alerta é configurado com a opção da linha de comando <tt>-alertnotify</tt>, que especifica um comando para ser executado quando um alerta for recebido. A mensagem de alerta é passada como um parâmetro para o comando <tt>alertnotify</tt>. Mais comumente, o comando <tt>alertnotify</tt> é definido para gerar uma mensagem de e-mail para o administrador do nodo, contendo a mensagem de alerta. O alerta também é exibido como uma caixa de diálogo pop-up na interface gráfica do usuário (bitcoin-Qt), caso ela esteja sendo executada.</p></div>
<div class="paragraph"><p>Other implementations of the bitcoin protocol might handle the alert in different ways. Many hardware-embedded bitcoin mining systems do not implement the alert message function because they have no user interface. It is strongly recommended that miners running such mining systems subscribe to alerts via a mining pool operator or by running a lightweight node just for alert purposes.</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-07-15 16:58:25 UTC
</div>
</div>
</body>
</html>
