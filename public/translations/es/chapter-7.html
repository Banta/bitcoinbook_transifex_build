<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.7" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="blockchain">La Cadena de Bloques</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introducción">Introducción</h3>
<div class="paragraph"><p> La estructura de datos la cadena de bloques es una lista ordenada, enlazada atrás en el tiempo de bloques de transacciones. La cadena de bloques se puede almacenar como un archivo plano, o en una base de datos simple. El cliente Bitcoin Core almacena los metadatos de la cadena de bloques usando  la base de datos LevelDB de Google. Los bloques están vinculados "de vuelta", cada referencia al bloque anterior de la cadena. La cadena de bloques a menudo se visualiza como una pila vertical, con los bloques en capas en la parte superior de uno al otro y el primer bloque que sirve como la base de la pila. La visualización de bloques apilados unos encima de otros resulta en el uso de términos como "altura" para referirse a la distancia desde el primer bloque, y "arriba" o "punta" para referirse al bloque más recientemente añadido.</p></div>
<div class="paragraph"><p>Cada bloque dentro de la cadena de bloques se identifica mediante un hash, generado utilizando el algoritmo criptográfico hash SHA256 en el encabezado del bloque. Cada bloque también hace referencia a un bloque anterior, conocido como el  bloque <em>padre</em>, a través del campo "hash anterior de bloque" en el encabezado del bloque. En otras palabras, cada bloque contiene el hash de su padre dentro de su propia cabecera. La secuencia de los hashes que unen cada bloque a su padre crea una cadena que se remonta hasta el final del primer bloque jamás creado, conocido como el  bloque génesis.</p></div>
<div class="paragraph"><p>Aunque un bloque tiene solo uno de los padres, puede tener temporalmente varios hijos. Cada uno de los hijos se refiere a la misma bloque que su matriz y contiene el mismo (padre) de hash en el campo "bloque anterior de hash". Hijos múltiples surgen durante una "bifurcación" blockchain, una situación temporal que se produce cuando diferentes bloques se descubren casi simultáneamente por diferentes mineros (ver <a href="#forks">[forks]</a>). Con el tiempo, un bloque hijo se convierte en parte de la blockchain y la "bifurcación" se resuelve. A pesar de que un bloque puede tener más de un hijo, cada bloque sólo puede tener uno de los padres. Esto se debe a que un bloque tiene un solo campo "bloque anterior de hash" que hace referencia a su único padre.</p></div>
<div class="paragraph"><p>El campo "bloque anterior de hash" está dentro de la cabecera del bloque y por lo tanto afecta al hash del bloque actual. La identidad propia del hijo cambia si la identidad de los padres cambia. Cuando el padre se modifica de alguna manera, los cambios de hash de los padres tambien cambian. Cuando el hash del padre cambia requiere un cambio en el puntero "anterior de hash de bloque" del hijo. Esto a su vez hace que el hash del hijo cambie, lo que requiere un cambio en el puntero del nieto, que a su vez cambia el nieto, y así sucesivamente.  Este efecto cascada asegura que una vez que un bloque tiene muchas generaciones siguientes que, no puede ser cambiado sin forzar un nuevo cálculo de todos los bloques siguientes. Debido a que un nuevo cálculo requeriría enorme computación, la existencia de una larga cadena de bloques histórica profunda hace a la cadena de bloques inmutable, que es una característica clave de la seguridad del bitcoin.</p></div>
<div class="paragraph"><p>Una forma de pensar en la cadena de bloques es como capas en una formación geológica o muestra del núcleo glaciar. Las capas superficiales pueden cambiar con las estaciones, o incluso perder la cabeza antes de que tengan tiempo para asentarse. Pero una vez que vas a pocos pulgadas de profundidad, las capas geológicas se vuelven más y más estable. Por el momento nos fijamos unos pocos cientos de pies abajo, usted está buscando en una instantánea del pasado que ha permanecido inalterado durante millones de años. En la cadena de bloques, los más recientes pocos bloques pueden ser revisados ​​si hay un nuevo cálculo de la cadena debido a una bifurcación. Los seis primeros bloques son como unas cuantas pulgadas de tierra vegetal. Pero una vez que usted va más profundamente en la cadena de bloques, más allá de seis bloques, los bloques son cada vez menos probable que cambie. Después de 100 bloques atrás hay tanta estabilidad que la transacción coinbase -la transacción que contiene recién minadas bitcoins- puede ser gastado. Unos pocos miles de bloques hacia atrás (un mes) y el blockchain reiterará la historia, para todos los propósitos prácticos. Mientras que el protocolo siempre permite una cadena para ser deshecha por una cadena más larga y al mismo tiempo la posibilidad de cualquier bloque que se está invierte siempre existe, la probabilidad de un evento tal disminuye a medida que pasa el tiempo hasta que se convierte infinitesimal.</p></div>
</div>
<div class="sect2">
<h3 id="_estructura_de_un_bloque">Estructura de un Bloque</h3>
<div class="paragraph"><p> Un bloque es una estructura de datos contenedor que agrupa las transacciones para su inclusión en el libro de contabilidad público, la cadena de bloques. El bloque se compone de una cabecera, que contiene metadatos, seguido por una larga lista de operaciones que componen la mayor parte de su tamaño. El encabezado del bloque es de 80 bytes, mientras que la transacción promedio es de al menos 250 bytes y el bloque promedio contiene más de 500 transacciones. Un bloque completo, con todas las transacciones, por lo tanto, es 1000 veces más grande que la cabecera del bloque. <a href="#block_structure1">[block_structure1]</a> describe la estructura de un bloque.</p></div>
<div class="tableblock" id="block_structure1">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. La estructura de un bloque</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Tamaño</p></td>
<td align="left" valign="top"><p class="table">Campo</p></td>
<td align="left" valign="top"><p class="table">Descripción</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Tamaño de Bloque</p></td>
<td align="left" valign="top"><p class="table">El tamaño del bloque en bytes luego de este campo</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">80 bytes</p></td>
<td align="left" valign="top"><p class="table">Encabezado de Bloque</p></td>
<td align="left" valign="top"><p class="table">Varios campos componen el encabezado del bloque</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Contador de Transacción</p></td>
<td align="left" valign="top"><p class="table">Cuántas transacciones hay a continuación</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Transacciones</p></td>
<td align="left" valign="top"><p class="table">Las transacciones registradas en este bloque</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="block_header">Encabezado de Bloque</h3>
<div class="paragraph"><p>  El encabezado del bloque se compone de tres conjuntos de metadatos bloque. En primer lugar, hay una referencia a un hash bloque anterior, que conecta este bloque al bloque anterior en la cadena de bloques. El segundo conjunto de metadatos, es decir, el    <em>difficulty</em>, <em>timestamp</em> y <em>nonce</em>, se refieren a la competencia la minería, como se detalla en <a href="#ch8">[ch8]</a>. La tercera pieza de metadatos es la raíz del árbol Merkle, una estructura de datos utilizada para resumir de manera eficiente todas las transacciones en el bloque. <a href="#block_header_structure_ch07">[block_header_structure_ch07]</a> Describe la estructura de una cabecera de bloque.</p></div>
<div class="tableblock" id="block_header_structure_ch07">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. La estructura del encabezado de bloque</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Tamaño</p></td>
<td align="left" valign="top"><p class="table">Campo</p></td>
<td align="left" valign="top"><p class="table">Descripción</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Versión</p></td>
<td align="left" valign="top"><p class="table">Un número de versión para seguir las actualizaciones de software y protocolo</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Hash del Bloque Anterior</p></td>
<td align="left" valign="top"><p class="table">Una referencia al hash del bloque anterior (padre) en la cadena</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Raíz Merkle</p></td>
<td align="left" valign="top"><p class="table">Un hash de la raíz del árbol de merkle de las transacciones de este bloque</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Hora</p></td>
<td align="left" valign="top"><p class="table">El tiempo de creación aproximada de este bloque (segundos desde Unix Epoch)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Objetivo de Dificultad</p></td>
<td align="left" valign="top"><p class="table">El objetivo de dificultad del algoritmo de prueba de trabajo para este bloque</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Nonce</p></td>
<td align="left" valign="top"><p class="table">Un contador usado para el algoritmo de prueba de trabajo</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>El nonce, objetivo de dificultad y sello de tiempo son usados en el proceso de minado y serán analizados en mayor detalle en <a href="#ch8">[ch8]</a>.</p></div>
</div>
<div class="sect2">
<h3 id="block_hash">Identificadores de Bloque: Hash de Encabezado de Bloque y Altura de Bloque</h3>
<div class="paragraph"><p>   El identificador primario de un bloque es su hash criptográfico, una huella digital, realizada por hash de la cabecera del bloque dos veces a través del algoritmo SHA256. El hash de 32 bytes resultante se llama el   hash_ _block pero es más preciso llamarlo la bloque de cabecera de hash, pase: [ &lt;phrase role="keep-together"&gt; porque sólo el encabezado del bloque se utiliza para calcular la misma. Por ejemplo, &lt;/phrase&gt; ] + 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f + es el hash del bloque del primer bloque bitcoin jamás creado. El hash de bloque identifica un bloque de forma única e inequívoca y se puede derivar de forma independiente por cualquier nodo simplemente haciendo hash de la cabecera del bloque.</p></div>
<div class="paragraph"><p>Tenga en cuenta que el hash de bloque no está realmente incluido dentro de la estructura de datos del bloque, ni cuando el bloque es transmitido en la red, ni cuando se guarda en el almacenamiento de persistencia de un nodo como parte de la cadena de bloques. En cambio, el hash del bloque se calcula por cada nodo que se recibe el bloque de la red. El hash bloque podría ser almacenado en una tabla de base de datos separada como parte de los metadatos del bloque, para facilitar la indexación y la recuperación más rápida de los bloques desde el disco.</p></div>
<div class="paragraph"><p>Una segunda manera de identificar un bloque es, por su posición en el blockchain, denominado  paso: [ &lt;phrase role="keep-together"&gt;&lt;emphasis&gt; altura del bloque &lt;/emphasis&gt; . El primer bloque jamás creado es a la altura del bloque 0 (cero) y es el &lt;/phrase&gt; ] paso: [ &lt;phrase role="keep-together"&gt; mismo bloque que se hace referencia anteriormente por el siguiente bloque de hash &lt;/phrase&gt; ] <tt>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</tt>. Un bloque de este modo se puede identificar dos maneras: haciendo referencia al hash de bloque o haciendo referencia a la altura del bloque. Cada bloque posterior se añadió "encima" de ese primer bloque es una posición "superior" en cadena de bloques, como cajas apiladas una encima de la otra. La altura del bloque el 1 de enero de 2014, fue de aproximadamente 278000, lo que significa que había 278000 bloques apilados en la parte superior del primer bloque creado en enero de 2009.</p></div>
<div class="paragraph"><p>A diferencia de la hash de bloque, la altura del bloque no es un identificador único. Aunque un solo bloque siempre tendrá una altura de bloque específico e invariante, lo contrario no es cierto: la altura del bloque no siempre identifica un solo bloque. Dos o más bloques podrían tener la misma altura del bloque, que compiten por la misma posición en la cadena de bloques. Este escenario se discute en detalle en la sección <a href="#forks">[forks]</a>. También la altura del bloque no es una parte de la estructura de datos del bloque; no se almacena dentro del bloque. Cada nodo identifica dinámicamente la posición de un bloque (altura) en la cadena de bloques cuando se recibe desde la red Bitcoin. La altura del bloque también puede ser almacenada como metadatos en una tabla de base de datos indexada para la recuperación más rápida.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>El <em>block Hash</em> de un bloque siempre identifica un solo bloque único. Un bloque también tiene siempre una <em>altura de bloque</em> específica. Sin embargo, no es siempre el caso de que una altura del bloque específico puede identificar un único bloque. Más bien, dos o más bloques pueden competir por una sola posición en la cadena de bloques.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect2">
<h3 id="_el_bloque_génesis">El Bloque Génesis</h3>
<div class="paragraph"><p>  El primer bloque en la cadena de bloques se llama el bloque génesis y fue creada en 2009. Es el ancestro común de todos los bloques en el blockchain, lo que significa que si se inicia en cualquier bloque y sigue la cadena hacia atrás en el tiempo, es muy probable que llegar al bloque de génesis.</p></div>
<div class="paragraph"><p>Cada nodo siempre comienza con una cadena de bloques de al menos un bloque debido a que el bloque de génesis se codifica de forma estática en el software de cliente bitcoin, tal que no puede ser alterado. Cada nodo siempre "sabe" el hash del bloque de génesis y estructura, el tiempo fijado que fue creado, e incluso la transacción única dentro. Por lo tanto, cada nodo tiene el punto de partida para la cadena de bloques, una "raíz" segura desde la que construir un blockchain confianza.</p></div>
<div class="paragraph"><p> Ver el bloque génesis estático codificado dentro del cliente Bitcoin Core, en <a href="http://bit.ly/1x6rcwP">chainparams.cpp</a>.</p></div>
<div class="paragraph"><p>El siguiente identificador de hash pertenece al bloque de génesis:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</tt></pre>
</div></div>
<div class="paragraph"><p>Puede buscar ese hash de bloque en cualquier sitio web de explorador de bloques, como blockchain.info, y usted encontrará una página que describe el contenido de este bloque, con una dirección URL que contiene ese hash:</p></div>
<div class="paragraph"><p><a href="https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">https://blockchain.info/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a></p></div>
<div class="paragraph"><p><a href="https://blockexplorer.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f">https://blockexplorer.com/block/000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</a></p></div>
<div class="paragraph"><p>Usando el cliente de referencia Bitcoin Core en la línea de comandos:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bitcoind getblock 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f</tt></pre>
</div></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>El bloque génesis contiene un mensaje oculto en su interior. La entrada de transacción coinbase contiene el texto "The Times 03 / Ene / 2009 Canciller está al borde de segundo plan de rescate para los bancos." Este mensaje fue pensado para ofrecer la prueba de la primera fecha de este bloque fue creado, haciendo referencia a la titular del periódico británico <em>The Times</em>. También sirve como un recordatorio de la lengua en la mejilla de la importancia de un sistema monetario independiente, con el lanzamiento del bitcoin ocurre al mismo tiempo que una crisis monetaria mundial sin precedentes. El mensaje se ha incrustado en el primer bloque por Satoshi Nakamoto, creador del bitcoin.</p></div>
</div>
<div class="sect2">
<h3 id="_vinculando_bloques_en_la_cadena_de_bloques">Vinculando Bloques en la Cadena de Bloques</h3>
<div class="paragraph"><p>  Los nodos completos de Bitcoin mantienen una copia local de la cadena de bloques, comenzando en el bloque de génesis. La copia local de la cadena de bloques se actualiza constantemente a medida que nuevos bloques se encuentran y se utilizan para extender la cadena. Cuando un nodo recibe bloques entrantes desde la red, serán validados estos bloques y luego se enlazan a la cadena de bloques existente. Para establecer un vínculo, un nodo examinará la cabecera del bloque de entrada y buscar el "hash de bloque anterior."</p></div>
<div class="paragraph"><p>Supongamos, por ejemplo, que un nodo tiene 277314 bloques en la copia local de la blockchain. El último bloque del nodo conoce es bloquear 277314, con un hash cabecera del bloque de <tt>00000000000000027e7ba6fe7bad39faf3b5a83daed765f05f7d1b71a1632249</tt>.</p></div>
<div class="paragraph"><p>El nodo bitcoin luego recibe un nuevo bloque de la red, el cual es diseccionado de la siguiente manera:</p></div>
<div class="listingblock">
<div class="content"></div></div>
<div class="paragraph"><p>Buscando un nuevo bloque, el nodo encuentra el campo <tt>hash previo de bloque</tt>, que contiene el hash de su bloque padre. Es un hash conocido por el nodo, del último bloque en la cadena a la altura de 277314. Por lo tanto, este nuevo bloque es un hijo del último bloque de la cadena y se extiende a la cadena de bloques existente. El nodo añade este nuevo bloque al final de la cadena, añadiendo a la cadena de bloques una nueva altura de 277315. <a href="#chain_of_blocks">[chain_of_blocks]</a> Muestra la cadena de tres bloques, unidos por referencias en el campol <tt>hash previo de bloque</tt>.</p></div>
</div>
<div class="sect2">
<h3 id="merkle_trees">Árboles de Merkle</h3>
<div class="paragraph"><p>  Cada bloque en el blockchain bitcoin contiene un resumen de todas las transacciones en el bloque, utilizando un árbol de merkle.</p></div>
<div class="paragraph"><p>Un árbol de merkle, también conocido como una  árbol binario hash, es una estructura de datos utilizada para resumir de manera eficiente y verificar la integridad de grandes conjuntos de datos. Los árboles de meekle son árboles binarios que contienen hashes criptográficos. El término "árbol" se usa en informática para describir una estructura de datos de ramificación, pero estos árboles por lo general aparecen al revés con la "raíz" en la parte superior y las "hojas" en la parte inferior de un diagrama, como se verá en los ejemplos que siguen.</p></div>
<div class="imageblock" id="chain_of_blocks">
<div class="content">
<img src="images/msbt_0701.png" alt="images/msbt_0701.png" />
</div>
<div class="title">Figure 1. Bloques vinculados en una cadena, por referencia a la cabecera de bloque anterior de hash</div>
</div>
<div class="paragraph"><p>Los árboles de Merkle se utilizan en bitcoin para resumir todas las transacciones en un bloque, produciendo una huella digital en general de todo el conjunto de las operaciones, proporcionando un proceso muy eficiente para verificar si una transacción se incluye en un bloque. Un árbol de Merkle  se construye mediante hash de forma recursiva en los pares de nodos hasta que sólo quede uno de hash, llamado root o merkle root. El algoritmo de hash criptográfico utilizado en los árboles de Merkle de Bitcoin es SHA256 y se aplica dos veces, también conocido como doble SHA256.</p></div>
<div class="paragraph"><p>Cuando N elementos de datos se les hace hash y se resumen en un árbol de Merkle, puede comprobar para ver si algún elemento de un dato se incluye en el árbol con un máximo de <tt>2*log<sub>2</sub>(N)</tt> cálculos, haciendo de este un dato una estructura muy eficiente.</p></div>
<div class="paragraph"><p>El árbol de Merkle se construye de abajo hacia arriba. En el siguiente ejemplo, comenzamos con cuatro transacciones, A, B, C y D, que forman la <em>hojas</em> del árbol de Merkle, como se muestra en &lt;&lt;simple_merkle&gt; &gt;. Las transacciones no se almacenan en el árbol de Merkle; más bien, sus datos están hash y el hash resultante se almacena en cada nodo hoja como  H<sub>A</sub>, H<sub>B</sub>, H<sub>C</sub>, y H<sub>D</sub>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>H~A~ = SHA256(SHA256(Transacción A))</tt></pre>
</div></div>
<div class="paragraph"><p>Pares consecutivos de nodos hoja son luego resumidos en un nodo padre, concatenando los dos hashes y el hash juntos. Por ejemplo, para construir el nodo padre H~~AB, los dos valores hash de 32 bytes de los hijos se concatenan para crear una cadena de 64 bytes. Esa cadena es entonces doble hash para producir el hash del nodo principal:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>H~AB~ = SHA256(SHA256(H~A~ + H~B~))</tt></pre>
</div></div>
<div class="paragraph"><p>El proceso continúa hasta que sólo hay un nodo en la parte superior, el nodo conocido como la raíz Merkle. Ese hash de 32 bytes se almacena en la cabecera del bloque y resume todos los datos de todas los cuatro transacciones.</p></div>
<div class="imageblock" id="simple_merkle">
<div class="content">
<img src="images/msbt_0702.png" alt="merkle_tree" />
</div>
<div class="title">Figure 2. Calculando los nodos en un árbol de Merkle</div>
</div>
<div class="paragraph"><p>Debido a que el árbol Merkle es un árbol binario, se necesita un número par de nodos de hoja. Si hay un número impar de transacciones para resumir, el último hash transacción se duplicará para crear un número par de nodos hoja, también conocido como  <em>balanced tree</em>. Esto se muestra en &lt;&lt;merkle_tree_odd&gt; &gt;, donde se duplica la transacción C.</p></div>
<div class="imageblock" id="merkle_tree_odd">
<div class="content">
<img src="images/msbt_0703.png" alt="merkle_tree_odd" />
</div>
<div class="title">Figure 3. Duplicando un elemento de datos para alcanzar un número par de elementos de datos</div>
</div>
<div class="paragraph"><p>El mismo método para la construcción de un árbol de cuatro transacciones se puede generalizar para construir árboles de cualquier tamaño. En Bitcoin es común tener de varios cientos a más de mil transacciones en un solo bloque, que se resumen en la misma forma, la producción de sólo 32 bytes de datos como la raíz merkle sola. En &lt;&lt;merkle_tree_large&gt; &gt;, verá un árbol construido a partir de 16 transacciones. Tenga en cuenta que, aunque la raíz se ve más grande que los nodos hoja en el diagrama, es exactamente el mismo tamaño, a sólo 32 bytes. Sobre la existencia de una transacción o cien mil operaciones en el bloque, la raíz merkle siempre los resume en 32 bytes.</p></div>
<div class="paragraph"><p>Para demostrar que una transacción específica se incluye en un bloque, un nodo sólo necesita producir <tt>log<sub>2</sub>(N)</tt> hash de 32 bytes, lo que constituye una  ruta de autenticación o camino de merkle para la conexión de la transacción específica a la raíz del árbol. Esto es especialmente importante ya que el número de transacciones aumenta, porque el logaritmo en base 2 del número de transacciones aumenta mucho más lentamente. Esto permite que los nodos de Bitcoin para producir eficientemente caminos de 10 o 12 hashes (320-384 bytes), que pueden proporcionar la prueba de una sola transacción de más de mil operaciones en un bloque de megabytes de tamaño.</p></div>
<div class="imageblock" id="merkle_tree_large">
<div class="content">
<img src="images/msbt_0704.png" alt="merkle_tree_large" />
</div>
<div class="title">Figure 4. Un árbol de merkle resumiendo muchos elementos de datos</div>
</div>
<div class="paragraph"><p>En <a href="#ruta del arbol de merkle">[ruta del arbol de merkle]</a>, un nodo puede demostrar que una transacción K está incluida en el bloque mediante la producción de un camino merkle que es sólo cuatro hashes de 32-byte de largo (128 bytes en total). La ruta consta de los cuatro valores hash (señalados en azul en <a href="#merkle_tree_path">[merkle_tree_path]</a>) H<sub>L</sub>, H<sub>IJ</sub>, H<sub>MNOP</sub> and H<sub>ABCDEFGH</sub>. Con esos cuatro hashes suministrados a modo de ruta de autenticación, cualquier nodo puede demostrar que H<sub>K</sub>  (observe en verde en el diagrama) se incluye en la raíz merkle mediante el cálculo de cuatro por pares adicionales hashes H<sub>KL</sub>, H<sub>IJKL</sub>, H<sub>IJKLMNOP</sub>, y la raíz del árbol Merkle (descrito en una línea de puntos en el diagrama).</p></div>
<div class="paragraph" id="merkle_tree_path"><p>Una ruta de merkle utilizada para probar la inclusión de un elemento de datos
<span class="image">
<img src=":images/msbt_0705.png" alt="merkle_tree_path" />
</span></p></div>
<div class="paragraph"><p>El código en <a href="#merkle_example">[merkle_example]</a> demuestra el proceso de crear un árbol Merkle desde el hash nodo hoja hasta la raíz, utilizando la biblioteca libbitcoin para algunas funciones auxiliares.</p></div>
<?hard-pagebreak?>
<div class="exampleblock" id="merkle_example">
<div class="title">Example 1. Construyendo un árbol de Merkle</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p><a href="#merkle_example_run">[merkle_example_run]</a> muestra el resultado de compilar y ejecutar el código Merkle.</p></div>
<div class="exampleblock" id="merkle_example_run">
<div class="title">Example 2. Compilando y ejecutando el código de ejemplo merkle</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>La eficiencia de los árboles Merkle se hace evidente a medida que aumenta la escala. <a href="#block_structure2">[block_structure2]</a> muestra la cantidad de datos que necesita ser intercambiado como un camino merkle para demostrar que una transacción es parte de un bloque.</p></div>
<div class="tableblock" id="block_structure2">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Eficiencia de un árbol de Merkle</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Número de transacciones</p></td>
<td align="left" valign="top"><p class="table">Tamaño aprox. del bloque</p></td>
<td align="left" valign="top"><p class="table">tamaño de ruta (hashes)</p></td>
<td align="left" valign="top"><p class="table">Tamaño de ruta (bytes)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">16 transacciones</p></td>
<td align="left" valign="top"><p class="table">4 kilobytes</p></td>
<td align="left" valign="top"><p class="table">4 hashes</p></td>
<td align="left" valign="top"><p class="table">128 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">512 transacciones</p></td>
<td align="left" valign="top"><p class="table">128 kilobytes</p></td>
<td align="left" valign="top"><p class="table">9 hashes</p></td>
<td align="left" valign="top"><p class="table">288 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">2048 transacciones</p></td>
<td align="left" valign="top"><p class="table">512 kilobytes</p></td>
<td align="left" valign="top"><p class="table">11 hashes</p></td>
<td align="left" valign="top"><p class="table">352 bytes</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">65.535 transacciones</p></td>
<td align="left" valign="top"><p class="table">16 megabytes</p></td>
<td align="left" valign="top"><p class="table">16 hashes</p></td>
<td align="left" valign="top"><p class="table">512 bytes</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Como se puede ver en la tabla, mientras que el tamaño de bloque aumenta rápidamente, de 4 KB con 16 transacciones a un tamaño de bloque de 16 MB para adaptarse a 65.535 transacciones, el camino merkle requerido para demostrar la inclusión de una transacción aumenta mucho más lentamente, a partir de 128 bytes a sólo 512 bytes. Con árboles de merkle, un nodo puede descargar sólo los encabezados de bloque (80 bytes por bloque) y aún así ser capaz de identificar la inclusión de una transacción en un bloque mediante la recuperación de un camino de merkle pequeño de un nodo completo, sin almacenar o transmitir la gran mayoría de la cadena de bloques, que puede ser de varios gigabytes de tamaño. Los nodos que no mantienen una cadena de bloques completa, llamados verificación simplificada pago (nodos SPV), usan de caminos Merkle para verificar las transacciones sin necesidad de descargar bloques completos.  (( (rango = "endofrange", startref = "ix_ch07-asciidoc1")))</p></div>
</div>
<div class="sect2">
<h3 id="_árboles_de_merkle_y_verificación_de_pago_simplificada_spv">Árboles de Merkle y Verificación de Pago Simplificada (SPV)</h3>
<div class="paragraph"><p>  Los árboles de Merkle son ampliamente utilizados por los nodos SPV. Los nodos SPV no tienen todas las transacciones y no descargan bloques completos, sólo los encabezados de bloque. Con el fin de verificar que una transacción se incluye en un bloque, sin tener que descargar todas las transacciones en el bloque, que utilizan una ruta de autenticación, o la ruta de merkle.</p></div>
<div class="paragraph"><p>Consideremos, por ejemplo, un nodo de SPV que está interesado en los pagos entrantes a una dirección incluida en su billetera. El nodo SPV establecerá un filtro de bloom en sus conexiones con sus compañeros para limitar las transacciones recibidas a sólo aquellos que contengan direcciones de interés. Cuando un compañero ve una transacción que coincida con el filtro de bloom, se enviará ese bloque usando un  mensaje de <tt>bloque de merkle</tt>. El mensaje <tt>bloque de merkle</tt> contiene el encabezado del bloque, así como un camino merkle que une la transacción de interés para la raíz merkle en el bloque. El nodo SPV puede utilizar esta ruta merkle para conectar la transacción para el bloque y verificar que la transacción se incluye en el bloque. El nodo SPV también utiliza la cabecera del bloque para vincular el bloque con el resto de la cadena de blqoues. La combinación de estos dos enlaces, entre la transacción y bloque, y entre el bloque y la cadena de bloques, prueba que la transacción se registra en la cadena de bloques. Con todo, el nodo SPV habrá recibido menos de un kilobyte de datos para la cabecera del bloque y la ruta de merkle, una cantidad de datos que es más de mil veces menos que un bloque completo (aproximadamente 1 megabyte actualmente). </p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-07-15 16:58:53 UTC
</div>
</div>
</body>
</html>
