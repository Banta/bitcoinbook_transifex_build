<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.7" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="ch04_keys_addresses_wallets">Claves, Direcciones, Carteras</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introducción">Introducción</h3>
<div class="paragraph"><p> La propiedad de bitcoins se establece a través de <em>claves digitales</em>, <em>direcciones bitcoin</em>, y <em>firmas digitales</em>. Las claves digitales no son almacenadas realmente en la red, sino que son creadas y almacenadas por usuarios en un archivo o simple base de datos llamada <em>cartera</em> (wallet). Las claves digitales en la cartera de un usuario son completamente independientes del protocolo bitcoin y pueden ser generadas y administradas por el software de cartera del usuario sin referencia alguna a la cadena de bloques o acceso a Internet. Las claves habilitan muchas de las propiedades interesantes de bitcoin, incluyendo la confianza descentralizada y el control, comprobación de propiedad, y el modelo de seguridad de pruebas criptográficas.</p></div>
<div class="paragraph"><p>Cada transacción bitcoin requiere una firma válida para ser incluída en la cadena de bloques, la cual puede ser generada con claves digitales válidas; por lo tanto, quien posea una copia de dichas claves tendrá control de los bitcoins en esa cuenta. Las claves vienen en pares, consistiendo de una clave privada (secreta) y una clave pública. Imagina a la clave pública como si fuera el número de una cuenta bancaria y la clave privada el PIN secreto o la firma en un cheque que provee control sobre la cuenta. Estas claves digitales son rara vez vistas por los usuarios de bitcoin. En mayor medida son almacenadas dentro del archivo cartera y administradas por el software de cartera bitcoin.</p></div>
<div class="paragraph"><p>En la porción de pago de una transacción bitcoin, la clave pública del destinatario es representada por su huella digital, llamada una  <em>dirección bitcoin</em>, la cual es usada de igual forma que nombre del beneficiario en un cheque (i.e., "Páguese a la orden de&#8230;"). En la mayoría de los casos una dirección bitcoin es generada a partir de y correspondiendo a una clave pública. Sin embargo, no todas las direcciones bitcoin representan una clave pública; también pueden representar otros beneficiarios tales como scripts, como veremos más tarde en este capítulo. De esta forma las direcciones bitcoin abstraen al destinatario de los fondos, flexibilizando el destino de las transacciones, de forma similar a los chequees en papel: un único instrumento de pago que puede ser usado para pagar a cuentas de personas, compañías, pagar facturas o pagar por efectivo. La dirección bitcoin es la única representación de las claves que los usuarios ven rutinariamente ya que esta es la parte que necesitan compartir con el mundo.</p></div>
<div class="paragraph"><p>En este capítulo presentaremos carteras, las cuales contienen llaves criptográficas. Echaremos un vistazo a cómo las claves son generadas, almacenadas y administradas. Analizaremos los varios formatos de codificación utilizados para representar claves privadas y públicas, direcciones y direcciones script. Finalmente veremos usos especiales de claves: para firmar mensajes, probar propiedad y crear direcciones vanidosas (vanity addresses) y carteras de papel (paper wallets).</p></div>
<div class="sect3">
<h4 id="_criptografía_de_clave_pública_y_criptomonedas">Criptografía de Clave Pública y Criptomonedas</h4>
<div class="paragraph"><p>La criptografía de clave pública fue inventada en la década de 1970 y es la base matemática de la seguridad informática.</p></div>
<div class="paragraph"><p>Desde la invención de la criptografía de clave pública, varias funciones matemáticas adecuadas, tales como exponenciación de números primos y multiplicación de curvas elípticas, han sido descubiertas. Estas funciones matemáticas son prácticamente irreversibles, lo cual significa que son fáciles de calcular en una dirección e inviables de calcular en la dirección opuesta. Basada en estas funciones matemáticas, la criptografía permite la creación de secretos digitales y firmas digitales infalsificables. Bitcoin utiliza multiplicación de curvas elípticas como base para su criptografía de clave pública.</p></div>
<div class="paragraph"><p>En bitcoin utilizamos la criptografía de clave pública para crear un par de claves que controla el acceso a los bitcoins. El par de claves consiste en una clave privada y&#8212;derivada de esta última&#8212;una clave pública única. La clave pública es usada para recibir bitcoins, y la clave privada es usada para firmar transacciones y gastar dichos bitcoins.</p></div>
<div class="paragraph"><p>Existe una relación matemática entre las claves pública y privada que permiten que la clave privada sea utilizada para generar firmas en mensajes. Estas firmas pueden ser validadas contra la clave pública sin necesidad de revelar la clave privada.</p></div>
<div class="paragraph"><p>Cuando los bitcoins son gastados el dueño actual de los bitcoins presenta su clave pública y firma (diferente cada vez, pero creada a partir de la misma clave privada) en una transacción para gastar esos bitcoins. A través de la presentación de la clave pública y firma, todos los participantes en la red bitcoin pueden verificar y aceptar la transacción como válida, confirmando que la persona transfiriendo los bitcoins los posee al momento de la transferencia.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>En la mayoría de las implementaciones de carteras las claves privadas y públicas son almacenadas juntas como <em>pares de claves</em> por conveniencia. Sin embargo la clave pública puede ser calculada a partir de la clave privada, por lo que almacenar únicamente la clave privada también es posible.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="private_public_keys">Claves Privadas y Públicas</h4>
<div class="paragraph"><p>Una cartera bitcoin contiene una colección de claves, cada una compuesta de una clave privada y una pública. La clave privada (k) es un número, generalmente elegido aleatoriamente. A partir de la clave privada utilizamos multiplicación de curva elíptica, una función criptográfica de sentido único, para generar la clave pública (K). A partir de la clave pública (K) utilizamos una función de hash criptográfica de sentido único para generar la dirección bitcoin (A). En esta sección comenzaremos por generar una clave privada, echar una mirada a la matemática de curva elíptica usada para covertirla en una clave pública, y finalmente generar una dirección bitcoin a partir de la clave pública. La relación entre clave privada, clave pública y dirección bitcoin es ilustrada en <a href="#k_to_K_to_A">[k_to_K_to_A]</a>.</p></div>
<div class="imageblock" id="k_to_K_to_A">
<div class="content">
<img src="images/msbt_0401.png" alt="privk_to_pubK_to_addressA" />
</div>
<div class="title">Figure 1. Clave privada, clave pública y dirección bitcoin</div>
</div>
</div>
<div class="sect3">
<h4 id="private_keys">Claves Privadas</h4>
<div class="paragraph"><p>Una clave privada es simplemente un número escogido al azar. La propiedad y control de una clave privada es la raíz del control del usuario sobre los fondos asociados con la dirección bitcoin correspondiente. La clave privada es usada para crear las firmas requeridas para gastar bitcoins demostrando la pertenencia de los fondos usados en una transacción. La clave privada debe permanecer en secreto en todo momento, ya que revelarla a terceros es el equivalente a darles el control sobre los bitcoins asegurados por dicha clave. También deben hacerse copias de respaldo de las claves privadas para protegerlas de pérdidas accidentales, ya que si se pierde no puede ser recuperada y los fondos asegurados por ella se perderán para siempre.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>La clave privada bitcoin es simplemente un número. Puedes elegir tu clave privada aleatoriamente usando simplemente una moneda, papel y lápiz: arroja la moneda 256 veces y tendrás los dígitos binarios de una clave privada aleatoria que puedes usar en una cartera bitcoin. La clave pública puede luego ser generada a partir de la clave privada.</p></div>
</td>
</tr></table>
</div>
<div class="sect4">
<h5 id="_generando_una_clave_privada_a_partir_de_un_número_aleatorio">Generando una clave privada a partir de un número aleatorio</h5>
<div class="paragraph"><p>El primer y más importante paso en la generación de claves privadas es encontrar una fuente de entropía o azar segura. Crear una clave bitcoin es esencialmente lo mismo que "elegir un número entre 1 y 2<sup>256</sup>." El método exacto utilizado para elegir tal número no importa siempre y cuando no sea predecible ni repetible. El software bitcoin utiliza los generadores de números aleatorios del sistema para generar 256 bits de entropía (azar). Usualmente el generador de números aleatorios del sistema operativo es inicializado por una fuente humana de azar, lo cual es la razón por la que puede que te solicite que muevas tu mouse durante algunos segundos. Para los verdaderamente paranoicos nada vence a un dado, papel y lápiz.</p></div>
<div class="paragraph"><p>Más precisamente, la clave privada puede ser cualquier número entre <tt>1</tt> y <tt>n - 1</tt>, donde n es una constante (n = 1,158 * 10<sup>77</sup>, poco menos que 2<sup>256</sup>) definida como el orden de la curva elíptica usada en bitcoin (ver <a href="#elliptic_curve">[elliptic_curve]</a>). Para crear tal clave elegimos un número de 256 bits y verificamos que sea menor a <tt>n - 1</tt>. En términos de programación, esto es generalmente se logra alimentando una cadena más grande de bits aleatorios, recolectada a partir de una fuente aleatoriedad criptográficamente segura, en un algoritmo de hash SHA256 que convenientemente producirá un número de 256 bits. Si el resultado es menor a <tt>n - 1</tt> hemos obtenido una clave privada apropiada. De lo contrario, simplemente lo intentamos nuevamente con otro número aleatorio.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>No crees tu propio código para generar un número aleatorio ni uses un generador de números aleatorios "simple" ofrecido por tu lenguaje de programación. Utiliza una fuente de números pseudo-aleatorios criptográficamente segura (FNPACS) con una semilla a partir de una fuente de entropía suficiente. Estudia la documentación de la biblioteca de generación de números aleatorios que elijas para estar seguro de que sea criptográficamente segura. La correcta implementación de una FNPACS es crítica para la seguridad de las claves.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>La siguiente es una clave privada (k) generada aleatoriamente, mostrada en formato hexadecimal (256 dígitos binarios representados en 64 dígitos hexadecimales, cada uno con 4 bits):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>El tamaño del espacio de claves privadas bitcoin, 2<sup>256</sup> es un número inimaginablemente grande. Es aproximadamente 10<sup>77</sup> en decimal. Se estima que el universo visible contiene 10<sup>80</sup> átomos.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Para generar una clave nueva con el cliente Bitcoin Core (ver <a href="#ch03_bitcoin_client">[ch03_bitcoin_client]</a>) usa el comando <tt>getnewaddress</tt>. Por razones de seguridad muestra solamente la clave pública, no la clave privada. Para pedir a bitcoind que exhiba la clave privada usa el comando <tt>dumpprivkey</tt>. El comando <tt>dumpprivkey</tt> muestra la clave privada en formato codificado en Base58 con checksum, <em>Formato de Importación de Cartera</em> (Wallet Import Fromat, o WIF), el cual examinaremos en mayor detalle en <a href="#priv_formats">[priv_formats]</a>. Aquí hay un ejemplo de generación y exhibición de una clave privada usando estos dos comandos:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bitcoind getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</tt></pre>
</div></div>
<div class="paragraph"><p>El comando <tt>dumpprivkey</tt> abre una cartera y extra la clave privada que fue generada por el comando <tt>getnewaddress</tt>. No es posible para bitcoind conocer la clave privada a partir de la clave pública a menos que estén ambas almacenadas en la cartera.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>El comando <tt>dumpprivkey</tt> no está generando una clave privada a partir de una clave pública, ya que esto es imposible. El comando simplemente revela la clave privada ya conocida por la cartera, la cual ha sido generada por el comando <tt>getnewaddress</tt>.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>También puedes usar la herramienta de línea de comando Bitcoin Explorer (ver <a href="#libbitcoin">[libbitcoin]</a>) para generar y mostrar claves privadas con los comandos <tt>seed</tt>, <tt>ec-new</tt> y <tt>ec-to-wif</tt>: </p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</tt></pre>
</div></div>
</div>
</div>
<div class="sect3">
<h4 id="pubkey">Claves Públicas</h4>
<div class="paragraph"><p>La clave pública es generada a partir de la clave privada usando multiplicación de curva elíptica, la cual es irreversible: \(K = k * G\) donde <em>k</em> es la clave privada, <em>G</em> es un punto constante llamado el <em>punto generador</em> y <em>K</em> es la clave pública resultante. La operación inversa, conocida como "encontrando el logaritmo discreto"—calcular <em>k</em> a partir de _K_—es tan difícil como probar todos los valors de <tt>k</tt>, es decir, una búsqueda por fuerza bruta. Antes de demostrar cómo generar una clave pública a partir de una clave privada, echemos una mirada a la criptografía de curva elíptica en más detalle.</p></div>
</div>
<div class="sect3">
<h4 id="elliptic_curve">Criptografía de Curva Elíptica Explicada</h4>
<div class="paragraph"><p>La criptografía de curva elíptica es un tipo de criptografía de asimétrica de clave pública basada en el problema del logaritmo discreto tal como se expresa por suma y multiplicación sobre puntos de una curva elíptica.</p></div>
<div class="paragraph"><p><a href="#ecc-curve">[ecc-curve]</a> es un ejemplo de una curva elíptica, similar a las usadas por bitcoin.</p></div>
<div class="imageblock" id="ecc-curve">
<div class="content">
<img src="images/msbt_0402.png" alt="ecc-curve" />
</div>
<div class="title">Figure 2. Una curva elíptica</div>
</div>
<div class="paragraph"><p>Bitcoin usa una curva elíptica específica y un conjunto de constantes matemáticas definidas en un estándar llamado <tt>secp256k1</tt>, establecido por el Instituto Nacional de Estándares y Tecnología (National Institute of Standards and Technology, o NIST). La curva <tt>secp256k1</tt> es definida por la siguiente función, la cual produce una curva elíptica:</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}</div></div>
<div class="paragraph"><p>ó</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}</div></div>
<div class="paragraph"><p>El <em>mod p</em> (módulo del número primo p) indica que la curva se encuentra sobre un cuerpo finito de orden <em>p</em>, también escrito como \(\mathbb{F}_p\), donde p = 2<sup>256</sup> – 2<sup>32</sup> – 2<sup>9</sup> – 2<sup>8</sup> – 2<sup>7</sup> – 2<sup>6</sup> – 2<sup>4</sup> – 1, un número primo muy grande.</p></div>
<div class="paragraph"><p>Ya que la curva se encuentra definida sobre un cuerpo finito de orden primo en vez de sobre los números reales, se ve como un patrón de puntos dispersos en dos dimensiones, lo cual lo vuelve difícil de visualizar. Sin embargo, la matemática es idéntica a la de la curva elíptica sobre los números reales. Como ejemplo, <a href="#ecc-over-F17-math">[ecc-over-F17-math]</a> muestra la misma curva elíptica sobre un cuerpo finito mucho menor de orden primo 17, mostrando un patrón de puntos sobre una grilla. La curva elíptica de bitcoin <tt>secp256k1</tt> puede pensarse como un patrón mucho más complejo de puntos sobre una grilla inconmensurablemente grande.</p></div>
<div class="imageblock" id="ecc-over-F17-math">
<div class="content">
<img src="images/msbt_0403.png" alt="ecc-over-F17-math" />
</div>
<div class="title">Figure 3. Criptografía de curva elíptica: visualizando una curva elíptica sobre F(p), con p=17</div>
</div>
<div class="paragraph"><p>Así que, por ejemplo, el siguiente es un punto P con coordenadas (x,y) que es un punto en la curva <tt>secp256k1</tt>. Puedes verificar esto tú mismo usando Python:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)</tt></pre>
</div></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>En matemática de curva elíptica existe un punto llamado el "punto al infinito," el cual corresponde al rol de 0 en la suma. En computadores a veces es representado como x = y = 0 (lo cual no satisface la ecuación de la curva elíptica, pero es un caso aislado simple que puede ser chequeado).</p></div>
<div class="paragraph"><p>Existe también un operador + llamado "suma," el cual posee ciertas propiedades similares a la suma tradicional de números reales que aprenden los niños en la escuela. Dados dos puntos P<sub>1</sub> y P<sub>2</sub> sobre una curva elíptica, existe un tercer punto P<sub>3</sub> = P<sub>1</sub> + P<sub>2</sub>, también sobre la curva.</p></div>
<div class="paragraph"><p>Geométricamente, este tercer punto  P<sub>3</sub> es calculado dibujando una línea entre P<sub>1</sub> y P<sub>2</sub>. Esta línea intersecará la curva elíptica en exactamente un punto adicional. Llamemos a este punto P<sub>3</sub>' = (x, y). Luego reflejamos el eje x para obtener P<sub>3</sub> = (x, –y).</p></div>
<div class="paragraph"><p>Existen un par de casos especiales que explican la necesidad del "punto al infinito".</p></div>
<div class="paragraph"><p>Si P<sub>1</sub> y P<sub>2</sub> son el mismo punto, la línea "entre" P<sub>1</sub> y P<sub>2</sub> debe extenderse para ser la tangente sobre la curva en el punto P<sub>1</sub>. Esta tangente intersecará la curva en exactamente un nuevo punto. Puedes usar técnicas de cálculo para determinar la pendiente de la línea tangencial. Estas técnicas curiosamente funcionan a pasar de estar restringiendo nuestro interés a puntos sobre la curva con coordenadas de dos enteros.</p></div>
<div class="paragraph"><p>En algunos casos (esto es, si P<sub>1</sub> y P<sub>2</sub> tienen el mismo valor en x pero distinto valor en y) la línea tangente será exactamente vertical, en cuyo caso P3 = "punto al infinito."</p></div>
<div class="paragraph"><p>Si P<sub>1</sub> es el "punto al infinito," entonces la suma P<sub>1</sub> + P<sub>2</sub> = P<sub>2</sub>. Similarmente, si P<sub>2</sub> es el punto al infinito, entonces P<sub>1</sub> + P<sub>2</sub> = P<sub>1</sub>. Esto muestra que el punto al infinito juega el rol de 0.</p></div>
<div class="paragraph"><p>Resulta que + es asociativo, lo cual significa que (A + B) + C = A + (B + C). Eso significa que podemos escribir A + B + C sin paréntesis y sin ninguna ambigüedad.</p></div>
<div class="paragraph"><p>Ahora que hemos definido la suma podemos definir la multiplicación en la forma estándar en que extiende a la suma. Para un punto P sobre la curva elíptica, si k es un número entero, entonces kP = P + P + P + &#8230; + P (k veces). Nótese que k es a veces llamada una "exponente" en este caso, lo cual puede causar confusión. </p></div>
</div>
<div class="sect3">
<h4 id="public_key_derivation">Generando una Clave Pública</h4>
<div class="paragraph"><p>Comenzando con una clave privada en la forma de un número <em>k</em> generado aleatoriamente, lo multiplicamos por un punto predeterminado de la curva llamado <em>punto generador</em> <em>G</em> para producir otro punto en algún otro punto de la curva, el cual será la clave pública <em>K</em> correspondiente. El punto generador es especificado como parte del estándar <tt>secp256k1</tt> y es siempre el mismo para todas las claves en bitcoin:</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{K = k * G}
\end{equation}</div></div>
<div class="paragraph"><p>donde k es la clave privada, G es el punto generador, y K es la clave pública resultante, un punto sobre la curva. Ya que el punto generador es siempre el mismo para todos los usuarios de bitcoin, una clave privada k multiplicada por G siempre dará como resultado la misma clave pública K. La relación entre k y K es fija, pero solo puede ser calculada en una dirección, de k a K. Esa es la razón por la que una dirección bitcoin (derivada de K) puede ser compartida con cualquiera sin revelar la clave privada (k) del usuario.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Una clave privada puede ser convertida a una clave pública, pero una clave pública no puede ser convertida en una clave privada ya que la matemática solo funciona en un sentido.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Para implementar la multiplicación de curva elíptica tomamos la clave privada k generada previamente y la multiplicamos por el punto generador G para encontrar la clave pública K:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</tt></pre>
</div></div>
<div class="paragraph"><p>La Clave Pública K se define como el punto <tt>K = (x,y)</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = (x, y)

donde,

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</tt></pre>
</div></div>
<div class="paragraph"><p>Para visualizar la multiplicación de un punto y un entero usaremos la más sencilla curva elíptica sobre los números reales—recuerda, la matemática es la misma. Nuestro objetivo es encontrar el múltiplo kG del punto generador G. Eso es lo mismo que sumar G a sí mismo k veces consecutivas. En curvas elípticas sumar un punto a sí mismo es el equivalente a dibujar una línea tangente sobre el punto y hallar dónde interseca la curva nuevamente y luego reflejar ese punto sobre el eje x.</p></div>
<div class="paragraph"><p><a href="#ecc_illustrated">[ecc_illustrated]</a> muestra el proceso de derivar G, 2G, 4G, como una operación geométrica sobre la curva.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>La mayoría de las implementaciones bitcoin usan la <a href="http://bit.ly/1ql7bn8">biblioteca criptográfica OpenSSL</a> para realizar los cálculos de curva elíptica. Por ejemplo, para derivar la clave pública se usa la función <tt>EC_POINT_mul()</tt>.</p></div>
</td>
</tr></table>
</div>
<div class="imageblock" id="ecc_illustrated">
<div class="content">
<img src="images/msbt_0404.png" alt="ecc_illustrated" />
</div>
<div class="title">Figure 4. Criptografía de curva elíptica: Visualizando la multiplicacion de un punto G por un entero k sobre una curva elíptica</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_direcciones_bitcoin">Direcciones Bitcoin</h3>
<div class="paragraph"><p>Una dirección bitcoin es una cadena de dígitos y carácteres que puede ser compartida con cualquiera que desee enviarte dinero. Las direcciones producidas a partir de una clave pública consisten de una cadena de números y letras, comenzando por el dígito "1". Aquí hay un ejemplo de una dirección bitcoin:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</tt></pre>
</div></div>
<div class="paragraph"><p>La dirección bitcoin es lo que más frecuentemente aparece como el "destinatario" de los fondos. Si comparásemos una transacción bitcoin un cheque en papel, la dirección bitcoin sería el beneficiario, es decir, lo que escribimos en la línea luego de "Páguese a la orden de." En un cheque en papel el beneficiario puede a veces ser el nombre del titular de una cuenta bancaria, pero puede incluir también corporaciones, instituciones, o incluso efectivo. El hecho de que los cheques en papel no requieren de especificar una cuenta, sino que en cambio usan un nombre abstracto como destinatario de los fondos, los convierte en instrumentos de pago muy flexibles. Las transacciones bitcoin usan una abstracción similar para ser muy flexibles: la dirección bitcoin. Una dirección bitcoin puede representar al propietario del par de clave privada y pública, o puede representar otra cosa, como un script de pago, como veremos en <a href="#p2sh">[p2sh]</a>. Por ahora examinemos el caso simple: una dirección bitcoin que representa y es derivada de una clave pública.</p></div>
<div class="paragraph"><p>La dirección bitcoin es derivada de la clave pública a través del uso de hashing criptográfico de sentido único. Un "algoritmo de hashing", o simplemente un "algoritmo de hash" es una función de sentido único que produce una huella o "hash" a partir de una entrada de tamaño arbitrario. Las funciones de hash criptográfico son usadas extensivamente en bitcoin: en las direcciones bitcoin, en las direcciones de script, y en algoritmo de prueba de trabajo de minado. Los algoritmos usados para crear direcciones bitcoin a partir de claves públicas son el Secure Hash Algorithm (SHA) y el RACE Integrity Primitives Evaluation Message Digest (RIPEMD), específicamente SHA256 y RIPEMD160.</p></div>
<div class="paragraph"><p>A partir de la clave pública K computamos el hash SHA256 y luego computamos el hash RIPEMD160 del resultado, produciendo un número de 160 bits (20 bytes):</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}</div></div>
<div class="paragraph"><p>donde K es la clave pública y A es la dirección bitcoin resultante.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Una dirección bitcoin <em>no es</em> lo mismo que una clave pública. Las direcciones bitcoin son derivadas de una clave pública a través de una función de sentido único.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Las direcciones bitcoin son casi siempre presentadas a los usuarios en una codificación llamada "Base58Check" (ver <a href="#base58">[base58]</a>), la cual usa 58 carácteres (un sistema numérico de base 58) y un checksum para ayudar a la legibilidad humana, evitar ambigüedad y proteger de errores en la transcripción y entrada de direcciones. Base58Check también es usado en muchas otras formas en bitcoin, siempre que haya una necesidad de que un usuario lea y transcriba un número correctamente, tal como una dirección bitcoin, una clave privada, una clave encriptada, o un hash de script. En la siguiente sección examinaremos las mecánicas de la codificación y decodificación de Base58Check y las representaciones resultantes. <a href="#pubkey_to_address">[pubkey_to_address]</a> ilustra la conversión de una clave pública a una dirección bitcoin.</p></div>
<div class="imageblock" id="pubkey_to_address">
<div class="content">
<img src="images/msbt_0405.png" alt="pubkey_to_address" />
</div>
<div class="title">Figure 5. Clave pública a dirección bitcoin: conversión de una clave pública en una dirección bitcoin</div>
</div>
<div class="sect3">
<h4 id="base58">Codificación Base58 y Base58Check</h4>
<div class="paragraph"><p>Para representar números largos en forma compacta, usando menos símbolos, muchos sistemas informáticos utilizan representaciones alfanuméricas mezcladas con una base mayor a 10. Por ejemplo, mientras el sistema decimal tradicional utiliza 10 numerales, de 0 a 9, el sistema hexadecimal usa 16, con letras de la A a la F como los seis símbolos adicionales. Un número representado en formato hexadecimal es más breve que su equivalente representación decimal. Aun más compacta, la representación Base-64 usa 26 letras minúscula, 26 letras mayúscula, 10 numerales y dos carácteres más como "+" y "/" para transmitir datos binarios sobre medios de texto plano, tal como email. Base-64 es más comúnmente usado para añadir adjuntos binarios en emails. Base58 es un formato de codificación binaria basada en texto desarrollada para su uso en bitcoin y utilizada en muchas otras criptomonedas. Ofrece un balance entre representación compacta, legibilidad y detección y prevención de errores. Base58 es un subconjunto de Base64, usando las letras mayúsculas y minúsculas y números, pero omitiendo algunos carácteres que a menudo son confundidos por otros y pueden verse idénticos cuando se representan con ciertas fuentes. Específicamente, Base58 es Base64 sin el 0 (número cero), O (letra o mayúscula), l (letra L minúscula), I (letra i mayúscula) y los símbolos "\+" y "/". O, puesto de forma más sencilla, es el conjunto de letras mayúscula y minúscula y números sin los cuatro (0, O, l, I) que acabamos de mencionar.</p></div>
<div class="exampleblock" id="base58alphabet">
<div class="title">Example 1. alfabeto Base58 de bitcoin</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre><tt>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</tt></pre>
</div></div>
</div></div>
<div class="paragraph"><p>Para añadir seguridad extra contra errores tipográficos o de transcripción, Base58Check es un formato de codificación de Base58, usado frecuentemente en bitcoin, el cual posee un código de chequeo de errores. El checksum consiste de cuatro bytes adicionales añadidos al final de los datos siendo codificados. El checksum es derivado del hash de los datos codificados y puede por ende ser usado para detectar y prevenir errores de transcripción o tipeo. Cuando el código de decodificación es presentado con un código Base58Check calculará el checksum de los datos y lo comparará con el checksum incluído en el código. Si no son idénticos significa que ha habido un error y el código Base58Check es inválido. Por ejemplo, esto previene que una dirección bitcoin tipeada erróneamente sea aceptada por el software de cartera como un destinatario válido, un error que de lo contrario resultaría en la pérdida de fondos.</p></div>
<div class="paragraph"><p>Para convertir datos (un número) al formato Base58Check primero agregamos un prefijo a los datos, llamado el "byte de versión," el cual sirve para identificar fácilmente el tipo de datos siendo codificados. Por ejemplo, en el caso de una dirección bitcoin el prefijo es cero (0x00 en hexadecimal), mientras que el prefijo usado cuando se codifica una clave privada es 128 (0x80 en hexadecimal). Una lista de prefijos de versión comunes puede verse en <a href="#base58check_versions">[base58check_versions]</a>.</p></div>
<div class="paragraph"><p>A continuación computamos el checksum "doble SHA", lo que significa que aplicamos el algoritmo de hash SHA256 dos veces sobre resultado previo (prefijo y datos):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>checksum = SHA256(SHA256(prefijo+datos))</tt></pre>
</div></div>
<div class="paragraph"><p>Del hash de 32 bytes resultante (hash de un hash) tomamos solo los primeros cuatro bytes. Estos cuatro bytes sirven como el código de chequeo de error, o checksum. El checksum es concatenado (o anexado) al final.</p></div>
<div class="paragraph"><p>El resultado está compuesto de tres elementos: un prefijo, los datos y un checksum. Este resultado es codificado usando el alfabeto Base58 descrito anteriormente. <a href="#base58check_encoding">[base58check_encoding]</a> ilustra el proceso de codificación Base58Check.</p></div>
<div class="imageblock" id="base58check_encoding">
<div class="content">
<img src="images/msbt_0406.png" alt="Base58CheckEncoding" />
</div>
<div class="title">Figure 6. Codificación Base58Check: un formato Base58, con versión y checksum para codificar datos bitcoin sin ambigüedades</div>
</div>
<div class="paragraph"><p>En bitcoin la mayoría de los datos presentados al usuario son codificados usando Base58Check para hacerlos compactos, fáciles de leer, y facilitar la detección de errores. El prefijo de versión en la codificación Base58Check es usada para crear formatos distinguibles fácilmente, los cuales al ser codificados en Base58 contienen carácteres específicos al principio de la carga codificada en Base58Check. Estos carácteres facilitan a humanos la identificación del tipo de los datos codificados y cómo usarlos. Esto es lo que diferencia, por ejemplo, a las direcciones bitcoin codificadas en Base58Check comenzadas en 1 del formato WIF de claves privada codifacada en Base58Check comenzadas en 5. Algunos ejemplos de prefijos d eversión y sus carácteres Base58 resultantes se muestra en <a href="#base58check_versions">[base58check_versions]</a>.</p></div>
<?hard-pagebreak?>
<div class="tableblock" id="base58check_versions">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Prefijos de versión Base58Check y ejemplos de resultados codificados</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Tipo</p></td>
<td align="left" valign="top"><p class="table">Prefijo de versión (hexadecimal)</p></td>
<td align="left" valign="top"><p class="table">Prefijo del resultado Base58</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Dirección Bitcoin</p></td>
<td align="left" valign="top"><p class="table">0x00</p></td>
<td align="left" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Dirección Pago-a-Hash-de-Script</p></td>
<td align="left" valign="top"><p class="table">0x05</p></td>
<td align="left" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Dirección de Testnet Bitcoin</p></td>
<td align="left" valign="top"><p class="table">0x6F</p></td>
<td align="left" valign="top"><p class="table">m o n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF de Clave Privada</p></td>
<td align="left" valign="top"><p class="table">0x80</p></td>
<td align="left" valign="top"><p class="table">5, K o L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Clave Privada con Encriptación BIP38</p></td>
<td align="left" valign="top"><p class="table">0x0142</p></td>
<td align="left" valign="top"><p class="table">6P</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Clave Pública Extendida BIP32</p></td>
<td align="left" valign="top"><p class="table">0x0488B21E</p></td>
<td align="left" valign="top"><p class="table">xpub</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Veamos el proceso completo de creación de una dirección bitcoin, partiendo de una clave privada, a una clave pública (un punto en la clave elíptica) a una dirección doblemente hasheada y finalmente la codificación Base58Check. El código C++ <a href="#addr_example">[addr_example]</a> muestra el proceso completo paso a paso, desde clave privada hasta dirección bitcoin codificada en Base58Check. El código de ejemplo usa la biblioteca libbitcoin presentada en <a href="#alt_libraries">[alt_libraries]</a> para algunas funciones útiles.</p></div>
<div class="exampleblock" id="addr_example">
<div class="title">Example 2. Creando una dirección bitcoin codificada en Base58Check a partir de una clave privada</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>El código usa una clave privada predefinida de forma que produzca la misma dirección bitcoin cada vez que es ejecutado, como se muestra en <a href="#addr_example_run">[addr_example_run]</a>.</p></div>
<div class="exampleblock" id="addr_example_run">
<div class="title">Example 3. Compilando y ejecutando el código addr</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_formatos_de_claves">Formatos de Claves</h4>
<div class="paragraph"><p>Tanto las claves privadas como públicas pueden ser representadas en un número de foromatos distintos. Todas estas representaciones codifican el mismo número a pesar de verse diferentes. Estos formatos son principalmente usados para facilitar el trabajo a las personas al leer y transcribir claves sin introducir errores.</p></div>
<div class="sect4">
<h5 id="priv_formats">Formatos de claves privadas</h5>
<div class="paragraph"><p>La clave privada puede ser representada en un número de formatos distintos, todos los cuales corresponden al mismo número de 256 bits. <a href="#table_4-2">[table_4-2]</a> muestra tres formatos comunes usados para representar claves privadas.</p></div>
<div class="tableblock" id="table_4-2">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Representaciones de claves privadas (formatos de codificación)</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Tipo</p></td>
<td align="left" valign="top"><p class="table">Prefijo</p></td>
<td align="left" valign="top"><p class="table">Descripción</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Hexadecimal</p></td>
<td align="left" valign="top"><p class="table">Ninguno</p></td>
<td align="left" valign="top"><p class="table">64 dígitos hexadecimales</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">Codificación Base58Check: Base58 con un prefijo de versión de 128 y checksum de 32 bits</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF comprimido</p></td>
<td align="left" valign="top"><p class="table">K o L</p></td>
<td align="left" valign="top"><p class="table">Como el caso anterior, con sufijo 0x01 añadido antes de codificar</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>La tabla <a href="#table_4-3">[table_4-3]</a> muestra la clave privada generada en estos tres formatos.</p></div>
<?hard-pagebreak?>
<div class="tableblock" id="table_4-3">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Ejemplo: Misma clave, formatos distintos</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Formato</p></td>
<td align="left" valign="top"><p class="table">Clave Privada</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Hexadecimal</p></td>
<td align="left" valign="top"><p class="table">1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF comprimido</p></td>
<td align="left" valign="top"><p class="table">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Todas estas representaciones son formas distintas de mostrar el mismo número, la misma clave privada. Se ven distintas, pero cualquiera de estos formatos puede ser convertido fácilmente a cualquier otro formato.</p></div>
<div class="paragraph"><p>Usamos el  comando <tt>wif-to-ec</tt> de Bitcoin Explorer (ver <a href="#libbitcoin">[libbitcoin]</a>) para mostrar que ambas claves WIF representan la misma clave privada:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_decodificar_a_partir_de_base58check">Decodificar a partir de Base58Check</h5>
<div class="paragraph"><p>Los comandos de Bitcoin Explorer (ver <a href="#libbitcoin">[libbitcoin]</a>) facilitan el escribir shell scripts y "tubos" de línea de comando que manipulan claves bitcoin, direcciones y transacciones. Puedes usar Bitcoin Explorer para decodificar el formato Base58Check en la línea de comandos.</p></div>
<div class="paragraph"><p>Usamos el comando <tt>base58check-decode</tt> para decodificar la clave sin comprimir:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}</tt></pre>
</div></div>
<div class="paragraph"><p>El resultado contiene la clave como su carga (payload), el prefijo de versión 128 del Formato de Importación de Cartera (WIF) y un checksum.</p></div>
<div class="paragraph"><p>Nótese que la "carga" de la clave comprimida es anexada con el sufijo <tt>01</tt>, dando la señal de que la clave pública derivada debe ser comprimida.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_codificar_de_hexadecimal_a_base58check">Codificar de hexadecimal a Base58Check</h5>
<div class="paragraph"><p>Para codificar a Base58Check (lo opuesto al comando anterior) usamos el comando <tt>base59check-encode</tt> de Bitcoin Explorer (ver <a href="#libbitcoin">[libbitcoin]</a>) y proveemos la clave privada hexadecimal, seguida por el prefijo de versión 128 del Formato de Importación de Cartera (WIF):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_codificar_de_hexadecimal_clave_comprimida_a_base58check">Codificar de hexadecimal (clave comprimida) a Base58Check</h5>
<div class="paragraph"><p>Para codificar a Base58Check como una clave privada "comprimida" (ver <a href="#comp_priv">[comp_priv]</a>) anexamos el sufijo <tt>01</tt> a la clave hexadecimal y luego codificamos como anteriormente:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</tt></pre>
</div></div>
<div class="paragraph"><p>El formato resultante WIF comprimido comienza con una "K". Esto denota que la clave privada dentro tiene un sufijo de "01" y será usada para producir claves públicas comprimidas únicamente (ver <a href="#comp_pub">[comp_pub]</a>).</p></div>
</div>
<div class="sect4">
<h5 id="_formatos_de_claves_públicas">Formatos de claves públicas</h5>
<div class="paragraph"><p>Las claves públicas también son presentadas en distintas formas, principalmente como claves públicas <em>comprimidas</em> o <em>descomprimidas</em>.</p></div>
<div class="paragraph"><p>Como vimos previamente, la clave pública es un punto sobre la curva elíptica el cual consiste de un par de coordenadas <tt>(x,y)</tt>. Usualmente es representada con el prefijo <tt>04</tt> seguido por dos números de 256 bits, uno para la coordenada <em>x</em> del punto, y otro para la coordenada <em>y</em>. El prefijo <tt>04</tt> es usado para distinguir claves públicas descomprimidas a partir de claves públicas comprimidas que comienzan con un <tt>02</tt> o un <tt>03</tt>.</p></div>
<div class="paragraph"><p>Aquí hay una clave pública generada por la clave privada que creamos previamente, mostrada como las coordenadas <tt>x</tt> e <tt>y</tt>.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</tt></pre>
</div></div>
<div class="paragraph"><p>Aquí está la misma clave pública mostrada como un número de 520 bits (130 dígitos hexadecimales) con el prefijo <tt>04</tt> seguido por las coordenadas <tt>x</tt> y luego <tt>y</tt>, como <tt>04 x y</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&lt;?pdf-cr?&gt;07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="comp_pub">Claves públicas comprimidas</h5>
<div class="paragraph"><p><?dbhtml orphans="4"?>Las claves públicas comprimidas fueron introducidas a bitcoin para reducir el tamaño de las transacciones y conservar espacio en disco en los nodos que almacenan la base de datos de la cadena de bloques bitcoin. La mayoría de las transacciones incluye la clave pública requerida para validar las credenciales del propietario y gastar los bitcoins. Cada clave pública requiere 520 bits (prefijo \+ x \+ y), que al ser multiplicados por varios cientos de transacciones por bloque, o decenas de miles de transacciones por día, suman una cantidad significativa de datos a la cadena de bloques.</p></div>
<div class="paragraph"><p>Como vimos en la sección <a href="#pubkey">[pubkey]</a>, una clave pública es un punto (x,y) sobre una curva elíptica. Ya que la curva expresa una función matemática, un punto sobre la curva representa una solución a una ecuación, y por ende, si conocemos la coordenada <em>x</em> podemos calcular la coordenada <em>y</em> resolviendo la ecuación y<sup>2</sup> mod p = (x<sup>3</sup> + 7) mod p. Esto nos permite almacenar solamente la coordenada <em>x</em> del punto de clave pública, omitiendo la coordenada <em>y</em> y reduciendo el tamaño de la clave y el espacio requerido para almacenarla en 256 bits. ¡Una reducción en tamaño de casi el 50% por transacción representa muchos datos ahorrados con el transcurrir del tiempo!</p></div>
<div class="paragraph"><p>Mientras que las claves públicas descomprimidas llevan el prefijo <tt>04</tt>,  las claves públicas comprimidas empiezan con el prefijo <tt>02</tt> o <tt>03</tt>. Veamos por qué hay dos prefijos posibles: ya que el lado izquierdo de la ecuación es y<sup>2</sup> la solución para y es una raíz cuadrada, la cual puede tener un valor positivo o negativo. Visualmente esto significa que la coordenada <em>y</em> resultante puede encontrarse por encima o por debajo del eje x. En el gráfico de la curva elíptica <a href="#ecc-curve">[ecc-curve]</a> se puede observar que la curva es simétrica, lo cual significa que es reflejada como un espejo por el eje x. Entonces, a pesar de poder omitir la coordenada <em>y</em> debemos almacenar el <em>signo</em> de y (positivo o negativo), o, en otras palabras, debemos recordar si estaba por encima o por debajo del eje x, ya que cada una de esas opciones representa un distinto punto y distinta clave pública. Cuando calculamos la curva elíptica en aritmética binaria sobre el cuerpo finitio de orden primo p, la coordenada <em>y</em> es o bien par o impar, lo cual corresponde al signo positivo o negativo explicado anteriormente. Por ende, para distinguir entre los dos posibles valores de y almacenamos una clave pública comprimida con el prefijo <tt>02</tt> si <tt>y</tt> es par, y <tt>03</tt> si es impar, permitiendo al software deducir correctamente la coordenada <em>y</em> a partir de la coordenada <em>x</em> y descomprimir la clave pública obteniendo las coordenadas completas del punto. La compresión de clave pública es ilustrada en <a href="#pubkey_compression">[pubkey_compression]</a>.</p></div>
<div class="imageblock" id="pubkey_compression">
<div class="content">
<img src="images/msbt_0407.png" alt="pubkey_compression" />
</div>
<div class="title">Figure 7. Compresión de clave pública</div>
</div>
<div class="paragraph"><p>Aquí está la misma clave pública generada anteriormente, mostrada como una clave pública comprimida almacenada en 264 bits (66 dígitos hexadecimales) con el prefijo <tt>03</tt> indicando que la coordenada <em>y</em> es impar:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</tt></pre>
</div></div>
<div class="paragraph"><p>Esta clave pública comprimida corresponde a la misma clave privada, lo que significa que es generada a partir de la misma clave privada. Sin embargo se ve distinta de la clave pública descomprimida. Más importante aun, si convertimos esta clave pública comprimida a una dirección bitcoin usando la función de hash doble (<tt>RIPEMD160(SHA256(K))</tt>) producirá una dirección bitcoin <em>diferente</em>. Esto puede resultar confuso, ya que significa que una misma clave privada puede producir una clave pública expresada en dos formatos distintos (comprimida y descomprimida) que producen dos direcciónes bitcoin diferentes. Sin embargo, la clave privada es idéntica para ambas direcciones bitcoin.</p></div>
<div class="paragraph"><p>Las claves públicas comprimidas se están convirtiendo gradualmente en la opción por defecto en todos los clientes bitcoin, lo cual está teniendo un impacto significativo sobre la reducción del tamaño de transacciones y por ende la cadena de bloques. Sin embargo, no todos los clientes soportan claves públicas comprimidas aun. Los clientes más recientes que soportan claves públicas comprimidas tiene que tener en cuenta transacciones de clientes más antiguos que no soportan claves públicas comprimidas. Esto es especialmente importante cuando una aplicación de cartera importa claves privadas de otra aplicación de cartera bitcoin, ya que la nueva cartera necesita escanear la cadena de bloques para encontrar transacciones correspondientes a estas claves importadas. ¿Qué direcciones bitcoin debe buscar la cartera bitcoin? ¿Las direcciones bitcoin producidas por claves públicas descomprimidas, o las direcciones bitcoin producidas por claves públicas comprimidas? Ambas son direcciones bitcoin válidas, y la clave privada puede firmar por ellas, ¡pero son direcciones distintas!</p></div>
<div class="paragraph"><p>Para resolver este problema el Formato de Importación de Cartera (WIF) usado al exportar claves privadas de una cartera es implementado en forma diferente en carteras más recientes, indicando de esta forma que dichas claves privadas han sido usadas para producir claves públicas <em>comprimidas</em> y por ende direcciones bitcoin <em>comprimidas</em>. Esto permite a la cartera a la que se importa distinguir entre claves privadas originadas en carteras recientes o antiguas y buscar transacciones en la cadena de bloques que posean direcciones correspondientes a las claves públicas comprimidas o descomprimidas, respectivamente. Veamos cómo esto funciona en mayor detalle en la siguiente sección.</p></div>
</div>
<div class="sect4">
<h5 id="comp_priv">Claves privadas comprimidas</h5>
<div class="paragraph"><p>Irónicamente el término "clave privada comprimida" es engañoso, ya que al exportar una clave privada como WIF comprimida resulta de hecho siendo un byte <em>más larga</em> que una clave privada "descomprimida". Esto es debido a que añade el sufijo 01, el cual significa que proviene de una cartera más reciente y no debe ser usada para producir claves públicas comprimidas. Las claves privadas no son comprimidas y no pueden ser comprimidas. El término "clave privada comprimida" en realidad significa "clave privada a partir de la cual debe derivarse una clave pública comprimida," mientras que "clave privada descomprimida" realmente significa "clave privada a partir de la cual debe derivarse una clave pública descomprimida." Para evitar mayor confusión debes referirte a los formatos de exportación como "WIF comprimido" o "WIF" en vez de referirte a las claves privadas como "comprimidas."</p></div>
<div class="paragraph"><p>Recuerda, estos formatos <em>no son</em> usados de manera intercambiable. En una cartera más reciente que implementa claves públicas comprimidas las claves privadas serán exhibidas únicamente como WIF comprimido (con prefijo K o L). Si la cartera es una implementación más antigua y no usa claves públicas comprimidas, las claves privadas solo serán exhibidas como WIF (con prefijo 5). El objetivo aquí es comunicar a la cartera que importará estas claves privadas si debe buscar en la cadena de bloques por direcciones y claves públicas comprimidas o descomprimidas.</p></div>
<div class="paragraph"><p>Si una cartera bitcoin es capaz de implementar claves públicas comprimidas las usará en todas las transacciones. Las claves privadas en la cartera serán usadas para derivar los puntos de clave pública sobre la curva, los cuales serán comprimidos. Las claves públicas comprimidas serán usadas para producir direcciones bitcoin y esas serán usadas en transacciones. Al exportar claves privadas desde una nueva cartera que implementa claves públicas comprimidas, el Formato de Importación de Cartera es modificado, con el añadido del sufijo de un byte <tt>01</tt> a la clave privada. La clave privada resultante codificada en Base58Check se llama "WIF Comrpimido" y comienza con la letra K o L en vez de con un "5" como es el caso de claves codificadas en WIF (descomprimido) de carteras más antiguas.</p></div>
<div class="paragraph"><p><a href="#table_4-4">[table_4-4]</a> muestra la misma clave codificada en formatos WIF y WIF comprimido.</p></div>
<div class="tableblock" id="table_4-4">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 4. Ejemplo: Misma clave, formatos distintos</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Formato</p></td>
<td align="left" valign="top"><p class="table">Clave Privada</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Hex</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Hexadecimal comprimido</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD_01_</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF comprimido</p></td>
<td align="left" valign="top"><p class="table">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>¡"Claves privadas comprimidas" es un nombre poco apropiado! No son comprimidas; en cambio, el formato WIF comprimido significa que deben ser usadas para derivar claves públicas comprimidas y sus direcciones bitcoin correspondientes. Irónicamente, una clave privada codificada con WIF comprimido es un byte más largo ya que tiene el sufijo 01 añadido para distinguirlo de una "descomprimida".</p></div>
</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_implementando_claves_y_direcciones_en_python">Implementando Claves y Direcciones en Python</h3>
<div class="paragraph"><p>La biblioteca bitcoin en Python más completa es <a href="https://github.com/vbuterin/pybitcointools">pybitcointools</a> por Vitalik Buterin. En <a href="#key-to-address_script">[key-to-address_script]</a>, usamos la biblioteca (importada como "bitcoin") para generar y mostrar claves y direcciones en varios formatos.</p></div>
<div class="exampleblock" id="key-to-address_script">
<div class="title">Example 4. Generación y formato de clave y dirección con la biblioteca pybitcointools</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p><a href="#key-to-address_script_run">[key-to-address_script_run]</a> muestra la salida de ejecutar este código.</p></div>
<div class="exampleblock" id="key-to-address_script_run">
<div class="title">Example 5. Ejecutando key-to-address-ecc-example.py</div>
<div class="content">
<screen>
$ python key-to-address-ecc-example.py
Private Key (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (decimal) is:
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) is:
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key Compressed (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF-Compressed) is:
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key (x,y) coordinates is:
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L,
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (hex) is:
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec<?pdf-cr?>243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
Compressed Public Key (hex) is:
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is:
 1thMirt546nngXqyPEz532S8fLwbozud8
Dirección Bitcoin Comprimida (b58check) es:
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</screen>
</div></div>
<div class="paragraph"><p><a href="#ec_math">[ec_math]</a> es otro ejemplo, usando la biblioteca Python ECDSA para la matemática de curva elíptica y sin usar ninguna biblioteca bitcoin especializada.</p></div>
<div class="exampleblock" id="ec_math">
<div class="title">Example 6. Un script mostrando la matemática de curva elíptica usada para claves bitcoin</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p><a href="#ec_math_run">[ec_math_run]</a> muestra la salida producida al ejecutar este script.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>El ejemplo previo usa <tt>os.urandom</tt>, el cual refleja un generador de números aleatorios criptográficamente seguro (CSRNG) provisto por el sistema operativo. En el caso de un sistema tipo UNIX, como Linux, obtendrá sus números de <tt>/dev/urandom</tt>; y en el caso de Windows llamará a <tt>CryptGenRandom()</tt>. Si no se encuentra una fuente de azar confiable un error <tt>NotImplementedError</tt> será lanzado. Mientras que el generador de números aleatorios usado aquí es para propósitos demostrativos, <em>no es</em> apropiado para generar claves bitcoin de calidad de producción ya que no fue implementado con seguridad suficiente.</p></div>
</div></div>
<div class="exampleblock" id="ec_math_run">
<div class="title">Example 7. Instalando la biblioteca Python ECDSA y ejecutando el script ec_math.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre><tt>$ # Instalar el administrador de paquetes Python PIP
$ sudo apt-get install python-pip
$ # Instalar la biblioteca Python ECDSA
$ sudo pip install ecdsa
$ # Ejecutar el script
$ python ec-math.py
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873</tt></pre>
</div></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_carteras">Carteras</h3>
<div class="paragraph"><p>Las carteras son contenedores de claves privadas, usualmente implementadas como archivos estructurados o simples bases de datos.
Otro método para hacer claves es la <em>generación determinística de claves</em>. En ella derivas cada nueva clave privada usando una función de hash de sentido único de una clave privada previa, vinculándolas en una secuencia. Siempre y cuando puedas recrear esa secuencia tan solo necesitas de la primera clave (conocida como clave <em>semilla</em> o <em>maestra</em>) para generarlas todas. En esta sección examinaremos las distintas maneras de generar claves y las estructuras de cartera que se construyen a su alrededor.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Las carteras bitcoin contienen claves, no monedas. Cada usuario posee una cartera conteniendo claves. Las carteras son en esencia llaveros conteniendo pares de claves privadas/públicas (ver <a href="#private_public_keys">[private_public_keys]</a>). Los usuarios firman transacciones con las claves, demostrando de esa forma que son dueños de las salidas de transacción (sus monedas). Las monedas son almacenadas en la cadena de bloques en forma de salidas de transacción (a menudo notadas como vout o txout).</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="random_wallet">Carteras No Determinísticas (Aleatorias)</h4>
<div class="paragraph"><p> En los primeros clientes bitcoin, las carteras eran simplemente colecciones de claves privadas generadas aleatoriamente. Este tipo de cartera se conoce como <em>cartera no determinista de tipo 0</em>. Por ejemplo,  el cliente Bitcoin Core genera previamente 100 claves privadas aleatorias cuando se inicia, y genera más claves cuando son necesarias, usando cada clave solamente una vez. Este tipo de cartera se conoce como "Simplemente un Montón De Claves," o JBOK, y están siendo reemplazadas por carteras deterministas porque son engorrosas de manejar, respaldar e importar.  La desventaja de las carteras aleatorias es que si generas muchas has de realizar copia de todo, lo que supone que la cartera ha de ser respaldada de forma frecuente. Cada clave ha de respaldarse, o los fondos que controla se pierden irrevocablemente si la cartera pasa a ser inaccesible. Esto entra en conflicto directamente con el principio de evitar la reutilización de direcciones, usando cada dirección de bicoin durante solo una transacción&#8230; La reutilización de direcciones reduce la privacidad mediante la asociación de múltiples transacciones y direcciones con los demás. Una cartera de tipo 0 no determinista es una mala elección de cartera, sobre todo si se quiere evitar dirección de reutilización porque eso significa gestionar muchas claves, lo que crea la necesidad de copias de seguridad frecuentes. Aunque el cliente Bitcoin Core incluye una cartera tipo 0, el uso de esta cartera es desaconsejado por los desarrolladores de Bitcoin Core. &lt;&lt; &gt;&gt; Type0_wallet muestra una billetera no determinista, que contiene un conjunto disperso de claves aleatorias.</p></div>
</div>
<div class="sect3">
<h4 id="_carteras_determinísticas_a_partir_de_semilla">Carteras Determinísticas (A Partir de Semilla)</h4>
<div class="paragraph"><p>((("wallets","seeded"))Determinista, o " cartera sembradas "son carteras que contienen claves privadas que surgen a partir de una semilla común, mediante el uso de una función hash unidireccional. La semilla es un número generado aleatoriamente que se combina con otros datos, como un número de índice o "código de cadena" (ver &lt; &lt;hd_wallets&gt; &gt;) Para derivar las claves privadas. En una cartera determinista, la semilla es suficiente para recuperar todas las claves derivadas, y por lo tanto una única copia de seguridad en el momento de la creación es suficiente. La semilla también es suficiente para una exportación de cartera o de importación, lo que permite una fácil migración de todas las claves de los usuarios entre diferentes implementaciones de cartera.</p></div>
<div class="imageblock" id="Type0_wallet">
<div class="content">
<img src="images/msbt_0408.png" alt="non-deterministic wallet" />
</div>
<div class="title">Figure 8. Cartera no determinística (aleatoria) tipo 0: una colección de claves generadas aleatoriamente</div>
</div>
</div>
<div class="sect3">
<h4 id="mnemonic_code_words">Palabras Código Mnemónicas</h4>
<div class="paragraph"><p>Los códigos mnemotécnicos son palabras en inglés que representan (codifican) un número aleatorio utilizado como semilla para obtener una cartera determinista. La secuencia de palabras es suficiente para volver a crear la semilla y desde allí volver a crear la cartera y todas las claves derivadas. Una aplicación de monedero que implementa billeteras deterministas con código nemotécnico mostrará al usuario una secuencia de 12 a 24 palabras al crear primero una billetera. Esa secuencia de palabras es la copia de seguridad de la carpeta y se puede utilizar para recuperar y volver a crear todas las claves de la misma o de cualquier aplicación de monedero compatible. Las palabras de código mnemotécnico hace que sea más fácil para los usuarios realizar copias de seguridad de las carteras, ya que son fáciles de leer y transcribir correctamente, en comparación con una secuencia aleatoria de números.</p></div>
<div class="paragraph"><p>Los códigos mnemotécnicos se definen en  la Propuesta de Mejoras de Bitcoin 39 (ver &lt; &lt;bip0039&gt; &gt;), Actualmente su estado está en proyecto. Tenga en cuenta que BIP0039 es una propuesta de proyecto y no una norma. En concreto, hay un estándar diferente, con un conjunto diferente de las palabras, utilizado por la ("carteraElectrum" (()))  cartera Electrum y precediendo a BIP0039 . BIP0039 es utilizado por la   cartera Trezor y algunas otras carteras, pero es incompatible con la aplicación de Electrum.</p></div>
<div class="paragraph"><p>BIP0039 define la creación de un código y semilla mnemónicos de la siguiente manera:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Crear una secuencia aleatoria (entropía) de 128 a 256 bits.
</p>
</li>
<li>
<p>
Crear un checksum de la secuencia aleatoria tomando los primeros pocos bits de su hash SHA256.
</p>
</li>
<li>
<p>
Anexar el checksum al final de la secuencia aleatoria.
</p>
</li>
<li>
<p>
Dividir la secuencia en secciones de 11 bits, usándolas para indexar un diccionario de 2048 palabras predefinidas.
</p>
</li>
<li>
<p>
Producir 12 a 24 palabras representando el código mnemónico.
</p>
</li>
</ol></div>
<div class="paragraph"><p><a href="#table_4-5">[table_4-5]</a> muestra la relación entre el tamaño de datos de entropía y la longitud de los códigos mnemónicos en palabras.</p></div>
<div class="tableblock" id="table_4-5">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 5. Códigos mnemónicos: entropía y longitud de palabra</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Entropía (bits)</p></td>
<td align="left" valign="top"><p class="table">Checksum (bits)</p></td>
<td align="left" valign="top"><p class="table">Entropía+checksum</p></td>
<td align="left" valign="top"><p class="table">Longitud de palabra</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">128</p></td>
<td align="left" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table">132</p></td>
<td align="left" valign="top"><p class="table">12</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">160</p></td>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">165</p></td>
<td align="left" valign="top"><p class="table">15</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">192</p></td>
<td align="left" valign="top"><p class="table">6</p></td>
<td align="left" valign="top"><p class="table">198</p></td>
<td align="left" valign="top"><p class="table">18</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">224</p></td>
<td align="left" valign="top"><p class="table">7</p></td>
<td align="left" valign="top"><p class="table">231</p></td>
<td align="left" valign="top"><p class="table">21</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">256</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
<td align="left" valign="top"><p class="table">264</p></td>
<td align="left" valign="top"><p class="table">24</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>El código mnemónico representa de 128 a 256 bits, los cuales son usados para derivar una semilla más larga (512 bits) a través del uso de la función de estiramiento de clave PBKDF2. La semilla resultante es usada para crear una cartera determinística y todas sus claves derivadas.</p></div>
<div class="paragraph"><p>Las tablas <xref linkend="table_4-6" xrefstyle="select: labelnumber"/> y <xref linkend="table_4-7" xrefstyle="select: labelnumber"/> muestran algunos ejemplos de códigos mnemónicos y las semillas que producen.</p></div>
<div class="tableblock" id="table_4-6">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 6. Código mnemónico de entropía de 128 bits y su semilla resultante</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Entropía de entrada (128 bits)</strong></p></td>
<td align="left" valign="top"><p class="table">0c1e24e5917779d297e14d45f14e1a1a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mnemónico (12 palabras)</strong></p></td>
<td align="left" valign="top"><p class="table">army van defense carry jealous true garbage claim echo media make crunch</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Semilla  (512 bits)</strong></p></td>
<td align="left" valign="top"><p class="table">3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88
8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf7</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="table_4-7">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 7. Código mnemónico de entropía de 256 bits y su semilla resultante</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Entropía de entrada (256 bits)</strong></p></td>
<td align="left" valign="top"><p class="table">2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mnemónico (24 palabras)</strong></p></td>
<td align="left" valign="top"><p class="table">cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Semilla (512 bits)</strong></p></td>
<td align="left" valign="top"><p class="table">3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22
fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="hd_wallets">Carteras Determinísticas Jerárquicas (BIP0032/BIP0044)</h4>
<div class="paragraph"><p> Se desarrollaron carteras deterministas para que fuese fácil de obtener muchas claves de una sola "semilla". La forma más avanzada de carteras deterministas es la cartera determinista_ o _HD cartera _ _jeráquica definida por la norma BIP0032. Las carteras deterministas jerárquicas contienen claves derivadas en una estructura de árbol, de tal manera que una clave padre puede derivarse una secuencia de claves de hijas, cada una de las cuales puede derivarse una secuencia de claves nietos, y así sucesivamente, a una profundidad infinita. Esta estructura de árbol se ilustra en &lt; &lt;Type2_wallet&gt; &gt;. </p></div>
<div class="imageblock" id="Type2_wallet">
<div class="content">
<img src="images/msbt_0409.png" alt="HD wallet" />
</div>
<div class="title">Figure 9. Cartera determinística jerárquica de tipo 2: un árbol de claves generadas a partir de una única semilla</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Si estás implementando una cartera bitcoin debería ser construida como una cartera HD siguiendo los estándares BIP0032 y BIP0044.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Las carteras HD ofrecen dos grandes ventajas sobre las claves aleatorias (no deterministas). En primer lugar, la estructura de árbol se puede utilizar para expresar significado organizativo adicional, tal como cuando se utiliza una rama específica de subclaves para recibir los pagos entrantes y una rama diferente se utiliza para recibir el cambio de los pagos salientes. Ramas de claves también se pueden utilizar en un entorno corporativo, la asignación de diferentes ramas a los departamentos, filiales, funciones específicas o categorías de contabilidad.</p></div>
<div class="paragraph"><p>La segunda ventaja de las carteras HD es que los usuarios pueden crear secuencias de claves públicas sin tener acceso a las claves privadas correspondientes. Esto permite a las carteras HD ser usadas en servidores inseguros o en capacidad de receptión de fondos únicamente, generando una clave pública distinta para cada transacción. Las claves públicas no necesitan ser pre-cargadas ni derivadas por adelantado, y aun así el servidor no tiene las claves privadas que permiten gastar los fondos.</p></div>
<div class="sect4">
<h5 id="_creación_de_una_cartera_hd_a_partir_de_una_semilla">Creación de una cartera HD a partir de una semilla</h5>
<div class="paragraph"><p> Las carteras HD se crean a partir de una sola  seed_ <em>root, que es un número aleatorio de 128, 256, o 512 bits. Todo lo demás que se determina en la cartera HD deriva de esta semilla raíz, que hace que sea posible volver a crear toda la cartera HD de esa semilla en cualquier cartera HD compatible. Esto hace que sea fácil de hacer copia de seguridad, restaurar, exportar e importar carteras HD que contienen miles o incluso millones de claves por la simple transferencia solamente la semilla de la raíz. La semilla de la raíz es más a menudo representada por una _secuencia de palabras mnemonicas</em>, como se describe en la sección anterior &lt; &lt;mnemonic_code_words&gt; &gt;, para que sea más fácil para las personas transcribir y almacenar.</p></div>
<div class="paragraph"><p>El proceso de creación de claves maestras y código de cadena maestro para una cartera HD se muestra en <a href="#HDWalletFromSeed">[HDWalletFromSeed]</a>.</p></div>
<div class="imageblock" id="HDWalletFromSeed">
<div class="content">
<img src="images/msbt_0410.png" alt="HDWalletFromRootSeed" />
</div>
<div class="title">Figure 10. Creando claves y códigos de cadena maestros a partir de una semilla raíz</div>
</div>
<div class="paragraph"><p>La semilla de la raíz es introducida en el algoritmo HMAC-SHA512 y el hash resultante se utiliza para crear una <em>Clave privada maestra</em> (m) y una <em>cadena maestra de codigo</em>. La clave privada maestra (m) y genera luego una clave pública maestra correspondiente (M), utilizando el proceso de multiplicación curva elíptica normal + m * G + que vimos anteriormente en este capítulo. El código de cadena se utiliza para introducir la entropía en la función que crea claves secundarias de claves de padres, como veremos en la siguiente sección.</p></div>
</div>
<div class="sect4">
<h5 id="_derivación_de_la_clave_pública_hija">Derivación de la clave pública hija</h5>
<div class="paragraph"><p> Las carteras deterministas jerárquicas utilizan una función <em>Clave de derivación hija</em> (CKD) para derivar claves hijas de claves de padres.</p></div>
<div class="paragraph"><p>Las funciones de derivación de claves hijas se basan en una función de hash de sentido único que combina:</p></div>
<div class="ulist"><ul>
<li>
<p>
Una clave privada o clave pública padre (clave descomprimida ECDSA)
</p>
</li>
<li>
<p>
Una semilla llamada código de cadena (256 bits)
</p>
</li>
<li>
<p>
Un número índice (32 bits)
</p>
</li>
</ul></div>
<div class="paragraph"><p>La cadena de código se utiliza para introducir datos aparentemente aleatorios para el proceso, de modo que el índice no es suficiente para derivar otras claves secundarias. Por lo tanto, tener una llave hija no permitirá encontrar sus hermanos, a menos que usted también tenga la cadena de código. La semilla código de la cadena inicial (en la raíz del árbol) se hace de datos aleatorios, mientras que los códigos de cadena posteriores se derivan de cada código de cadena de los padres.</p></div>
<div class="paragraph"><p>Estos tres elementos son combinados y hasheados para generar claves hijas, como se ve a continuación.</p></div>
<div class="paragraph"><p>La clave pública de los padres, la cadeba de código, y el número de índice se combinan y se hace hash con el algoritmo HMAC-SHA512 para producir una hash de 512 bits. El hash resultante se divide en dos mitades. La mitad derecha de 256 bits de la salida de hash se convirten en el código de cadena para el hijo. Los 256 bits de la mitad izquierda del hash y el número de índice se agregan a la clave privada de los padres para producir la clave privada del hijo. En &lt; &lt;CKDpriv&gt; &gt;, vemos esto ilustrado con el conjunto de índices a 0 para producir el hijo del padre de orden 0 (primero del índice).</p></div>
<div class="imageblock" id="CKDpriv">
<div class="content">
<img src="images/msbt_0411.png" alt="ChildPrivateDerivation" />
</div>
<div class="title">Figure 11. Extendiendo una clave privada padre para crear una clave privada hijo.</div>
</div>
<div class="paragraph"><p>Cambiar el indice nos permite ampliar la matriz y crear los otros hijos en la secuencia, por ejemplo, Niño 0, 1 Niño, Niño 2, etc. Cada clave padre puede tener 2000000000 llaves hijo.</p></div>
<div class="paragraph"><p>Repetir el proceso en un nivel inferior del árbol, cada hijo puede a su vez convertirse en un padre y crear sus propios hijos, en un número infinito de generaciones.</p></div>
</div>
<div class="sect4">
<h5 id="_usando_claves_hijos_derivadas">Usando claves hijos derivadas</h5>
<div class="paragraph"><p> Las claves privadas hijo son indistinguibles de las claves no deterministas (al azar). Debido a que la función de derivación es una función de un solo sentido, la clave hijo no puede ser usada para encontrar la clave principal. La clave hijo tampoco se puede utilizar para encontrar cualquier hermanos. Si usted tiene el n <sub> º </sub> hijo, usted no puede encontrar sus hermanos, como el hijo n-1 o el n+1 hijo, o cualquier otros hijos que forman parte de la secuencia. Sólo la clave principal y el código de cadena pueden derivar todos los hijos. Sin el código de cadena hijo, la clave hijo no puede ser usado para derivar cualquier nietos tampoco. Es necesario tanto la clave privada del hijo y el código de cadena hijo para iniciar una nueva rama y derivar nietos.</p></div>
<div class="paragraph"><p>Entonces, ¿se puede utilizar la clave privada hijo por sí sola? Se puede utilizar para hacer una clave pública y una dirección bitcoin. Entonces, se puede utilizar para firmar transacciones para gastar lo que no se haya pagado a esa dirección.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Una clave privada del hijo, la clave pública correspondiente, y la dirección bitcoin son indistinguibles de las claves y las direcciones creadas aleatoriamente. El hecho de que son parte de una secuencia no es visible, fuera de la función de la cartera HD que los creó. Una vez creadas, funcionan exactamente como claves "normales".</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect4">
<h5 id="_claves_extendidas">Claves extendidas</h5>
<div class="paragraph"><p> Como vimos anteriormente, la función clave de derivación se puede utilizar para crear los hijos en cualquier nivel del árbol, sobre la base de las tres entradas: una clave, una cadena de código, y el índice del hijo deseado. Los dos ingredientes esenciales son el código de la clave y cadena, y se combinan estos son llamados una <em>clave extendida</em>. El término "clave extendida" también podría ser pensado como "clave extensible" porque dicha clave se puede utilizar para crear los hijos.</p></div>
<div class="paragraph"><p>Las claves extendidas se almacenan y se representan simplemente como la concatenación de la clave de 256 bits y la cadena de código de 256 bits en una secuencia de 512 bits. Hay dos tipos de claves extendidas. Una clave privada extendida es la combinación de un código de clave privada y de la cadena y se puede utilizar para derivar las claves privadas de los hijos (y de ellos, las claves públicas hijo). Una clave pública extendida es una clave pública y el código de cadena, que puede ser utilizado para crear las claves públicas del hijo, como se describe en &lt; &lt;public_key_derivation&gt; &gt;.</p></div>
<div class="paragraph"><p>Piense en una clave extendida como el origen de una rama en la estructura de árbol de la cartera HD. Con el origen de la rama, puede derivar el resto de la rama. La clave privada extendida puede crear una rama completa, mientras que la clave pública extendida sólo puede crear una rama de las claves públicas.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Una clave extendida consiste en una clave pública o privada y en una cadena de código. Una clave extendida puede crear hijos, generando su propia rama en la estructura de árbol. Compartir una clave extendida da acceso a toda la rama.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p> Las claves extendidas se codifican utilizando Base58Check, para facilidad de exportación e importación entre los diferentes carteras compatible con BIP0032. La codificación de las claves extendidas Base58Check utiliza un número de versión especial que se traduce en el prefijo "xprv" y "xpub" cuando se codificadan los caracteres en Base58, para que sean fácilmente reconocibles. Dado que la clave extendida puede ser de 512 o 513 bits, es mucho más larga que otras cadenas codificadas Base58Check que hemos visto anteriormente.</p></div>
<div class="paragraph"><p>Aquí hay un ejemplo de una clave privada extendida, codificada en Base58Check:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c</tt></pre>
</div></div>
<div class="paragraph"><p>Aquí está la clave privada extendida correspondiente, también codificada en Base58Check:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="public__child_key_derivation">Derivación de clave pública hija</h5>
<div class="paragraph"><p> Como se mencionó anteriormente, una característica muy útil de las carteras deterministas jerárquicas es la capacidad para derivar claves secundarias públicas de las claves públicas de los padres, <em>sin</em> tener las claves privadas. Esto nos da dos maneras para obtener una clave pública hijo: ya sea desde la clave privada del hijo, o directamente de la clave pública principal.</p></div>
<div class="paragraph"><p>Una clave privada extendida puede ser usada, por tanto, para derivar todas las claves <em>públicas</em> (y solamente las claves públicas) en esa rama de la estructura de la cartera HD.</p></div>
<div class="paragraph"><p> Este acceso directo se pueden utilizar para crear despliegues muy seguros de sólo de clave pública en un servidor o aplicación que tiene una copia de una llave pública extendida y no hay claves privadas de ningún tipo. Ese tipo de despliegue puede producir un número infinito de claves públicas y direcciones bitcoin, pero no se puede gastar el dinero enviado a esas direcciones. Mientras tanto, en otro servidor, más seguro, la clave privada extendida puede derivar todas las claves privadas correspondientes para firmar transacciones y gastar el dinero.</p></div>
<div class="paragraph"><p> Una aplicación común de esta solución es instalar una clave pública extendida en un servidor web que sirve una aplicación de comercio electrónico. El servidor web puede utilizar la función de derivación de clave pública para crear una nueva dirección bitcoin en cada transacción (por ejemplo, para un carrito de la compra del cliente). El servidor web no tendrá ningún claves privadas que serían vulnerables al robo. Sin carteras HD, la única manera de hacer esto seria generar miles de direcciones de Bitcoin en un servidor seguro por separado y luego cargar previamente en el servidor de comercio electrónico. Este enfoque es engorroso y requiere un mantenimiento constante para garantizar que el servidor de comercio electrónico no "agote" las claves.</p></div>
<div class="paragraph"><p> Otra aplicación común de esta solución es el almacenamiento en frío o carteras de hardware. En ese escenario, la clave privada extendida se puede almacenar en una cartera de papel o dispositivo de hardware (tal como un  cartera Trezor de hardware), mientras que la clave pública extendida puede mantenerse en línea. El usuario puede crear "recibir" direcciones a voluntad, mientras que las claves privadas se almacenan fuera de línea segura. Para gastar los fondos, el usuario puede utilizar la clave privada extendida en una firma offline bitcoin cliente o firmar las transacciones en el dispositivo de la cartera de hardware (por ejemplo, Trezor). &lt; &lt;CKDpub&gt; &gt; Ilustra el mecanismo para extender una clave pública principal para derivar claves públicas hijo.</p></div>
<div class="imageblock" id="CKDpub">
<div class="content">
<img src="images/msbt_0412.png" alt="ChildPublicDerivation" />
</div>
<div class="title">Figure 12. Extendiendo una clave pública padre para crear una clave pública hijo</div>
</div>
</div>
<div class="sect4">
<h5 id="_derivación_de_claves_hijo_mas_fuertes">Derivación de claves hijo mas fuertes</h5>
<div class="paragraph"><p> La capacidad de derivar una rama de claves públicas de una clave pública extendida es muy útil, pero viene con un riesgo potencial. El acceso a una clave pública extendida no da acceso a las claves privadas de los hijos. Sin embargo, debido a que la clave pública extendida contiene el código de cadena, si se conoce una clave privada hijo, o de alguna manera se filtró, se puede utilizar con el código de cadena para derivar todas las otras claves privadas hijo. Una única clave privada hijo filtrada, junto con un código de cadena matriz, revela todas las claves privadas de todos los hijos. Peor aún, la clave privada hijo junto con un código de cadena de los padres se puede utilizar para deducir la clave privada de los padres.</p></div>
<div class="paragraph"><p>Para contrarrestar este riesgo, las carteras HD utilizan una función alternativa derivación llamada <em>derivacion más fuerte</em>, que "rompe" la relación entre la clave pública principal y el código de cadena de hijo. La función de derivación endurecida utiliza la clave privada de los padres para derivar el código de cadena hijo, en lugar de la clave pública principal. Esto crea un "firewall" en la secuencia padre / hijo, con un código de cadena que no puede ser utilizado para comprometer un clave privada padres o hermanos. La función de derivación endurecida parece casi idéntico al hijo normal derivado de la clave privada, a excepción de que la clave privada matriz se utiliza como entrada a la función hash, en lugar de la clave pública principal, como se muestra en el diagrama en &lt; &lt;CKDprime&gt; &gt;.</p></div>
<div class="imageblock" id="CKDprime">
<div class="content">
<img src="images/msbt_0413.png" alt="ChildHardPrivateDerivation" />
</div>
<div class="title">Figure 13. Derivación endurecida de una clave hijo; omite la clave pública padre</div>
</div>
<div class="paragraph"><p>Cuando se utiliza la función de derivación privada endurecida, la clave privada hijo resultante y el código de cadena son completamente diferentes de lo que resultaría de la función normal de derivación. La "rama" resultante de las claves puede ser utilizado para producir las claves públicas largas que no son vulnerables, debido a que el código de cadena que contienen no puede ser explotado para revelar las claves privadas. Por lo tanto, la derivación endurecida se utiliza para crear un "espacio" en el árbol por encima del nivel donde se utilizan las claves públicas prolongadas.</p></div>
<div class="paragraph"><p>En términos simples, si usted desea utilizar la conveniencia de una clave pública ampliada para derivar ramas de claves públicas, sin exponerse al riesgo de un código de cadena de filtrado, debe derivarlo de un padre endurecido, en lugar de un padre normal. Como práctica recomendada, las claves maestras de los hijos de nivel 1 siempre deberian obtenerse a través de la derivación endurecida, para evitar el compromiso de las claves maestras.</p></div>
</div>
<div class="sect4">
<h5 id="_números_índice_para_derivación_normal_y_endurecida">Números índice para derivación normal y endurecida</h5>
<div class="paragraph"><p> El número de índice se utiliza en la función de derivación y es un entero de 32 bits. Para distinguir fácilmente entre claves derivadas a través de la función normal de derivación frente a claves derivadas a través de la derivación endurecida, este número de índice se divide en dos rangos.  Los números de índice que se utilizan <em>solo</em> entre 0 y 2 <sup> 31 </sup> -1 (0x0 a 0x7FFFFFFF) para la derivación normal. Números de índice entre 2 <sup> 31 </sup> y 2 <sup> 32 </sup> -1 (0x80000000 a 0xFFFFFFFF) se utilizan <em>solo</em> para la derivación endurecida. Por lo tanto, si el número de índice es menor que 2 <sup> 31 </sup>, eso significa que el hijo es normal, mientras que si el número de índice es igual o superior a 2 <sup> 31 </sup>, el hijo es considerado endurecido.</p></div>
<div class="paragraph"><p>Para que el número de índice sea más fácil de leer y en la pantalla, se muestra el número de índice para los hijos endurecidos a partir de cero, pero con un símbolo primordial. Por tanto, la primera llave normal del niño se muestra como 0, mientras que el primer hijo endurecido (índice 0x80000000) se muestra como sigue: [ &lt;markup&gt; 0 ' &lt;/markup&gt; ]. En la secuencia a continuación, la segunda clave endurecida tendría índice 0x80000001 y se muestra como 1 <em>, y así sucesivamente. Cuando ves un índice en una cartera HD i</em>, significa 2 <sup> 31 </sup> + i.</p></div>
</div>
<div class="sect4">
<h5 id="_identificador_de_clave_de_cartera_hd_ruta">Identificador de clave de cartera HD (ruta)</h5>
<div class="paragraph"><p> Las claves en una billetera HD se identifican mediante un convenio de denominación " ruta ", con cada nivel del árbol separados por una el carácter barra (/) (ver &lt; &lt;table_4-8&gt; &gt;). Las claves privadas derivadas de la clave inicial maestra privada con "m". Las claves públicas derivadas de la clave pública maestra inicial con "M". Por lo tanto, la clave privada del primer hijo de la clave privada maestra es m / 0. La clave pública primer hijo es M / 0. El segundo nieto del primer hijo es m / 0/1, y así sucesivamente.</p></div>
<div class="paragraph"><p>El "parentaje" de una clave se lee de derecha a izquierda, hasta llegar a la clave maestra de la que se deriva. Por ejemplo, el identificador m / x / y / z describe la llave que es el hijo-z de clave m / x / y, lo que es el hijo-y de la clave m / x, que es el hijo-x de m.</p></div>
<div class="tableblock" id="table_4-8">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 8. Ejemplos de rutas de cartera HD</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Ruta HD</p></td>
<td align="left" valign="top"><p class="table">Clave descrita</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m / 0</p></td>
<td align="left" valign="top"><p class="table">El primer (0) hijo clave privada de la clave privada maestra (m)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/0/0</p></td>
<td align="left" valign="top"><p class="table">La clave privada del primer nieto del primer hijo (m / 0)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/0'/0</p></td>
<td align="left" valign="top"><p class="table">El primer nieto normal del primer hijo <em>mas seguro</em> (m/0')</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/1/0</p></td>
<td align="left" valign="top"><p class="table">La clave privada del primer nieto del segundo hijo (m/1)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/23/17/0/0</p></td>
<td align="left" valign="top"><p class="table">La clave pública primera tatara-tatara-nieto del primer bisnieto del nieto 18 del hijo 24</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_navegando_por_la_estructura_de_árbol_de_la_cartera_hd">Navegando por la estructura de árbol de la cartera HD</h5>
<div class="paragraph"><p> La estructura de árbol de la cartera HD ofrece una gran flexibilidad. Cada clave de padres extendida puede tener 4 mil millones de hijos: 2 mil millones de hijos normales y 2 mil millones de hijos endurecidos. Cada uno de estos hijos pueden tener otros 4 mil millones de hijos, y así sucesivamente. El árbol puede ser tan profundo como quieras, con un número infinito de generaciones. Con todo esta flexibilidad, sin embargo, se hace muy difícil de navegar por este árbol infinito. Es especialmente difícil para transferir carteras HD entre implementaciones, debido a las posibilidades de organización interna en ramas principales y secundarias que son infinitas.</p></div>
<div class="paragraph"><p>Dos propuestas de mejora Bitcoin (BIPs) ofrecen una solución a esta complejidad, mediante la creación de algunas de las normas propuestas para la estructura de los árboles de la cartera HD. BIP0043 propone el uso del primer índice hijo endurecido como un identificador especial que significa el "fin" de la estructura de árbol. Basado en BIP0043, una cartera HD debería utilizar sólo una rama del árbol de nivel-1, con el número de índice de la identificación de la estructura y el espacio de nombres del resto del árbol mediante la definición de su propósito. Por ejemplo, una cartera HD utilizando una única rama m/i'/está destinado a significar un fin específico y ese propósito es identificado por el número de índice "i".</p></div>
<div class="paragraph"><p> La extensión de esa especificación, BIP0044  propone una estructura multicuenta cuyo "objetivo" es el número <tt>44'</tt> bajo BIP0043. Todas las carteras HD siguientes la estructura BIP0044 se identifican por el hecho de que sólo utilizan una rama del árbol: m/44'/.</p></div>
<div class="paragraph"><p>BIP0044 especifica que la estructura se basa en cinco niveles predefinidos del árbol:</p></div>
<div class="ulist"><ul>
<li>
<p>
m / propósito' / tipo_moneda <em>/ cuenta</em> / cambio / dirección_indice+
</p>
</li>
</ul></div>
<div class="paragraph"><p> El primer nivel "propósito" está siempre ajustado a <tt>44'</tt>. El segundo nivel "tipo_moneda" especifica el tipo de moneda criptomoneda, permitiendo billeteras HD multidivisa donde cada moneda tiene su propio sub-árbol bajo el segundo nivel. Hay tres monedas definidas por ahora: Bitcoin es m/44'/0', Bitcoin Testnet: [ &lt;markup&gt; m/44'/1' &lt;/markup&gt; ]; y litecoin es: [ &lt;markup&gt; m/44'/2' &lt;/markup&gt; ].</p></div>
<div class="paragraph"><p> El tercer nivel del árbol es "cuenta", que permite a los usuarios que subdividan sus carteras en subcuentas lógicas separadas, para la contabilidad o los propósitos de la organización. Por ejemplo, una billetera HD puede contener dos bitcoin "cuentas": [&lt;markup&gt;m/44'/0'/0'&lt;/markup&gt; ] y: [&lt;markup&gt;m/44'/0'/1'&lt;/markup&gt;]. Cada cuenta es la raíz de su propio subárbol.</p></div>
<div class="paragraph"><p> En el cuarto nivel, "cambio", una cartera HD tiene dos subárboles, uno para la creación de direcciones que reciben y otro para la creación de direcciones de cambio. Tenga en cuenta que mientras que los niveles anteriores utilizaron derivación endurecida, este nivel utiliza derivación normal. Esto se hace para permitir este nivel del árbol pueda exportar las claves públicas extendidas para el uso en un entorno no seguro. Las direcciones utilizables se derivan de la cartera HD como hijos del cuarto nivel, haciendo el quinto nivel del árbol de la "direccion_indice". Por ejemplo, la tercera dirección de recepción para los pagos bitcoin en la cuenta principal sería M/44'/0'/0'/0/2. La &lt; &lt;table_4-9&gt; &gt; muestra algunos ejemplos más.</p></div>
<div class="tableblock" id="table_4-9">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 9. Ejemplos de estructuras de carteras HD BIP0044</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Ruta HD</p></td>
<td align="left" valign="top"><p class="table">Clave descrita</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">M/44'/0'/0'/0/2</p></td>
<td align="left" valign="top"><p class="table">La tercera clave pública es la que recibe para la cuenta bitcoin primaria</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">M/44'/0'/3'/1/14</p></td>
<td align="left" valign="top"><p class="table">La clave pública de laa dirección decimoquinta recibe el cambio de cuarta cuenta bitcoin</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/44'/2'/0'/0/1</p></td>
<td align="left" valign="top"><p class="table">La segunda clave privada en la cuenta principal litecoin, para las transacciones de firma</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_experimentando_con_carteras_hd_usando_bitcoin_explorer">Experimentando con carteras HD usando Bitcoin Explorer</h5>
<div class="paragraph"><p>: </p></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_claves_y_direcciones_avanzadas">Claves y Direcciones Avanzadas</h3>
<div class="paragraph"><p>En las siguientes secciones veremos formas avanzadas de claves y direcciones, tales como claves privadas encriptadas, direcciones de scripts y multifirma, direcciones de vanidad y carteras de papel.</p></div>
<div class="sect3">
<h4 id="_claves_privadas_encriptadas_bip0038">Claves Privadas Encriptadas (BIP0038)</h4>
<div class="paragraph"><p> Las claves privadas deben mantenerse en secreto. La necesidad de <em>confidencialidad</em> de las claves privadas es una perogrullada ya que es muy difícil de lograr en la práctica, porque entra en conflicto con el objetivo de seguridad de igual modo es importante el de <em>disponibilidad</em>.   Mantener en privado la clave privada es mucho más difícil cuando necesita ser almacenada para copias de seguridad de la clave privada para evitar perderlo. Una clave privada almacenada en una cartera que se cifra con una contraseña puede ser segura, pero la cartera debe ser respaldado. En ocasiones, los usuarios necesitan mover las claves de una cartera a otra, para actualizar o reemplazar el software de cartera, por ejemplo. Las copias de seguridad de claves privadas también pueden ser almacenados en papel (ver &lt; &lt;paper_wallets&gt; &gt;) o en medios de almacenamiento externo, como una unidad flash USB. Pero ¿y si la propia copia de seguridad es robada o pérdida? Estos objetivos de seguridad en conflicto llevó a la introducción de una norma portátil y conveniente para el cifrado de claves privadas en una forma que pueda ser entendida por muchos diferentes carteras y clientes bitcoin, estandarizada en Propuesta de Mejora de Bitcoin 38 o BIP0038 (ver &lt; &lt;bip0038&gt; &gt;).</p></div>
<div class="paragraph"><p>BIP0038 propone una norma común para el cifrado de claves privadas con una frase de contraseña y codificación con Base58Check para que puedan ser almacenados de forma segura en los medios de copia de seguridad, transportados de forma segura entre carteras, o mantenidos en otras condiciones donde pueda estar expuesta la clave. El estándar para el cifrado utiliza el  Advanced Encryption Standard (AES), un estándar establecido por el Instituto Nacional de Estándares y Tecnología (NIST) y se utiliza ampliamente en las implementaciones de cifrado de datos comerciales y aplicaciones militares.</p></div>
<div class="paragraph"><p> Un esquema de cifrado BIP0038 toma como entrada una clave privada bitcoin, generalmente codificada en el formato de importación Wallet (WIF), como una cadena Base58Check con un prefijo de "5". Además, el esquema de cifrado BIP0038 toma una frase de paso -contraseña larga- generalmente compuesta de varias palabras o una cadena compleja de caracteres alfanuméricos. El resultado del esquema de cifrado BIP0038 es una clave privada cifrada con codificación Base58Check que comienza con el prefijo <tt>6P</tt>. Si ve una clave que comienza con <tt>6P</tt>, significa que está encriptada y requiere una contraseña para convertir (descifrar) de nuevo en una clave privada con formato WIF (prefijo <tt>5</tt>) que se pueden utilizar en cualquier cartera. Muchas aplicaciones de cartera ahora reconocen las claves privadas cifradas-BIP0038 y se solicitará al usuario una contraseña para descifrar e importar la clave. Las aplicaciones de terceros, como el increíblemente útil <a href="http://bitaddress.org">http://bitaddress.org</a> navegador basado en [Dirección de bitcoin] (Pestaña Detalles de Cartera), se puede utilizar para descifrar claves BIP0038.</p></div>
<div class="paragraph"><p> El caso de uso más común para claves cifradas en BIP0038 es para carteras de papel que se pueden utilizar como copia de seguridad de las claves privadas en un pedazo de papel. Siempre y cuando el usuario seleccione una frase fuerte como contraseña, una billetera de papel con claves privadas encriptada de BIP0038 es increíblemente segura y una gran manera de crear el almacenamiento bitcoin fuera de línea (también conocido como "almacenamiento en frío").</p></div>
<div class="paragraph"><p>Prueba las claves encriptadas en <a href="#table_4-10">[table_4-10]</a> usando bitaddress.org para ver cómo puedes obtener la clave desencriptada ingresando la frase secreta.</p></div>
<div class="tableblock" id="table_4-10">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 10. Ejemplo de una clave privada encriptada BIP0038</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Clave Privda (WIF)</strong></p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Frase secreta</strong></p></td>
<td align="left" valign="top"><p class="table">MyTestPassphrase</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Clave Encriptada (BIP0038)</strong></p></td>
<td align="left" valign="top"><p class="table">6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="p2sh_addresses">Direcciones de Pago-a-Hash-de-Script (P2SH) y Multi-Firma</h4>
<div class="paragraph"><p> Como sabemos, tradicionalmente las direcciones de Bitcoin empiezan con el número "1" y se derivan de la clave pública, que se deriva de la clave privada. Aunque cualquier persona puede enviar a una dirección bitcoin "1", los bitcoin sólo puede ser gastado mediante la presentación de la correspondiente firma de clave privada y hash de clave pública.</p></div>
<div class="paragraph"><p>Las direcciones Bitcoin que empiezan con el número "3" son (P2SH) direcciones pago a Script hash, a veces erróneamente llamadas multi-firma o direcciones multi-sig. Designan al beneficiario de una transacción bitcoin como el hash de un script, en lugar del propietario de una clave pública. La función se introdujo en enero de 2012 como Propuesta de Mejora Bitcoin 16 o BIP0016 (ver &lt; &lt;bip0016&gt; &gt;) y está siendo ampliamente adoptado, ya que proporciona la oportunidad de agregar funcionalidad a la dirección en sí misma. A diferencia de las transacciones que "envían" fondos para la dirección tradicional "1" bitcoin, también conocidas como   pagan a Public-Key-Hash (P2PKH), los fondos enviados a las direcciones de "3" requiere algo más que la presentación de un hash de clave pública y una clave privada de firma como prueba de propiedad. Los requisitos son designados en el momento en que se crea la dirección, dentro del guión, y todas las entradas a esta dirección serán gravadas con los mismos requisitos.</p></div>
<div class="paragraph"><p>Una dirección de hash pay-to-script se crea a partir de un script de transacción, que define quién puede pasar una salida de transacción (para más detalles, consulte <a href="#p2sh">[p2sh]</a>). La codificación de una dirección de pay-to-script a la implica el uso de la misma función doble de hash usada durante la creación de una dirección bitcoin, sólo se aplica en el script en lugar de la clave pública:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>hash de script = RIPEMD160(SHA256(script))</tt></pre>
</div></div>
<div class="paragraph"><p> El resultado del "script de hash" está codificado con Base58Check con una versión de prefijo 5, lo que resulta en una dirección codificada comenzando con un <tt>3</tt>. Un ejemplo de una dirección P2SH es <tt>3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</tt>, que se puede derivar mediante los comandos del Explorador de Bitcoin    + sha256 +,  + RIPEMD160 + y  ((("comando base58check a codificar (bx)")) ) + base58check a codificar + (ver <a href="#libbitcoin">[libbitcoin]</a>) como sigue:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ echo dup hash160 [ 89abcdefabbaabbaabbaabbaabbaabbaabbaabba ] equalverify checksig &gt; script
$ bx script-encode &lt; script | bx sha256 | bx ripemd160 | bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>P2SH no es necesariamente igual que una transacción multi-firma estándar. Una dirección P2SH representa un script multi-firma <em>más frecuente</em>, pero podría representar un script codificando otros tipos de transacciones.</p></div>
</td>
</tr></table>
</div>
<div class="sect4">
<h5 id="_direcciones_multi_firma_y_p2sh">Direcciones multi-firma y P2SH</h5>
<div class="paragraph"><p>Actualmente, la aplicación más común de la función P2SH es el script dirección multi-firma. Como su nombre lo indica, el guión subyacente requiere más de una firma para demostrar la propiedad y por lo tanto gastar fondos. La característica multi-firma bitcoin está diseñada para requerir M firmas (también conocido como el "umbral") de un total de N claves, conocido como un multi-sig M-de-N, donde M es igual o inferior a N. Por ejemplo, Bob, el dueño de la tienda de café del <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a> podría utilizar una dirección de varias firmas que requiere 1-de-2 firmas de una llave de su propiedad y una llave perteneciente a su cónyuge, lo que garantiza ninguno de los dos solo podría firmar para realizar una transacción de salida cerrada a esta dirección. Esto sería similar a una "cuenta conjunta" tal como se aplica en la banca tradicional, donde cualquiera de los cónyuges puede transferir con una sola firma. O Gopesh, el diseñador web de pago por Bob para crear un sitio web, podría tener una dirección de múltiples firma 2-of-3 para su negocio que garantice que no se pueden gastar los fondos a menos que al menos dos de los socios de negocios firmen una transacción.</p></div>
<div class="paragraph"><p>Exploraremos cómo crear transacciones que gastan fondos de direcciones P2SH (y multi-firma) en <a href="#transactions">[transactions]</a>.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_direcciones_de_vanidad">Direcciones de Vanidad</h4>
<div class="paragraph"><p> Las direcciones de Vanidad son direcciones Bitcoin válidas que contienen mensajes legibles. Por ejemplo, <tt>1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33</tt> es una dirección válida que contiene las letras que forman la palabra "Love" con las primeras cuatro letras en Base-58. Las direcciones de Vanidad requieren generar y comprobar miles de millones de claves privadas candidatas, hasta que uno se deriva una dirección bitcoin con el patrón deseado. Aunque hay algunas optimizaciones en el algoritmo de generación de la vanidad, el proceso implica esencialmente que escoge una clave privada al azar, derivando la clave pública, derivando la dirección bitcoin, y la comprobación para ver si coincide con el patrón de vanidad deseado, repitiendo miles de millones de veces hasta  encuentrar una coincidencia.</p></div>
<div class="paragraph"><p>Una vez que se encuentra una dirección de Vanidad que coincida con el patrón deseado, la clave privada de la que se deriva puede ser utilizada por el propietario para pasar bitcoins exactamente de la misma manera que cualquier otra dirección. Las direcciones de Vanidad no son menos o más segura que cualquier otra dirección. Dependen de la misma criptografía de curva elíptica (ECC) y Secure Hash Algorithm (SHA) como cualquier otra dirección. Puede encontrar más fácilmente la clave privada de una dirección a partir de un patrón de la vanidad de lo que puede cualquier otra dirección.</p></div>
<div class="paragraph"><p>En <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a>, introdujimos a Eugenia, directora de caridad para niños que funciona en las Filipinas. Digamos que Eugenia está organizando una unidad de recaudación de fondos bitcoin y quiere utilizar un bitcoin dirección bitcoin de Vanidad para dar a conocer la recaudación de fondos. Eugenia creará una dirección de vanidad que comienza por "1Kids" para recaudar fondos para promover la caridad de los niños. Vamos a ver cómo esta dirección de Vanidad es creada y lo que significa para la seguridad de la caridad de Eugenia.</p></div>
<div class="sect4">
<h5 id="_generando_direcciones_de_vanidad">Generando direcciones de vanidad</h5>
<div class="paragraph"><p> Es importante tener en cuenta que una dirección bitcoin es simplemente un número representado por símbolos en el alfabeto Base58. La búsqueda de un patrón como "1Kids" puede ser visto como la búsqueda de una dirección en el rango de <tt>1Kids11111111111111111111111111111</tt> a <tt>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</tt>. Hay aproximadamente 58 <sup> 29 </sup> (aproximadamente 1,4 * 10 <sup> 51 </sup>) direcciones en ese rango, comenzando por "1Kids". La <a href="#table_4-11">[table_4-11]</a> muestra el rango de direcciones que tienen el prefijo 1Kids.</p></div>
<div class="tableblock" id="table_4-11">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 11. El rango de direcciones de vanidad comenzando con "1Kids"</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Desde</strong></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kids11111111111111111111111111111</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kids11111111111111111111111111112</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kids11111111111111111111111111113</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><tt>&#8230;</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Hasta</strong></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</tt></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Veamos el patrón "1Kids" como un número y la frecuencia con la que podríamos encontrar este patrón en una dirección bitcoin (ver <a href="#table_4-12">[table_4-12]</a>). De promedio un PC ordenador de sobremesa, sin ningún hardware especializado, puede buscar aproximadamente 100.000 claves por segundo.</p></div>
<div class="tableblock" id="table_4-12">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 12. La frecuencia del patrón de vanidad (1KidsCharity) y el tiempo de búsqueda promedio en una PC de escritorio</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Longitud</p></td>
<td align="left" valign="top"><p class="table">Patrón</p></td>
<td align="left" valign="top"><p class="table">Frecuencia</p></td>
<td align="left" valign="top"><p class="table">Tiempo de búsqueda promedio</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table">1K</p></td>
<td align="left" valign="top"><p class="table">1 en 58 claves</p></td>
<td align="left" valign="top"><p class="table">&lt; 1 milisegundos</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table">1Ki</p></td>
<td align="left" valign="top"><p class="table">1 en 3.364</p></td>
<td align="left" valign="top"><p class="table">50 milisegundos</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table">1Kid</p></td>
<td align="left" valign="top"><p class="table">1 en 195.000</p></td>
<td align="left" valign="top"><p class="table">&lt; 2 segundos</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table">1Kids</p></td>
<td align="left" valign="top"><p class="table">1 en 11 millones</p></td>
<td align="left" valign="top"><p class="table">1 minuto</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">1KidsC</p></td>
<td align="left" valign="top"><p class="table">1 en 656 milliones</p></td>
<td align="left" valign="top"><p class="table">1 hora</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">6</p></td>
<td align="left" valign="top"><p class="table">1KidsCh</p></td>
<td align="left" valign="top"><p class="table">1 en 38 mil millones</p></td>
<td align="left" valign="top"><p class="table">2 días</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">7</p></td>
<td align="left" valign="top"><p class="table">1KidsCha</p></td>
<td align="left" valign="top"><p class="table">1 en 2.2 billones</p></td>
<td align="left" valign="top"><p class="table">3–4 meses</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">8</p></td>
<td align="left" valign="top"><p class="table">1KidsChar</p></td>
<td align="left" valign="top"><p class="table">1 en 128 billones</p></td>
<td align="left" valign="top"><p class="table">13–18 años</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">9</p></td>
<td align="left" valign="top"><p class="table">1KidsChari</p></td>
<td align="left" valign="top"><p class="table">1 en 7 mil billones</p></td>
<td align="left" valign="top"><p class="table">800 años</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">10</p></td>
<td align="left" valign="top"><p class="table">1KidsCharit</p></td>
<td align="left" valign="top"><p class="table">1 en 400 mil billones</p></td>
<td align="left" valign="top"><p class="table">46.000 años</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">11</p></td>
<td align="left" valign="top"><p class="table">1KidsCharity</p></td>
<td align="left" valign="top"><p class="table">1 en 23 trillones</p></td>
<td align="left" valign="top"><p class="table">2,5 millones de años</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Como se puede ver, Eugenia no podrá crear la dirección de vanidad "1KidsCharity" en el corto plazo, incluso si ella tuviese acceso a varios miles de ordenadores. Cada caracter adicional aumenta la dificultad en un factor de 58. Los patrones con más de siete caracteres se encuentran generalmente por el hardware especializado, tales como escritorios hechos a medida con múltiples  unidades de procesamiento de gráficos (GPU). Estos son a menudo reutilizados por "plataformas" bitcoin mineras que ya no son rentables para la minería bitcoin, pero se pueden utilizar para encontrar las direcciones de vanidad. Las búsquedas de Vanity sobre los sistemas de GPU son mucho más rápidos en el órden de magnitud que en una CPU de propósito general.</p></div>
<div class="paragraph"><p> Otra manera de encontrar una dirección de la vanidad es la de subcontratar el trabajo a un grupo de mineros de vanidad, como en el pool <a href="http://vanitypool.appspot.com">http://vanitypool.appspot.com</a> [Vanity pool]. Un pool es un servicio que permite a las personas con el hardware de GPU ganar bitcoin buscando direcciones de vanidad para los demás. Por un pequeño pago (0,01 bitcoin o aproximadamente $5 en el momento de escribir esto), Eugenia puede externalizar la búsqueda de una dirección de patrón de vanidad de siete caracteres y obtener resultados en un par de horas en lugar de tener que realizar una búsqueda de CPU durante meses.</p></div>
<div class="paragraph"><p>Generar una dirección de vanidad es un ejercicio de fuerza bruta: probar una clave aleatoria, compruebar la dirección resultante para ver si coincide con el patrón deseado, repetir hasta que tenga éxito. <a href="#vanity_miner_code">[vanity_miner_code]</a> muestra un ejemplo de un "minero de vanidad", un programa diseñado para encontrar direcciones de vanidad, escrito en C ++. El ejemplo se utiliza el  libbitcoin biblioteca, que se introdujo en <a href="#alt_libraries">[alt_libraries]</a>.</p></div>
<div class="exampleblock" id="vanity_miner_code">
<div class="title">Example 8. Minero de direcciones de vanidad</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>El ejemplo anterior usa <tt>std::random_device</tt>. Dependiendo de la implementación puede reflejar un generador de números aleatorios criptográficamente seguro (CSRNG) proporcionado por el sistema operativo subyacente. En el caso del sistema operativo UNIX como Linux, se nutre de <tt>/dev/urandom</tt>. Mientras que el generador de números aleatorios utilizado aquí es para fines de demostración, <em>no</em> es apropiado para generar claves Bitcoin de calidad de producción, ya que no se implementa con la suficiente seguridad.</p></div>
</div></div>
<div class="paragraph"><p>El código de ejemplo debe ser compilado usando un compilador de C <tt> y vinculado con la biblioteca libbitcoin (que debe ser instalado por primera vez en ese sistema). Para ejecutar el ejemplo, lanze el ejecutable</tt>vanity-miner++ sin parámetros (ver <a href="#vanity_miner_run">[vanity_miner_run]</a>) e intentará encontrar una dirección de vanidad que empiezan por "1kid".</p></div>
<div class="exampleblock" id="vanity_miner_run">
<div class="title">Example 9. Compilando y ejecutando el ejemplo de vanity-miner</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>El código de ejemplo tardará unos segundos para encontrar una coincidencia para el patrón de tres caracteres "kid", como podemos ver cuando usamos el comando <tt>time</tt> de Unix para medir el tiempo de ejecución. Cambiar la búsqueda +search + de patrón en el código fuente y ver cuánto tiempo le toma a los patrones de cuatro o cinco caracteres! </p></div>
</div>
<div class="sect4">
<h5 id="_seguridad_de_direcciones_de_vanidad">Seguridad de direcciones de vanidad</h5>
<div class="paragraph"><p> Las direcciones de Vanity pueden utilizarse para mejorar <em>y</em> para vencer a las medidas de seguridad; son realmente un arma de doble filo. Se utiliza para mejorar la seguridad, una dirección distintiva hace que sea más difícil para los adversarios para sustituir su propia dirección y engañan a sus clientes para que paguen a ellos en lugar de a usted. Desafortunadamente, las direcciones de vanidad también hacen posible que cualquier persona pueda crear una dirección que <em>se asemeje</em> a cualquier dirección de azar, o incluso otra dirección de vanidad, engañando de esta manera a sus clientes.</p></div>
<div class="paragraph"><p>Eugenia podría publicitar una dirección generada aleatoriamente (por ejemplo, <tt>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</tt>) a la cual la gente podría enviar sus donaciones. O podría generar una dirección de vanidad comenzada en 1Kids para hacerla más distintiva.</p></div>
<div class="paragraph"><p>En ambos casos, uno de los riesgos del uso de una dirección fija única (en lugar de una dirección dinámica separada por donante) es que un ladrón podría ser capaz de infiltrarse en su sitio web y reemplazarla con su propia dirección, desviando así las donaciones a sí mismo. Si ha anunciado su dirección de donación en un número de diferentes lugares, los usuarios pueden inspeccionar visualmente la dirección antes de hacer un pago para asegurarse de que es el mismo que vieron en su sitio web, en su correo electrónico, y en su propaganda. En el caso de una dirección aleatoria como <tt>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</tt>, el usuario medio querrá quizá inspeccionar los primeros caracteres "1J7mdg" y estar convencido de que la dirección coinde. El uso de un generador de direcciones de vanidad, una persona con la intención de robar mediante la sustitución de una dirección de aspecto similar puede generar rápidamente las direcciones que coinciden con los primeros caracteres, como se muestra en &lt; &lt;table_4-13&gt; &gt;.</p></div>
<div class="tableblock" id="table_4-13">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 13. Generando direcciones de vanidad para coincidir con una dirección aleatoria</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Dirección Aleatoria Original</strong></p></td>
<td align="left" valign="top"><p class="table">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Vanidad (coincidencia de 4 carácteres)</strong></p></td>
<td align="left" valign="top"><p class="table">1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Vanidad (coincidencia de 5 carácteres)</strong></p></td>
<td align="left" valign="top"><p class="table">1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Vanidad (coincidencia de 6 carácteres)</strong></p></td>
<td align="left" valign="top"><p class="table">1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Entonces, ¿una dirección de vanidad aumentar la seguridad? Si Eugenia genera la dirección de la vanidad <tt>1Kids33q44erFfpeXrmDSz7zEqG2FesZEN</tt>, los usuarios tienden a mirar a la palabra patrón vanidad <em>y algunos caracters adjuntos</em>, por ejemplo notando la parte "1Kids33" de la dirección. Eso obligaría a un atacante a generar una dirección de vanidad de al menos seis caracteres (dos más), gastando un esfuerzo que es 3364 veces (58 × 58) más alto que el Eugenia gastó para su vanidad de cuatro caracteres. En esencia, el esfuerzo que Eugenia gastó (o pagó a un pool vanidad) "empuja" al atacante a tener que producir un patrón de vanidad de más tiempo. Si Eugenia paga un pool para generar una dirección de la vanidad de 8 caracteres, el atacante podría ser empujado en el buscar una de 10 caracteres, que es inviable en un ordenador personal y caro incluso con un equipo de vanidad de minado de costumbre o una pool de vanidad. Lo que es asequible para Eugenia se convierte en inaccesible para el atacante, especialmente si la recompensa potencial de fraude no es lo suficientemente alto para cubrir el costo de la generación de direcciones vanidad. .</p></div>
</div>
</div>
<div class="sect3">
<h4 id="paper_wallets">Carteras de Papel</h4>
<div class="paragraph"><p> Las carteras de papel son claves privadas de bitcoin impresas en papel. A menudo, la cartera de papel también incluye la dirección bitcoin correspondiente por conveniencia, pero esto no es necesario, ya que puede ser derivada de la clave privada. Las carteras de papel son una forma muy efectiva para crear copias de seguridad o almacenamiento sin conexión bitcoin, también conocido como "el almacenamiento en frío." Como un mecanismo de copia de seguridad, una billetera de papel puede proporcionar seguridad contra la pérdida de la llave debido a un percance informático como un fallo de disco duro, robo o eliminación accidental. Como un mecanismo de "almacenamiento en frío", si las claves cartera de papel se generan fuera de línea y no almacenada en un sistema informático, que son mucho más seguros contra hackers, keyloggers y otras amenazas informáticas en línea.</p></div>
<div class="paragraph"><p>Las carteras de papel vienen en muchas formas, tamaños y diseños, pero a un nivel muy básico son simplemente una clave y una dirección impresas en papel. <a href="#table_4-14">[table_4-14]</a> muestra la forma más sencilla de una cartera de papel.</p></div>
<div class="tableblock" id="table_4-14">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 14. La forma más simple de una cartera de papel—una impresión de la dirección bitcoin y clave privada.</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Dirección Pública</p></td>
<td align="left" valign="top"><p class="table">Clave Privada (WIF)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p> Las carteras de papel se pueden generar fácilmente utilizando una herramienta web JavaScript en <em>bitaddress.org</em>. Esta página contiene todo el código necesario para generar claves y carteras de papel, incluso completamente desconectado de Internet. Para usarlo, guarde la página HTML en la unidad local o en una unidad flash USB externo. Desconectarse de Internet y abra el archivo en un navegador. Aún mejor, arrancar el ordenador utilizando un sistema operativo original, tal como un CD-ROM de arranque del sistema operativo Linux. Cualquier clave generada con esta herramienta sin conexión se puede imprimir en una impresora local mediante un cable USB (no inalámbrica), creando así carteras de papel cuyas claves sólo existen en el papel y nunca han sido almacenados en ningún sistema en línea. Ponga estas carteras de papel en una caja fuerte a prueba de fuego y "envie" bitcoins a su dirección bitcoin, para implementar una solución sencilla pero muy eficaz de "almacenamiento en frío". <a href="#paper_wallet_simple">[paper_wallet_simple]</a> Muestra una billetera de papel generado desde el sitio bitaddress.org.</p></div>
<div class="imageblock" id="paper_wallet_simple">
<div class="content">
<img src="images/msbt_0414.png" alt="images/msbt_0414.png" />
</div>
<div class="title">Figure 14. Un ejemplo de una cartera de papel simple de bitaddress.org</div>
</div>
<div class="paragraph"><p>La desventaja del sistema de monedero papel simple es que las claves impresas son vulnerables al robo. Un ladrón que es capaz de tener acceso al papel puede robar o fotografiar las claves y tomar el control de los bitcoins bloqueados con dichas claves. Un sistema de almacenamiento de la cartera de papel más sofisticado se utiliza en BIP0038 encriptadando claves privadas. Las claves impresas en la cartera de papel están protegidos por una contraseña que el propietario ha memorizado. Sin la contraseña, las claves cifradas son inútiles. Sin embargo, todavía son superiores a una cartera con una frase de contraseña-protegida porque las claves nunca han estado en línea y deben ser recuperadas físicamente de un almacenamiento protegido físicamente seguro u otro. <a href="#paper_wallet_encrypted">[paper_wallet_encrypted]</a> muestra una carpeta de papel con una clave privada encriptada (BIP0038) creado en el sitio bitaddress.org.</p></div>
<div class="imageblock" id="paper_wallet_encrypted">
<div class="content">
<img src="images/msbt_0415.png" alt="images/msbt_0415.png" />
</div>
<div class="title">Figure 15. Un ejemplo de una cartera de papel encriptada de bitaddress.org. La frase secreta es "test."</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p> Aunque se puede depositar fondos en una billetera de papel varias veces, se deben retirar todos los fondos una sola vez , gastando todo. Esto se debe a que en el proceso de desbloqueo de los fondos y de gasto algunas carteras podrían generar una dirección de cambio si vas a gastar menos de la totalidad del importe. Además, si el equipo que se utiliza para firmar la transacción se ve comprometida, corre el riesgo de exponer la clave privada. Al pasar la totalidad del saldo de una cartera de papel sólo una vez, se reduce el riesgo de compromiso clave. Si necesita sólo una pequeña cantidad, envíe los fondos restantes a una nueva cartera de papel en la misma transacción.</p></div>
</div></div>
<div class="paragraph"><p>Las carteras de papel vienen en muchos diseños y tamaños, con muchas características diferentes. Algunos están destinados a ser dado como regalos y tienen temas estacionales, como la Navidad y temas de año nuevo. Otros están diseñados para el almacenamiento en una bóveda bancaria o más seguro con la clave privada oculta de alguna manera, ya sea con opacos, pegatinas, raspaditos o plegados y sellados con una lámina adhesiva a prueba de manipulaciones. Figuras: [ &lt;xref linkend="paper_wallet_bpw" xrefstyle="select: labelnumber"/&gt; ] A través de pase: [ &lt;xref linkend="paper_wallet_spw" xrefstyle="select: labelnumber"/&gt; ] muestran varios ejemplos de carteras de papel con características de seguridad y de copia de seguridad.</p></div>
<div class="imageblock" id="paper_wallet_bpw">
<div class="content">
<img src="images/msbt_0416.png" alt="images/msbt_0416.png" />
</div>
<div class="title">Figure 16. Un ejemplo de una cartera de papel de bitcoinpaperwallet.com con la clave privada en una solapa plegable.</div>
</div>
<div class="imageblock" id="paper_wallet_bpw_folded">
<div class="content">
<img src="images/msbt_0417.png" alt="images/msbt_0417.png" />
</div>
<div class="title">Figure 17. La cartera de papel de bitcoinpaperwallet.com con la clave privada oculta.</div>
</div>
<div class="paragraph"><p>Otros diseños cuentan con copias adicionales de la llave y la dirección, en forma de fichas separables similares a talones de boletos, lo que le permite almacenar múltiples copias de protección contra incendios, inundaciones u otros desastres naturales.    </p></div>
<div class="imageblock" id="paper_wallet_spw">
<div class="content">
<img src="images/msbt_0418.png" alt="images/msbt_0418.png" />
</div>
<div class="title">Figure 18. Un ejemplo de una cartera de papel con copias adicionales de las claves en un "talón" de respaldo.</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-07-15 16:56:53 UTC
</div>
</div>
</body>
</html>
