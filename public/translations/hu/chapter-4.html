<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.7" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="ch04_keys_addresses_wallets">Kulcsok, címek, pénztárcák</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_bevezetés">Bevezetés</h3>
<div class="paragraph"><p>A bitcoinban a tulajdonjogot a <em>digitális kulcsok</em>, a <em>bitcoin címek</em> és a <em>digitális aláírások</em> teremtik meg. A digitális kulcsokat nem a hálózat tárolja, hanem a végfelhasználók hozzák létre és tárolják őket – vagy egy állományban vagy egy egyszerű adatbázisban, melynek <em>pénztárca</em> a neve. A felhasználó pénztárcájában lévő digitális kulcsok teljesen függetlenek a bitcoin protokolltól, a kulcsok a felhasználó pénztárca szoftverével a blokkláncra történő hivatkozás vagy Internet hozzáférés nélkül állíthatók elő és kezelhetők. A kulcsok valósítják meg a bitcoin sok érdekes tulajdonságát, többek között a decentralizált bizalmat és felügyeletet, a tulajdonjog igazolását és a kriptográfiailag helyes biztonsági modellt.</p></div>
<div class="paragraph"><p>Minden egyes bitcoin tranzakciónak érvényes aláírással kell rendelkeznie, csak ekkor lesz befoglalva a blokkláncba. Az aláírások viszont csak érvényes digitális kulcsokkal állírhatók elő, ezért ha valaki rendelkezik ezekkel a kulcsokkal, akkor rendelkezik a számlán lévő bitcoinokkal is. A kulcsok párokból állnak, az egyik a titkos (privát) kulcs, a másik a nyilvános kulcs. A nyilvános kulcsra gondoljanak úgy, mint egy bankszámla számra, a titkos kulcsra pedig úgy, mint egy titkos PIN kódra, vagy egy csekken lévő álaírásra, amely megteremti a számla feletti felügyeletet. Ezeket a digitális kulcsokat a bitcoin felhasználók ritkán látják. Többnyire a pénztárca állományban vannak tárolva, és a pénztárca szoftver kezeli őket.</p></div>
<div class="paragraph"><p>A bitcoin tranzakciók kifizetésekhez tartozó részében a címzett nyilvános kulcsát egy  <em>bitcoin címnek</em> nevezett digitális ujjlenyomat képviseli, amelynek ugyanaz a szerepe, mint egy csekken a kedvezményezett nevének. A legtöbb esetben a bitcoin cím egy nyilvános kulcsból jön létre, és megfelel a nyilvános kulcsnak. De nem minden bitcoin cím felel meg egy nyilvános kulcsnak, a címek más kedvezményezetteket, pl. scripteket is képviselhetnek, amint azt a fejezet későbbi részében látni fogjuk. Ily módon a bitcoin címek a pénzösszeg címzettjeit személyesítik meg, és a papír alapú csekkekhez hasonlóan a tranzakciókat rugalmassá teszik: ugyanaz a fizetési eszköz használható magánszemélyek vagy cégek számláinál, be- vagy kifizetésre. A bitcoin cím a kulcsok egyetlen olyan megjelenési formája, amivel a felhasználók rendszeresen találkoznak, mivel ezt kell megosztaniuk a nagyvilággal.</p></div>
<div class="paragraph"><p>Ebben a fejezetben a kulcsokkal és az őket tartalmazó pénztárcákkal ismerkedünk meg. Megvizsgáljuk, hogyan történik a kulcsok létrehozása, tárolása és kezelése. Áttekintjük a különféle kódolási formátumokat, melyek a titkos és nyilvános kulcsok, címke és script címek ábrázolására szolgálnak. Végül a kulcsok különleges felhasználásait tekintjük át, melyek a következők: üzenetek aláírása, a tulajdonjog bizonyítása, kérkedő címek (vanity address) és papír alapú pénztárcák létrehozása.</p></div>
<div class="sect3">
<h4 id="_a_nyilvános_kulcsú_titkosítás_és_a_digitális_pénz">A nyilvános kulcsú titkosítás és a digitális pénz</h4>
<div class="paragraph"><p>A nyilvános kulcsú titkosítást az 1970-es években fedezték fel. A  számítógép- és információbiztonság matematikai alapjait a nyilvános kulcsú titkosítás képzi.</p></div>
<div class="paragraph"><p>A nyilvános kulcsú titkosítás felfedezése óta számos, e célra alkalmas matematikai függvényt fedeztek föl, pl. a prímszámok hatványozását vagy az elliptikus görbéken történő szorzást. Ezek a matematikai fügvények gyakorlatilag megfordíthatatlanok, ami azt jelenti, hogy könnyű őket az egyik irányban kiszámítani, de ez a másik irányban gyakorlatilag lehetetlen. A titkosítás ezekre a matematikai függvényekre épül, és lehetővé teszi a digitális titkok és a nem hamisítható digitális aláírások létrehozását. A bitcoin elliptikus görbén történő szorzást használ a nyilvános kulcsú titkosításra.</p></div>
<div class="paragraph"><p>A bitcoinnál nyilvános kulcsú titkosítást használunk egy olyan kulcspár létrehozására, amely a bitcoinokhoz történő hozzzáférést szabályozza. A kulcspár egy titkos kulcsból és a belőle származó egyedi nyilvános kulcsból áll. A nyilvános kulcs szolgál a bitcoinok fogadására, a titkos kulcs szolgál a tranzakciók aláírására és a bitcoinok elköltésére.</p></div>
<div class="paragraph"><p>A nyilvános és titkos kulcs között van egy matematikai összefüggés, ami lehetővé teszi, hogy a titkos kulcsokkal üzenetek aláírását állítsuk elő. Ez az aláírás a nyilvános kulccsal úgy ellenőrizhető, hogy közben nincs szükség a titkos kulcs felfedésére.</p></div>
<div class="paragraph"><p>Ha egy bitcoin tulajdonos el akarja költeni a bitcoinjait, akkor egy tranzakcióban bemutatja a nyilvános kulcsát és egy aláírást (ami minden egyes alkalommal különböző, de ugyanabból a titkos kulcsból áll elő). A nyilvános kulcs és az aláírás révén a bitcoin hálózat bármelyik tagja ellenőrizni tudja a tranzakciót, meg tudja állípítani, hogy érvényes-e, és meg tud bizonyosodni arról, hogy a bitcoinokat küldő személy valóban birtokolta-e őket a küldés idején.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A legtöbb megvalósítás a titkos és nyilvános kulcsokat az egyszerűség kedvéért együtt, egy <em>kulcspárként</em> tárolja. Mivel a nyilvános kulcs előállítása a titkos kulcs ismeretében triviális feladat, ezért az is előfordulhat, hogy a pénztárcában csupán a titkos kulcs van tárolva.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="private_public_keys">Titkos és nyilvános kulcsok</h4>
<div class="paragraph"><p>A bitcoin pénztárca kulcspárok halmazát tartalmazza. Mindegyik kulcspár egy titkos és egy nyilvános kulcsból áll. A (k) titkos kulcs egy szám, melyet általában véletlenszerűen választanak. A titkos kulcsból elliptikus görbén történő szorzással, ami egy egyirányú titkosító függgvény, egy (K) nyilvános kulcsot állítunk elő. A (K) nyilvános kulcsból egy egyirányú titkosító hash függvénnyel egy (A) bitcoin címet állítunk elő. Ebben a részben először egy titkos kulcsot fogunk előállítani, majd megnézzük, hogy az elliptikus görbén milyen matematikai műveletekkel lehet a titkos kulcsot nyilvános kulccsá átalakítani, és végül a nyilvános kulcsból egy bitcoin címet állítunk elő. A titkos kulcs, nyilvános kulcs és bitcoin cím közötti összefüggést az alábbi ábra mutatja: <a href="#k_to_K_to_A">[k_to_K_to_A]</a></p></div>
<div class="imageblock" id="k_to_K_to_A">
<div class="content">
<img src="images/msbt_0401.png" alt="privk_to_pubK_to_addressA" />
</div>
<div class="title">Figure 1. Titkos kulcs, nyilvános kulcs és bitcoin cím</div>
</div>
</div>
<div class="sect3">
<h4 id="private_keys">Titkos kulcsok</h4>
<div class="paragraph"><p>A titkos kulcs egyszerűen egy véletlenszerűen választott szám. A titkos kulcs birtoklása az alapja annak, hogy a felhasználó rendelkezést legyen képes gyakorolni az összes pénz fölött, amely a titkos kulcsnak megfelelő bitcoin címhez tartozik. A titkos kulcs szolgál aláírások létrehozására. Az aláírás azt a célt szolgálja, hogy a felhasználó bizonyítani tudja a tranzakcióban szereplő összegek tulajdonjogát, mielőtt elkölti őket. A titkos kulcsnak egész idő alatt titokban kell maradnia, mert felfedése egy harmadik fél számára azzal lenne egyenértékű, mint ha hozzáférést adnánk neki azokhoz a bitcoinokhoz, melyeket ez a kulcs biztosít. A titkos kulcsról biztonsági másolatot kell készíteni, és védeni kell, nehogy véletlenül elveszítsük, mert ha elvész, akkor nem tudjuk semmi másból visszaállítani, és az általa biztosított összegek is örökre elvesznek.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A bitcoin titkos kulcs csupán egy szám. A titkos kulcs véletlenszerűen, pl. egy kockával, egy darab papírral és ceruzával is előállítható. Dobjunk fel egy pénzérmét 256-szor, és írjuk le a dobások eredményét egy bináris szám formájában. A nyilvános kulcs ezt követően a titkos kulcsból állítható elő.</p></div>
</td>
</tr></table>
</div>
<div class="sect4">
<h5 id="_a_titkos_kulcs_előállítása_egy_véletlen_számból">A titkos kulcs előállítása egy véletlen számból</h5>
<div class="paragraph"><p>A kulcsok előállításának első és legfontosabb lépése, hogy egy biztonságos entrópiaforrást, másképpen véletlenszerű forrást találjunk. Egy bitcoin kulcs előállítása lényegében egyenértékű azzal, hogy „Válasszunk egy számot 1 és 2<sup>256</sup> között”. Hogy pontosan hogyan választjuk ezt a számot, az nem számít, feltéve, hogy a választás nem megjósolható vagy nem megismételhető. A bitcoin szoftver a mögöttes operációs rendszer véletlenszám generátorát használja 256 bit entrópia (véletlenszerűség) előállítására. Az OS véletlenszám generátorát általában egy emberi eredetű entrópiaforrással inicializálják, ezért van szükség pl. arra, hogy mozgassuk az egeret néhány másodpercig. Az igazán paranoiások számára a dobókockánál, a papírnál és a ceruzánál nincs jobb módszer.</p></div>
<div class="paragraph"><p>Pontosabban, a titkos kulcs egy <tt>1</tt> és <tt>n - 1</tt> közötti tetszőleges szám lehet, ahol n konstans (n=1.158 * 10<sup>77</sup>, vagyis egy kicsit kevesebb, mint 2<sup>256</sup>), és a bitcoinnál használt elliptikus görbe rendszámával egyenlő (lásd az <a href="#elliptic_curve">[elliptic_curve]</a> részt). Egy ilyen kulcs előállításához véletlenszerűen válasszunk egy 256 bites számot, és ellenőrizzük, hogy kisebb-e <tt>n - 1</tt>-nél. Programozási szempontból ezt általában úgy valósítható meg, hogy kriptográfiailag biztoságos véletlen forrásból származó bitek egy nagyobb halmazát egy SHA256 hash algoritmussal összetömörítjuk, és ezzel egyszerűen létrehozunk egy 256 bites számot. Ha az eredmény kisebb, mint <tt>n - 1</tt>, akkor a titkos kulcs megfelelő. Ha nem, akkor egy másik véletlen számmal próbálkozunk.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Ne próbálkozzanak azzal, hogy saját pszeudó-véletlenszám generátort (PRNG, pseudo random number generator) írnak, vagy a kedvenc programozási nyelvük által felkínált "egyszerű" véletleszám generátort használják. Használjanak egy kriptográfiailag biztonságos pszeudó-véletlenszám generátort (CSPRNG, cryptographically-secure pseudo-random number generator), melynek magja megfelelő entrópiaforrásból származik. A CSPRNG helyes megvalósítása a kulcsok biztonsága szempontjábóll kritikus fontosságú.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Alább egy véletlenszerűen előállított (k) titkos kulcs látható hexadecimális formátumban (256 bináris számjegy, 64 hexadecimális számjeggyel ábrázolva, ahol mindegyik hexadecimális számjegy 4 bitnek felel meg):</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A titkos kulcsok száma a bitcoin esetén 2<sup>256</sup>, ami egy elképzelhetetlenül nagy szám. Decimálisan kb. 10<sup>77</sup>. A látható világegyetemben becslések szerint kb. 10<sup>80</sup> atom van.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>A Bitcoin Core kliensben (lásd  <a href="#ch03_bitcoin_client">[ch03_bitcoin_client]</a>) egy új kulcs a  <tt>getnewaddress</tt> paranccsal állítható elő. Biztonsági okokból a kliens csak a nyilvános kulcsot jelzi ki, a titkos kulcsot nem. Ha azt szeretnénk, hogy bitcoind írja ki a titkos kulcsot, használjuk a <tt>dumpprivkey</tt> parancsot. A <tt>dumpprivkey</tt> a titkos kulcs kijelzésére ellenőrző összeggel kiegészített 58-as számrendszeri formátumot használ, melyet tárca import formátumnak (WIF, <em>wallett import format</em>) hívunk. A WIF formátumot a <a href="#priv_formats">[priv_formats]</a> részben fogjuk részletesebben megvizsgálni. Az előző két paranccsal a következőképpen lehet egy titkos kulcsot előállítani és kijelezni:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bitcoind getnewaddress
1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
$ bitcoind dumpprivkey 1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</tt></pre>
</div></div>
<div class="paragraph"><p>A <tt>dumpprivkey</tt> kinyitja a pénztárcát és kiveszi belőle a <tt>getnewaddress</tt> parancs által előállított titkos kulcsot. A bitcoind csak akkor képes a nyilvános kulcsshoz tartozó titkos kulcs kiírására, ha a pénztárácában mindkettő tárolva van.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A <tt>dumpprivkey</tt> parancs a nyilvános kulcsból nem képes előállítani a titkos kulcsot, mivel ez lehetetlen. A parancs egyszerűen csak felfedi azt a titkos kulcsot, amelyet a pénztárca már ismer, és amely a <tt>getnewaddress</tt> paranccsal lett előállítva.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Titkos kulcsok előállítása és kijelzése a Bitcoin Explorer parancssori eszközzel is lehetséges, (lásd <a href="#libbitcoin">[libbitcoin]</a>). Az ehhez szükséges parancsok:  <tt>seed</tt>, <tt>ec-new</tt> és  <tt>ec-to-wif</tt>: </p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx seed | bx ec-new | bx ec-to-wif
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</tt></pre>
</div></div>
</div>
</div>
<div class="sect3">
<h4 id="pubkey">Nyilvános kulcsok</h4>
<div class="paragraph"><p>A nyilvános kulcs a titkos kulcsból, az elliptikus görbén történő szorzással számítható ki: \(K = k * G\), ahol <em>k</em> a titkos kulcs, <em>G</em> az ún. <em>generátor pont</em>, és <em>K</em> az eredményként kapott nyilvános kulcs. Az ellentétes művelet, az ún. "diszkrét logaritmus meghatározása" – vagyis a <em>k</em> kiszámítása, ha a <em>K</em> ismert – annyira nehéz, hogy egyenértékű azzal, mint ha a <tt>k</tt> összes lehetséges értékét végigpróbálgatnánk, vagyis olyan, mint egy nyers erőn alapuló keresés. Mielőtt szemléltetnénk, hogyan lehet a titkos kulcsból a nyilvános kulcsot előállítani, vizsgáljuk meg kicsit részletesebben az elliptikus görbékkel történő titkosítást.</p></div>
</div>
<div class="sect3">
<h4 id="elliptic_curve">Elliptikus görbékkel történő titkosítás</h4>
<div class="paragraph"><p>Az elliptikus görbékkel történő titkosítás egyfajta aszimmetrikus azaz nyilvános kulcsú titkosítás, amely egy elliptikus görbe pontjain végzettt összeadás és szorzás diszkrét logaritmus problémáján alapul.</p></div>
<div class="paragraph"><p>Alább egy elliptikus görbe látható, hasonló ahhoz, mint amit a bitcoin használ: <a href="#ecc-curve">[ecc-curve]</a></p></div>
<div class="imageblock" id="ecc-curve">
<div class="content">
<img src="images/msbt_0402.png" alt="ecc-curve" />
</div>
<div class="title">Figure 2. Egy elliptikus görbe</div>
</div>
<div class="paragraph"><p>A bitcoin az Amerikai Szabványügyi Hivatal (NIST, National Institute of Standards and Technology) által, a  <tt>secp256k1</tt> szabványban definiált elliptikus görbét és matematikai konstansokat használja. A <tt>secp256k1</tt> elliptikus görbét a következő függvény definiálja:</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{y^2 = (x^3 + 7)}~\text{over}~(\mathbb{F}_p)
\end{equation}</div></div>
<div class="paragraph"><p>vagy</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{y^2 \mod p = (x^3 + 7) \mod p}
\end{equation}</div></div>
<div class="paragraph"><p>A <em>mod p</em> (p prímszám szerinti modulus) azt jelzi, hogy egy <em>p</em> rendszámú véges mező fölött definiált görbéről van szó, ami úgy is írható, hogy \(\mathbb{F}_p\), ahol p = 2<sup>256</sup> - 2<sup>32</sup> - 2<sup>9</sup> – 2<sup>8</sup> -2<sup>7</sup> - 2<sup>6</sup> – 2<sup>4</sup> -1, egy nagyon nagy prímszám.</p></div>
<div class="paragraph"><p>Mivel ez a görbe a valós számok halmaza helyett egy prím rendszámú véges mező fölött lett definiálva, úgy néz ki, mint két dimenzióban szétszórt pontok halmaza, ami nagyon nehézzé teszi a megjelenítését. A matematikája azonban megegyezik a fenti, valós számok fölött definiált elliptikus görbéével. Például lent ugyanez az <a href="#ecc-over-F17-math">[ecc-over-F17-math]</a> elliptikus görbe látható egy sokkal kisebb, 17 rendszámú véges mező fölött, ahol a pont-minták egy rácson lettek megjelenítve. A bitcoin <tt>secp256k1</tt> elliptikus görbéje úgy képzelhető el, mint egy sokkal összetettebb pontminta, egy mérhetetetlenül nagy rácson.</p></div>
<div class="imageblock" id="ecc-over-F17-math">
<div class="content">
<img src="images/msbt_0403.png" alt="ecc-over-F17-math" />
</div>
<div class="title">Figure 3. Titkosítás elliptikus görbével: egy F(p) elliptikus görbe megjelenítése, p=17 esetén</div>
</div>
<div class="paragraph"><p>Lent például egy P(x, y) pont látható, amely a <tt>secp256k1</tt> görbén van. Ezt egy Python programmal önök is ellenőrizhetik:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>P = (55066263022277343669578718895168534326250603453777594175500187360389116729240, 32670510020758816978083085130507043184471273380659243275938904335757337482424)</tt></pre>
</div></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Az elliptikus görbék matematikája tartalmaz egy "végtelenben lévő" pontot, amely durván a 0-nak felel meg az összeadásban. A számítógépeken néha az x = y = 0 segítségével ábrázolják (amely nem elégíti ki az ellipitikus görbék egyenletét, de könnyen ellenőrizhető külön esetként kezelhető).</p></div>
<div class="paragraph"><p>Van továbbá egy "összeadásnak" nevezett  + művelet, amelynek néhány sajátossága hasonlít az iskolában tanult valós számok összeadásához. Ha az elliptikus görbén van két pont, P<sub>1</sub> és P<sub>2</sub>, akkor létezik egy harmadik pont, P<sub>3</sub>, amely szintén az elliptikus görbén van, és amelyre P<sub>3</sub> = P<sub>1</sub> + P<sub>2</sub> .</p></div>
<div class="paragraph"><p>Geometriailag ez a harmadik pont, a P<sub>3</sub> úgy számítható ki, hogy húzunk egy egyeneset a P<sub>1</sub> és P<sub>2</sub> között. Ez az egyenes az elliptikus görbét pontosan egy további helyen fogja metszeni. Nevezzük ezt a pontot P<sub>3</sub><em>-nek: P<sub>3</sub></em> = (x, y). A P<sub>3</sub> pont ennek a pontnak az x tengelyre történő tükrözésével kapható meg: P<sub>3</sub> = (x, -y).</p></div>
<div class="paragraph"><p>Van néhány különleges eset, amely megvilágítja, miért van szükség a "végtelenben lévő pontra".</p></div>
<div class="paragraph"><p>Ha a P<sub>1</sub> és a P<sub>2</sub> pont megegyezik, akkor a P<sub>1</sub> és P<sub>2</sub> "közötti" egyenes a görbe P<sub>1</sub> pontbeli érintője lesz. Az érintő pontosan egy pontban fogja metszeni a görbét. A differenciálszámítás segítségével meghatározható az érintő meredeksége. Ezek a módszerek érdekes módon még akkor is működnek, ha csak azok a görbén lévő pontok érdekelnek minket, melyeknek mindkét koordinátája egész szám!</p></div>
<div class="paragraph"><p>Bizonyos esetekben (pl. ha a P<sub>1</sub> és a P<sub>2</sub> x koordinátája azonos, de az y koordinátája különböző), akkor az érintő függőleges lesz, és ebben az esetben a P<sub>3</sub> = "a végtelenben lévő pont".</p></div>
<div class="paragraph"><p>Ha P<sub>1</sub> a "végtelenben lévő pont", akkor P<sub>1</sub> + P<sub>2</sub> = P<sub>2</sub>. Hasonlóképpen, ha a P<sub>2</sub> a végtelenben lévő pont, akkor P<sub>1</sub> + P<sub>2</sub> = P<sub>1</sub>. Ez mutatja, hogy a végtelenben lévő pont a 0 szerepét játssza.</p></div>
<div class="paragraph"><p>A + asszociatív, vagyis A + B) + C = A + (B + C). Ez azt jelenti, hogy A + B + C zárójelezés nélül is egyértelmű.</p></div>
<div class="paragraph"><p>Az összeadás definiálása után az szorzást a szokásos módon, az összeadás kiterjesztéseként definiálható. Az elliptikus görbén lévő P pontra, ha k egész szám, akkor kP = P + P + … + P (k-szor). Megjegyezük, hogy a k-t néha zavaró módon "kitevőnek" hívják.</p></div>
</div>
<div class="sect3">
<h4 id="public_key_derivation">Egy nyilvános kulcs előállítása</h4>
<div class="paragraph"><p>Kiindulópontunk egy titkos kulcs, amely egy véletlenszerűen előállított <em>k</em> szám, majd ezt megszorozzuk a görbe egy előre meghatározott  <em>G</em> pontjával, a <em>generátor ponttal</em>, és ezzel egy másik pontot állítunk elő valahol a görbén, ami megfelel a <em>K</em> nyilvános kulcsnak. A generátor pontot a <tt>secp256k1</tt> szabvány definiálja, és mindegyik bitcoin kulcs esetén ugyanaz.</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{K = k * G}
\end{equation}</div></div>
<div class="paragraph"><p>ahol k a titkos kulcs, G a generátor pont, és K az eredményként kapott nyilvános kulcs, azaz a görbe egy másik pontja. Mivel a generátor pont az összes bitcoin felhasználó esetén ugyanaz, egy k titkos kulcs G-vel vett szorzata mindig ugyanazt a K nyilvános kulcsot eredményezi. A k és K közötti kapcsolat rögzített, de csak az egyik irányban lehet könnyen kiszámítani, k-tól K irányában. A bitcoin címet (amely K-ból van leszármaztatva) emiatt lehet bárkivel megosztani, és emiatt nem fedi fel a felhasználó titkos kulcsát (k).</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Egy titkos kulcsból kiszámítható a nyilvános kulccsá, de egy nyilvános kulcsot nem lehet titkos kulccsá visszaalakítani, mert a számítás csak egy irányban működik.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Az  elliptikus görbén történő szorzást úgy valósítjuk meg, hogy az előzőleg előállított k titkos kulcsot megszorozzuk a G generátor ponttal, ami a K nyilvános kulcsot eredményezi:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = 1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD * G</tt></pre>
</div></div>
<div class="paragraph"><p>A K nyilvános kulcs definíció szerint egy pont: <tt>K = (x,y)</tt>:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = (x, y)

ahol

x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</tt></pre>
</div></div>
<div class="paragraph"><p>Egy pont és egy egész szorzatának megjelenítésére egy egyszerűbb, valós számokon definiált elliptikus görbét fogjuk használni – a matematika ugyanaz. A célunk az, hogy előállítsuk a G generátor pont kG többszörösét. Ez ugyanaz, mint ha a G-t k-szor összeadnánk. Az elliptikus görbék esetén egy pont önmagával történő összeadása egyenértékű azzal, hogy egy értintőt húzunk az adott pontban, és megkeressük, hogy hol metszi az érintő a görbét, majd ezt a pontot tükrözzük az x-tengelyen.</p></div>
<div class="paragraph"><p>A <a href="#ecc_illustrated">[ecc_illustrated]</a> ábra a G, 2G, 4G előállításának folyamatát mutatja, a görbén végzettt geometriai műveletek formájában.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A legtöbb bitcoin implementáció az  <a href="http://bit.ly/1ql7bn8">OpenSSL könyvtár</a> OpenSSL könyvtárat használja az elliptikus görbékkel történő titkosításra. Például a nyilvános kulcs előállítása az <tt>EC_PONT_mul()</tt> függvénnyel lehetséges.</p></div>
</td>
</tr></table>
</div>
<div class="imageblock" id="ecc_illustrated">
<div class="content">
<img src="images/msbt_0404.png" alt="ecc_illustrated" />
</div>
<div class="title">Figure 4. Elliptikus görbével történő titkosítás: a G pont és egy egész szorzatának megjelenítése egy elliptikus görbén</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_bitcoin_címek">Bitcoin címek</h3>
<div class="paragraph"><p>A bitcoin cím egy számokból és betűkből álló string, amely bárkivel megosztható, aki pénz akar önöknek küldeni. A nyilvános kulcsból előállított címek betűket és számokat tartalmaznak, és az „1” számjeggyel kezdődnek. Példa egy bitcoin címre:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</tt></pre>
</div></div>
<div class="paragraph"><p>A tranzakciókban a bitcoin cím leggyakrabban a pénz „címzettjét” azonosítja. Ha összehasonlítjuk a bitcoin tranzakciót egy papír csekkel, akkor a bitcoin cím felel meg a kedvezményezettnek, vagyis ezt írjuk a „Kinek fizetendő” sor után. Papír csekk esetén a kedvezményezett néha egy bankszámlaszám, de lehet cég, intézmény vagy akár pénzt is felvehetünk vele. Mivel a papír csekkeken nem kell számlaszámot megadni, csak egy absztrakt személyt, aki a pénz címzettje, ezért a papír csekkek nagyon rugalmas fizetési eszközt jelentenek. A bitcoin tranzakciók hasonló absztrakciót használnak, a bitcoin címet, ami nagyon rugalmassá teszi őket. A bitcoin cím képviselheti egy nyilvános/titkos kulcspár tulajdonosát, vagy valami mást, pl. egy scriptet, amint azt a <a href="#p2sh">[p2sh]</a> részben látni fogjuk. Egyelőre vizsgáljuk meg az egyszerű esetet, amikor a bitcoin cím egy nyilvános kulcsból származik és azt képviseli.</p></div>
<div class="paragraph"><p>A bitcoin cím a nyilvános kulcsból egy egyirányú kriptográfiai tömörítés (hashing) használatával áll elő. A „tömörítő algoritmus” vagy egyszerűen „hash algoritmus” egy egyirányú függvény, amely egy tetszőleges méretű bemenet esetén egy ujjlenyomatot vagy „zanzát” (hash-t) állít elő. A kriptográfiai hash függvényeket a bitcoin a bitcoin címekben, a script címekeben és a bányászat „munkabizonyíték” algoritmusában széleskörűen használja. A nyilvános kulcsból a bitcoin cím előállítása a következő algoritumusokkal történik: az SHA (Secure Hash Algorithm) és a RIPEMD (RACE Integrity Primitives Evaluation Message Digest), konkrétabban az SHA256 és a RIPEMD160 segítségével.</p></div>
<div class="paragraph"><p>A K nyilvános kulcsból kiindulva kiszámítjuk a kulcs SHA256 tömörítését, majd az eredmény RIPEMD160 tömörítését. Így egy 160 bites (20 bájtos) számot kapunk:</p></div>
<div class="mathblock">
<div class="content">\begin{equation}
{A = RIPEMD160(SHA256(K))}
\end{equation}</div></div>
<div class="paragraph"><p>ahol K a nyilvános kulcs és A az eredményként kapott bitcoin cím.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Egy bitcoin cím <em>nem</em> azonos a nyilvános kulccsal. A bitcoin címek a nyilvános kulcsból származnak, egy egyirányú függvény alkalmazásával.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>A bitcoin címeket a felhasználók majdnem mindig „Base58Check” kódolásban látják (lásd <a href="#base58">[base58]</a>). Ez a kódolás 58 karaktert (58-as számrendszert) használ, és egy ellenőrző összeggel van kiegészítve, ami segíti az olvashatóságot, és véd a cím beviteli és továbbítási hibák ellen. A Base58Check sok más módon is szerephez jut a bitcoinban, ha egy szám, pl. egy bitcoin cím, egy titkos kulcs, egy titkosított kulcs vagy egy script tömörítésének pontos beírására van szükség. A következő részben megvizsgáljuk a Base58Check kódolás és dekódolás működését, és az így előálló alakokat. A  <a href="#pubkey_to_address">[pubkey_to_address]</a> egy nyilvános kulcs bitcoin címmé történő átalakítását szemlélteti. </p></div>
<div class="imageblock" id="pubkey_to_address">
<div class="content">
<img src="images/msbt_0405.png" alt="pubkey_to_address" />
</div>
<div class="title">Figure 5. Nyilvános kulcsból bitcoin cím: egy nyilvános kulcs átalakítása bitcoin címmé</div>
</div>
<div class="sect3">
<h4 id="base58">Base58 és Base58Check kódolás</h4>
<div class="paragraph"><p>Azért, hogy a hosszú számok tömören, kevesebb szimbólummal legyenek ábrázolhatók, sok számítógéprendszer vegyes alfanumerikus ábrázolást használ, ahol a számrendszer  alapja 10-nél nagyobb. Például míg a szokásos tízes alapú számrendszer 0-tól 9-ig 10 számjegyet használ, a hexadecimális számrendszer 16-ot,  amelyben az A és F közötti betűk jelentik a további hat szimbólumot. Egy hexadecimális formátumban ábrázolt szám rövidebb, mint a neki megfelelő tízes számrendszerbeli szám. Még tömörebb a Base-64 ábrázolás, amely a 26 kisbetűt, a 26 nagybetűt, a 10 számjegyet és két további karaktert, a „\+” és a „/” karaktereket használja bináris adatok szövegként, pl. e-levélben történő továbbítására. A Base-64-et leggyakrabban e-levelek bináris csatolmányainál használják. A Base-58 formátum egy olyan szöveges formátum, melyet a bitcoin és sok más digitális pénz használ. Egyensúlyt teremt a tömör ábrázolás, az olvashatóság, a hiba ellenőrzés és a hiba megelőzés között. A Base-58 a Base-64 egy részhalmaza: a kis- és nagybetűkket valamint a számokat használja, de elhagy közülük néhányat, amelyeket gyakran összecserélnek egymással, vagy amelyek némelyik betűtípus esetén egyformának látszanak. A Base-58 olyan Base-64, melyből hiányzik a 0 (a nulla szám), az O (a nagy o betű), az l (a kis L), az I (a nagy i), valamint a „\+” és „/”. Vagy egyszerűbben, a Base-58 a kis- és nagybetűk valamint a számok halmaza, melyből hiányzik az előbb említett négy karakter (0, O, l, I).</p></div>
<div class="exampleblock" id="base58alphabet">
<div class="title">Example 1. A bitcoin Base-58 ábécéje</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre><tt>123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz</tt></pre>
</div></div>
</div></div>
<div class="paragraph"><p>A Base58Check olyan Base-58 kódolási formátum, amely az elírások és továbbítási hibák elleni védelemként beépített hiba ellenőrző kóddal rendelkezik. Az ellenőrző összeg további négy bájt, amely a kódolt adat végén áll. Az ellenőrző összeg a kódolt adat tömörítéséből származik, emiatt gépelési hibák felfedésére és megelőzésére használható. A dekódoló szoftver egy Base58Check kód esetén kiszámítja az adat ellenőrző összegét, és összehasonlítja a kódban lévő ellenőrző összeggel. Ha a kettő nem egyezik meg, akkor ez azt mutatja, hogy hiba van, és a Base58Check adat érvénytelen. Pl. ezen a módon megelőzhető, hogy egy elgépelt bitcoin címet a pénztárca alkalmazás érvényes címként fogadjon el. Az ellenőrzés hiányában egy gépelési hiba a pénz elvesztéséhez vezetne.</p></div>
<div class="paragraph"><p>Egy tetszőleges adat (szám) Base58Check formátumba történő átalakítása úgy történik, hogy az adathoz egy előtagot adunk hozzá, az úgynevezett „verzió bájt”-ot, ami a kódolt adat adattípusának egyszerű azonosítására szolgál. Például a bitcoin címek esetében ez az előtag nulla (0x00 hexadecimálisan), míg a titkos kulcsok esetében 128 (0x80 hexadecimálisan). A leggyakoribb előtagokat a <a href="#base58check_versions">[base58check_versions]</a> táblázat mutatja.</p></div>
<div class="paragraph"><p>Ezután kiszámítjuk a „kettős-SHA” ellenőrző összeget, vagyis az SHA256 hash algoritmust az előző eredményen kétszer alkalmazzuk:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>checksum = SHA256(SHA256(prefix+data))</tt></pre>
</div></div>
<div class="paragraph"><p>Az eredményként kapott 32 bájtos hashből (a hash hashéből) csak az elő négy bájtot használjuk. Ez a négy bájt szolgál hibaellenőrző kódként vagy ellenőrző összegként. Az ellenőrző összeget hozzáadjuk a cím végéhez.</p></div>
<div class="paragraph"><p>Az eredmény három részből tevődik össze: egy előtagból, az adatból és az ellenőrző összegből. Az eredményt az előzőleg leírt Base58 ábécével kódoljuk. A <a href="#base58check_encoding">[base58check_encoding]</a>  szemlélteti a Base58Check kódolási folyamatát.</p></div>
<div class="imageblock" id="base58check_encoding">
<div class="content">
<img src="images/msbt_0406.png" alt="Base58CheckEncoding" />
</div>
<div class="title">Figure 6. Base58Check kódolás: bitcoin adatok egyértelmű kódolása 58-as számrendszerben, verziószámmal és ellenőrző összeggel</div>
</div>
<div class="paragraph"><p>A bitcoin esetén a felhasználó számára megjelenített legtöbb adat Base58Check kódolású, mert így az adatok tömörek, könnyen olvashatók és a hibák szempontjából könnyen ellenőrizhetők. A Base58Check kódolásban használt verzió előtag lehetővé teszi, hogy egymástól könnyen megkülönböztethető formátumokat hozzunk létre. Az előtag Base-58-ban kódolva a Base58Check kódolt formátum egy adott karaktere lesz, ami az emberek számára is könnyűvé teszi az adattípusok felismerését és használatát. Ez különbözteti meg péládul az „1”-essel kezdődő Base58Check formátumban kódolt bitcoin címet a „5”-sel kezdődő WIF formátumú titkos kulcstól. Néhány minta előtag és az eredményként kapott Base-58 karakter itt látható <a href="#base58check_versions">[base58check_versions]</a>.</p></div>
<?hard-pagebreak?>
<div class="tableblock" id="base58check_versions">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. Base58Check verzió előtagok és a kódolt eredmények</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Típus</th>
<th align="left" valign="top"> Verzió előtag (hexa)</th>
<th align="left" valign="top"> A Base58 eredmény előtagja</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Bitcoin cím</p></td>
<td align="left" valign="top"><p class="table">0x00</p></td>
<td align="left" valign="top"><p class="table">1</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">FIzetés-Script-Hash-nek cím</p></td>
<td align="left" valign="top"><p class="table">0x05</p></td>
<td align="left" valign="top"><p class="table">3</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Bitcoin Testnet cím</p></td>
<td align="left" valign="top"><p class="table">0x6F</p></td>
<td align="left" valign="top"><p class="table">m vagy n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF titkos kulcs</p></td>
<td align="left" valign="top"><p class="table">0x80</p></td>
<td align="left" valign="top"><p class="table">5, K vagy L</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BIP38 kódolt titkos kulcs</p></td>
<td align="left" valign="top"><p class="table">0x0142</p></td>
<td align="left" valign="top"><p class="table">6P</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">BIP32 kiterjesztett nyilvános kulcs</p></td>
<td align="left" valign="top"><p class="table">0x0488B21E</p></td>
<td align="left" valign="top"><p class="table">xpub</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Tekintsük át a bitcoin cím előállítás teljes folymatatát, a titkos kulcstól a nyilvános kulcson keresztül a kettősen hash-elt címig, és végül a Base58Check kódolásig. Az <a href="#addr_example">[addr_example]</a> részben látható C++ kód lépésről lépésre a teljes folyamatot bemutatja, a privát kulcstól a Base58Check kódolású bitcoin címig. A példa az <a href="#alt_libraries">[alt_libraries]</a> részben bevezetett libbitcoin könyvtár segédfüggvényeit használja.</p></div>
<div class="exampleblock" id="addr_example">
<div class="title">Example 2. A titkos kulcsból egy Base58Check kódolású bitcoin cím létrehozása</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>A kód egy előre definiált titkos kulcsot használ, emiatt minden egyes futásakor ugyanazt a címet hozza létre, amint azt a <a href="#addr_example_run">[addr_example_run]</a> mutatja.</p></div>
<div class="exampleblock" id="addr_example_run">
<div class="title">Example 3. A bitcoin címet előállító mintapélda lefordítása és futtatása</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
<div class="sect3">
<h4 id="_kulcs_formátumok">Kulcs formátumok</h4>
<div class="paragraph"><p>Mind a titkos, mind  a nyilvános kulcs számos különböző formátumban ábrázolható. A különféle ábrázolási módok ugyanazt a számot ábrázolják, még ha különbözőnek látszak is. Ezeket a formátumok főként arra használatosak, hogy megkönnyítsék a kulcsok leírását és megadását, és védjenek a hibák ellen.</p></div>
<div class="sect4">
<h5 id="priv_formats">Titkos kulcs formátumok</h5>
<div class="paragraph"><p>Egy titkos kulcs számos különböző formátumban ábrázolható. Ezek mindegyike ugyanannak a 256-bites számnak felel meg. A <a href="#table_4-2">[table_4-2]</a> táblázatban a titkos kulcsok ábrázolására szolgáló három leggyakrabban használt formátum látható.</p></div>
<div class="tableblock" id="table_4-2">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. Egy titkos kulcs ábrázolási módjai (kódolási formátumok)</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Típus</th>
<th align="left" valign="top">Előtag</th>
<th align="left" valign="top">Leírás</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Hexa</p></td>
<td align="left" valign="top"><p class="table">Nincs</p></td>
<td align="left" valign="top"><p class="table">64 hexadecimális számjegy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">Base58Check kódolás: Base58, verzió előtaggal (128) és egy 32 bites ellenőrző összeggel</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tömörített WIF</p></td>
<td align="left" valign="top"><p class="table">K vagy L</p></td>
<td align="left" valign="top"><p class="table">Mint előbb, de a kódolás előtt a 0x01 utótag hozzáfűzése</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>A <a href="#table_4-3">[table_4-3]</a> ebben a három formátumban tartalmazza ugyanazt a privát kulcsot.</p></div>
<?hard-pagebreak?>
<div class="tableblock" id="table_4-3">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. Példa: Ugyanaz a kulcs, különböző formátumok</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">Formátum </th>
<th align="left" valign="top"> Titkos kulcs</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Hexa</p></td>
<td align="left" valign="top"><p class="table">1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tömörített WIF</p></td>
<td align="left" valign="top"><p class="table">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Az összes fenti alak ugyanazt a számot, ugyanazt a titkos kulcsot ábrázolja. Ezek különbözőnek látszanak ugyan, de bármelyik formátum könnyen átalakítható bármelyik másik formátumra.</p></div>
<div class="paragraph"><p>A Bitcoin Explorer  <tt>wif-to-ec</tt> parancsával tudjuk megmutatni, hogy mindkét WIF kulcs ugyanannak a titkos kulcsnak felel meg:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx wif-to-ec 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd

$ bx wif-to-ec KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_a_base58check_formátum_dekódolása">A Base58Check formátum dekódolása</h5>
<div class="paragraph"><p>A Bitcoin Explorer parancsaival (lásd <a href="#libbitcoin">[libbitcoin]</a>) könnyen tudunk bitcoin kulcsokat, címeket és tranzakciókat kezelő shell scripteket és "pipe"-okat írni. A Bitcoin Explorer-rel a következőképpen lehet a parancssorban dekódolni a Base58Check formátumot:</p></div>
<div class="paragraph"><p>A <tt>base58check-decode</tt> parancsot használjuk a tömörítetlen kulcs dekódolására:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx base58check-decode 5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn
wrapper
{
    checksum 4286807748
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd
    version 128
}</tt></pre>
</div></div>
<div class="paragraph"><p>Az eredmény a kulcsot (hasznos tartalom, payload), a Pénztárca Import Formátum (Wallet Import Format, WIF) előtagját (128) és az ellenőrző összeget tartalmazza.</p></div>
<div class="paragraph"><p>Figyelje meg, hogy a tömörített kulcs "hasznos tartalmához" a <tt>01</tt> utótag lett hozzáfűzve, ami azt jelzi, hogy tömörített kulcsot szeretnénk előállítani.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx base58check-decode KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ
wrapper
{
    checksum 2339607926
    payload 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01
    version 128
}</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_hexadecimális_formátum_átalakítása_base58check_formátumba">Hexadecimális formátum átalakítása Base58Check formátumba</h5>
<div class="paragraph"><p>Ha hexadecimális formátumból Base58Check formátumba szeretnénk átalakítást végezni (az előző parancs ellentettje), akkor a Bitcoin Explorer  <tt>base58check-encode</tt> parancsát használhatjuk (lásd <a href="#libbitcoin">[libbitcoin]</a>). A hexadecimális titkos kulcs után a  Wallet Import Format (WIF) előtagot, a  128-at kell megadni:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd --version 128
5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="_tömörített_hexadecimális_kulcs_kódolása_base58check_formátumba">Tömörített hexadecimális kulcs kódolása Base58Check formátumba</h5>
<div class="paragraph"><p>Ha „tömörített” titkos kulcsként  (lásd <a href="#comp_priv">[comp_priv]</a>) szeretnénk a kulcsot Base58Check kódolással előállítani, akkor hozzáadjuk a <tt>01</tt> utótagot a hexa kulcshoz, majd a fentiekhez hasonlóan elvégezzük a kódolást:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ bx base58check-encode 1e99423a4ed27608a15a2616a2b0e9e52ced330ac530edcc32c8ffc6a526aedd01 --version 128
KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</tt></pre>
</div></div>
<div class="paragraph"><p>Az eredményként kapott WIF tömörített formátum „K”-val kezdődik, ami azt jelzi, hogy a titkos kulcsnak egy „01” utótagja van, és csak tömörített nyilvános kulcsok hozhatók létre belőle (lásd a <a href="#comp_pub">[comp_pub]</a> részt).</p></div>
</div>
<div class="sect4">
<h5 id="_nyilvános_kulcs_formátumok">Nyilvános kulcs formátumok</h5>
<div class="paragraph"><p>A nyilvános kulcsok szintén többféle formátumban ábrázolhatók, a legfontosabbak a <em>tömörített</em> és a <em>nem tömörített</em> nyilvános kulcsok.</p></div>
<div class="paragraph"><p>Mint azt előzőleg láttuk, a nyilvános kulcs az elliptikus görbe egy pontja, amely egy <tt>(x,y)</tt> koordinátapárból áll. Általában a <tt>04</tt> előtaggal ábrázolják, melyet két 256-bites szám követ, az egyik a pont <em>x</em>-koordinátája, a másik az <em>y</em>-koordinátája. A <tt>04</tt> előtag különbözteti meg a nem tömörített nyilvános kulcsokat a tömörített nyilvános kulcsoktól, melyek <tt>02</tt>-vel vagy <tt>03</tt>-mal kezdődnek.</p></div>
<div class="paragraph"><p>Alább a fenti titkos kulcsból előállított nyilvános kulcs <tt>x</tt> és <tt>y</tt> koordinátája látható.</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>x = F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A
y = 07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</tt></pre>
</div></div>
<div class="paragraph"><p>Ugyanez a nyilvános kulcs egy 520-bites számként (130 hexa számjegyként), a <tt>04</tt> előtaggal, melyet az <tt>x</tt> és az <tt>y</tt> koordináta követ:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = 04F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A&lt;?pdf-cr?&gt;07CF33DA18BD734C600B96A72BBC4749D5141C90EC8AC328AE52DDFE2E505BDB</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="comp_pub">Tömörített nyilvános kulcsok</h5>
<div class="paragraph"><p><?dbhtml orphans="4"?>A tömörített nyilvános kulcsokat azért vezették be a bitcoinban, hogy csökkentsék a tranzakciók méretét és diszk helyet takarítsanak a teljes bitcoin blokklánc adatbázist tároló csomópontokon. A legtöbb tranzakcióban szerepel a nyilvános kulcs, amely a tulajdonos személyazonosságának tanúsítására és a bitcoin elköltésére szolgál. Mindegyik nyilvános kulcs 520 bit hosszú (előtag \+ x \+ y), ami összeszorozva a blokkban lévő több száz tranzakcióval, vagy a napi több tízezer tranzakcióval jelentős adatmennyiséget tesz ki a blokkláncon.</p></div>
<div class="paragraph"><p>Amint azt a <a href="#pubkey">[pubkey]</a> részben láttuk, a nyilvános kulcs egy (x,y) pont az elliptikus görbén. Mivel a görbe egy matematikai függvénynek felel meg, a görbén lévő pont a görbe egyenletének egy megoldását jelenti. Ezért ha ismerjük az <em>x</em>-koordinátát, akkor az <em>y</em>-koordinátát az y<sup>2</sup> mod p = (x<sup>3</sup> + 7) mod p egyenlet megoldásával számíthatjuk ki. Ez lehetővé teszi, hogy a nyilvános kulcsban csak az <em>x</em>-koordinátáját tároljuk, és elhagyhassuk az <em>y</em>-koordinátát. Ily módon 256 bittel csökkenthető a tároláshoz szükséges hely. Ezzel  majdnem 50%-kal csökken minden tranzakció mérete, ami idővel nagyon nagy helymegtakarításhoz vezet.</p></div>
<div class="paragraph"><p>Míg a nem tömörített nyilvános kulcsoknak <tt>04</tt> az előtagja, a  tömörített kulcsok <tt>02</tt>-vel vagy <tt>03</tt>-mal kezdődnek. Vizsgáljuk meg, miért van két lehetséges előtag! Mivel az egyenlet bal oldalán y<sup>2</sup> áll, az y megoldás pozitív vagy negatív lehet. Képileg ez azt jelenti, hogy az <em>y</em>-koordináta az <em>x</em>-tengely felett vagy az <em>x</em>-tengely alatt lehet. Amint azt az elliptikus görbe <a href="#ecc-curve">[ecc-curve]</a> ábrázolásán láthatjuk, a görbe szimmetrikus, ami azt jelenti, hogy az x-tengelyre tükrös. Emiatt, ha el is hagyhatjuk az <em>y</em> koordinátát, az y <em>előjelét</em> (pozitív vagy negatív) tárolnunk kell, más szóval, tudnunk kell, hogy az x-tengely felett vagy alatt volt-e, mivel mindkét lehetőséghez egy különböző pont és egy különböző nyilvános kulcs tartozik. Ha az elliptikus görbét a p-rendű véges mezőn számítjuk ki, az <em>y</em> koodináta páros vagy páratlan lehet, ami megfelel a fenti pozitív vagy negatív előjelnek. Ezért aztán ha szeretnénk megkülönböztetni az y lehetséges értékeit, akkor a tömörített nyilvános kulcsot <tt>02</tt> előtaggal tároljuk, ha az <tt>y</tt> páros, és <tt>03</tt>-mal, ha páratlan, ami lehetővé teszi, hogy egy program az <em>x</em>-koordinátából helyesen meg tudja állapítani az <em>y</em>-koordináta értékét, és a tömörített nyilvános kulcsból a pont mindkét koordinátáját előállítsa . A nyilvános kulcs tömörítését a <a href="#pubkey_compression">[pubkey_compression]</a> szemlélteti.</p></div>
<div class="imageblock" id="pubkey_compression">
<div class="content">
<img src="images/msbt_0407.png" alt="pubkey_compression" />
</div>
<div class="title">Figure 7. A nyilvános kulcs tömörítése</div>
</div>
<div class="paragraph"><p>Íme, ugyanaz a nyilvános kulcs, melyet előzőleg láttunk, tömörített nyilvános kulcsként, 264 biten (66 hexa számjeggyel) tárolva. A <tt>03</tt> előtag azt jelzi, hogy az <em>y</em> koodináta páratlan:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>K = 03F028892BAD7ED57D2FB57BF33081D5CFCF6F9ED3D3D7F159C2E2FFF579DC341A</tt></pre>
</div></div>
<div class="paragraph"><p>Ez a tömörített nyilvános kulcs ugyanannak a titkos kulcsnak felel meg, ami azt jelenti, hogy ugyanabból a titkos kulcsból lett előállítva. Mégis különbözőnek látszik a nem tömörített nyilvános kulcstól. Még fontosabb, hogy ha ezt a tömörített nyilvános címet a kétszeres hash függvénnyel (<tt>RIPEMD160(SHA256(K))</tt>) bitcoin címmé alakítjuk át, akkor egy másik bitcoin címet kapunk. Ez zavaró lehet, mert azt jelenti, hogy ugyanabból a titkos kulcsból két <em>különböző</em> nyilvános kulcs állítható elő, mely két különböző formátumban ábrázolható (tömörítve és nem tömörítve), ami két különböző bitcoin címet eredményez. Ugyanakkor a titkos kulcs mindkét bitcoin cím esetén azonos.</p></div>
<div class="paragraph"><p>A tömörített nyilvános kulcsok lassanként alapértelmezettek lesznek a különféle bitcoin klienseken belül, ami jelentős hatással van a tranzakciók méretének csökkentésére, és emiatt a blokkláncra. De még nem mindegyik kliens támogatja a tömörített nyilvános kulcsokat. Az újabb klienseknek, melyek támogatják a tömörített nyilvános kulcsokat, számolniuk kell a tömörített nyilvános kulcsokat nem támogató, régebbi kliensekből származó tranzakciókkal. Ez különösen fontos akkor, ha egy pénztárca alkalmazás titkos kulcsokat importál egy másik pénztárca alkalmazásból, mert az új pénztárcának végig kell pásztáznia a blokkláncot, ha szeretné megtalálni az importált kulcsokhoz tartozó tranzakciókat. Melyik bitcoin címet kell a bitcoin pénztárcának végigpásztáznia? A nem tömörített nyilvános kulcs által előállított bitcoin címet, vagy a tömörített nyilvános kulcshoz tartozó bitcoin címet? Mindkettő érvényes bitcoin cím, és mindkettő aláírható a titkos kulccsal, de mégis két külön címről van szó!</p></div>
<div class="paragraph"><p>A kérdés megoldása érdekében a titkos kulcsok pénztárcából történő kiexportálásakor a titkos kulcsokat ábrázoló WIF formátum (Wallet Import Format, pénztárca import formátum) az újabb pénztárcák esetében eltérő módon lett megvalósítva, hogy azt is jelezze, ha a titkos kulcsok <em>tömörített</em> nyilvános kulcsok előállítására szolgálnak, és ennek megfelelően tömörített bitcoin címek tartoznak hozzájuk. Ez lehetővé teszi, hogy az importálást végző pénztárca különbséget tudjon tenni a régebbi vagy újabb pénztárcákból származó titkos kulcsok között, és a blokkláncon azokat a tranzakciókat keresse meg, melyek a megfelelő nem tömörített vagy tömörített nyilvános kulcsokhoz tartozó bitcoin cimeknek felelnek meg. Nézzük meg részletesebben, hogyan megy mindez végbe.</p></div>
</div>
<div class="sect4">
<h5 id="comp_priv">Tömörített titkos kulcsok</h5>
<div class="paragraph"><p>A „tömörített titkos kulcs” elnevezés eléggé félrevezető, mert a titkos kulcs kiexportálása WIF-tömörített titkos kulcsként történik, és valójában egy bájttal <em>hosszabb</em>, mint a „tömörítetlen” titkos kulcs. Ennek az az oka, hogy 01 utótaggal végződik, ami azt jelzi, hogy egy újabb, modern pénztárcából származik, és csak tömörített nyilvános kulcsok előállítására szabad használni. A titkos kulcsok nincsenek tömörítve és nem tömöríthetők. A „tömörített titkos kulcs” kifejezés valójában azt jelenti, hogy „olyan titkos kulcs, melyből tömörített nyilvános kulcsot kell előállítani”, míg a „nem tömörített titkos kulcs” azt jelenti, hogy „olyan titkos kulcs, melyből nem tömörített nyilvános kulcsot kell előállítani”. Az export formátumra „WIF-tömörített” vagy „WIF” formátumként érdemes hivatkozni, és a titkos kulcsnál a további félreértések elkerülése érdekében el kell felejteni a „tömörítés” szót.</p></div>
<div class="paragraph"><p>Megjegyezzük, hogy a kétféle formátum <em>nem</em> cseréhető fel egymással. Egy modern pénztárcában, amely képes a tömörített nyilvános kulcsok kezelésére, a titkos kulcsok mindig WIF-tömörített alakban lesznek kiexportálva (K/L előtag). Ha a pénztárca régebbi, és nem használja a tömörített nyilvános kulcsokat, a titkos kulcs mindig WIF formátumban lesz kiexportálva (5 előtag). A cél az, hogy jelezzük a titkos kulcsokat beimportáló pénztárca számára, hogy tömörített vagy tömörítetlen nyilvános kulcsokat és címeket kell-e keresnie a blokkláncban.</p></div>
<div class="paragraph"><p>Ha a bitcoin pénztárca képes a tömörített nyilvános kulcsok kezelésére, akkor az összes tranzakcióban ezeket fogja használni. A pénztárcában lévő titkos kulcsokból levezethetők a görbén lévő nyilvános pontok, majd megtörténik ezek tömörítése. A pénztárca a tömörített nyilvános kulcsokat fogja bitcoin címek előállítására használni, és ezek szerepelnek majd a tranzakciókban. Ha titkos kulcsokat exportálunk ki egy új pénztárcából, amely támogatja a tömörített nyilvános kulcsokat, akkor a WIF formátum úgy módosul, hogy a titkos kulcs egy 1 bájtos utótaggal (<tt>01</tt>) egészül ki. Ennek a Base58Check kódolásával kapott titkos kulcsot nevezzük „tömörített WIF”-nek, és ez a „K” vagy az „L” betűvel kezdődik, ellentétben a régebbi pénztárcákból származó, WIF kódolt (nem tömörített) kulcsokkal, melyek „5”-tel kezdődnek.</p></div>
<div class="paragraph"><p>A <a href="#table_4-4">[table_4-4]</a> ugyanazt a kulcsot mutatja, WIF és WIF-tömörített formátumban.</p></div>
<div class="tableblock" id="table_4-4">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 4. Példa: Ugyanaz a kulcs, különböző formátumok</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">Formátum </th>
<th align="left" valign="top"> Titkos kulcs</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Hexa</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">WIF</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Tömörített hexa</p></td>
<td align="left" valign="top"><p class="table">1E99423A4ED27608A15A2616A2B0E9E52CED330AC530EDCC32C8FFC6A526AEDD_01_</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">tömörített WIF</p></td>
<td align="left" valign="top"><p class="table">KxFC1jmwwCoACiCAWZ3eXa96mBM6tb3TYzGmf6YwgdGWZgawvrtJ</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A „tömörített titkos kulcs” teljesen helytelen elenevezés! A titkos kulcs nincs tömörítve. A WIF-tömörített formátum jelenti, hogy a titkos kulcsból csak tömörített nyilvános kulcsot, és az ehhez tartozó bitcoin címet szabad előállítani. A „WIF-tömörített” titkos kulcs egy bájttal hosszab, mert a 01 utótaggal rendelkezik, amely megkülönbözteti a „tömörítetlen” titkos kulcstól.</p></div>
</td>
</tr></table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kulcsok_és_címek_kezelése_pythonban">Kulcsok és címek kezelése Pythonban</h3>
<div class="paragraph"><p>A legátfogóbb Pythonban  megírt bitcoin könyvtár Vitalik Buterin <a href="https://github.com/vbuterin/pybitcointools">pybitcointools</a> könyvtára. A <a href="#key-to-address_script">[key-to-address_script]</a> példában a „bitcoin”-ként beimportált pybitcointools könyvtárral fogjunk különféle formátumú kulcsokat és címeket előállítani:</p></div>
<div class="paragraph" id="key-to-address_script"><p>Kulcs és cím előállítás és formattálás a pybitcointools könyvtárral</p></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>A <a href="#key-to-address_script_run">[key-to-address_script_run]</a> a kód futtatásakor kapott kimenet mutatja:</p></div>
<div class="exampleblock" id="key-to-address_script_run">
<div class="title">Example 4. A key-to-address-ecc-example.py futtatása</div>
<div class="content">
<screen>
$ python key-to-address-ecc-example.py
Private Key (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa6
Private Key (decimal) is:
 26563230048437957592232553826663696440606756685920117476832299673293013768870
Private Key (WIF) is:
 5JG9hT3beGTJuUAmCQEmNaxAuMacCTfXuw1R3FCXig23RQHMr4K
Private Key Compressed (hex) is:
 3aba4162c7251c891207b747840551a71939b0de081f85c4e44cf7c13e41daa601
Private Key (WIF-Compressed) is:
 KyBsPXxTuVD82av65KZkrGrWi5qLMah5SdNq6uftawDbgKa2wv6S
Public Key (x,y) coordinates is:
 (41637322786646325214887832269588396900663353932545912953362782457239403430124L,
 16388935128781238405526710466724741593761085120864331449066658622400339362166L)
Public Key (hex) is:
 045c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec<?pdf-cr?>243bcefdd4347074d44bd7356d6a53c495737dd96295e2a9374bf5f02ebfc176
Compressed Public Key (hex) is:
 025c0de3b9c8ab18dd04e3511243ec2952002dbfadc864b9628910169d9b9b00ec
Bitcoin Address (b58check) is:
 1thMirt546nngXqyPEz532S8fLwbozud8
Compressed Bitcoin Address (b58check) is:
 14cxpo3MBCYYWCgF74SWTdcmxipnGUsPw3
</screen>
</div></div>
<div class="paragraph"><p>Az <a href="#ec_math">[ec_math]</a> egy másik példa, amely a Python ECDSA könyvtárat használja az ellpitikus görbén történő számításokhoz, és nem használ semmilyen egyéb speciális bitcoin könyvtárat.</p></div>
<div class="exampleblock" id="ec_math">
<div class="title">Example 5. A bitcoin kulcsoknál használt, elliptikus görbén végzett számítások szemléltetése</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Az <a href="#ec_math_run">[ec_math_run]</a> a script futtatásakor kapott kimenetet mutatja.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>A fenti példa az <tt>os.urandom</tt> véletlenszám generátort használja, amely kriptográfiailag biztonságos véletlenszám generátor (cryptographically secure random number generator (CSRNG)), amely a scriptet futtató operációs rendszerből származik. Az UNIX-szerű operációs rendszerek, például a Linux esetén a <tt>/dev/urandom</tt> forrást használja, a Windows esetén pedig a <tt>CryptGenRandom()</tt> függvényt hívja. Ha nem talál megfelelő véletlen forrást, akkor a <tt>NotImplementedError</tt> hibajelzést adja. Az itt használt véletlenszám generátor csupán szemléltetési célokra szolgál, és <em>NEM</em> alkalmas éles bitcoin kulcsok előállítására, mivel nem elégséges a biztonsága.</p></div>
</td>
</tr></table>
</div>
<div class="exampleblock" id="ec_math_run">
<div class="title">Example 6. A Python ECDSA könyvtár installálása és az ec_math.py script futtatása</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre><tt>$ # Install Python PIP package manager
$ sudo apt-get install python-pip
$ # Install the Python ECDSA library
$ sudo pip install ecdsa
$ # Run the script
$ python ec-math.py
Secret:  38090835015954358862481132628887443905906204995912378278060168703580660294000
EC point: (70048853531867179489857750497606966272382583471322935454624595540007269312627, 105262206478686743191060800263479589329920209527285803935736021686045542353380)
BTC public key: 029ade3effb0a67d5c8609850d797366af428f4a0d5194cb221d807770a1522873</tt></pre>
</div></div>
</div></div>
</div>
<div class="sect2">
<h3 id="_pénztárcák">Pénztárcák</h3>
<div class="paragraph"><p>A pénztárcák a titkos kulcsok tárolására szolgálnak. Általában struktúrált adatállományokkal vagy egyszerű adatbázisokkal  vannak megvalósítva.
A kulcs előállításának egy másik módszere a <em>determinisztikus kulcs előállítás</em>. Ennél mindegyik új titkos kulcs egy egyirányú hash függvény használatával, az előző titkos kulcsból áll elő, és egy sorozatot képez. A sorozat újbóli létrehozásához csak az első kulcsra van szükség (ennek <em>mag</em> vagy <em>mesterkulcs</em> a neve). Ebben a részben megvizsgáljuk a kulcsgenerálás különféle módszereit, és a köréjük épített pénztárca szerkezeteket.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A pénztárcában kulcsok vannak, nem pedig érmék. Mindegyik felhasználónak van egy kulcsokat tartalmazó pénztárcája. A pénztárcák valójában kulcskarikák, melyeken nyilvános/titkos kulcspárok vannak (lásd a <a href="#private_public_keys">[private_public_keys]</a> részt). A felhasználók a kulcsokkal írják alá a tranzakciókat, így bizonyítva, hogy a birtokukban vannak az aláírt tranzakció kimenetek (az érmék). Az érméket a blokklánc tárolja, tranzakció kimenetek formájában (ezeket gyakran úgy jelölik, hogy vout vagy txout).</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="random_wallet">Nem-determinisztikus (véletlen) pénztárcák</h4>
<div class="paragraph"><p>Az első bitcoin kliensekben a pénztárca egyszerűen egy halom véletlenszerűen generált titkos kulcs volt. Az ilyen pénztárcákat <em>0. típusú, nem determinisztikus pénztárcának</em> hívjuk. Például a Bitcoin Core kliens az első indításakor előre 100 véletlenszerű titkos kulcsot, és szükség esetén további kulcsokat generál. Mindegyik kulcsot csak egyszer használja. Az ilyen pénztárcát úgy is hívják, hogy „csak egy halom kulcs”. A determinisztikus pénztárcák váltják föl őket, mert nagyon nehézkes a kezelésük, a kulcsok mentése és beimportálása. A véletlenszerűen generált kulcsoknak az a hátránya, hogy ha sok ilyet állítunk elő, akkor mindegyikről másolatot kell keszítenünk, ami azt jelenti, hogy a pénztárcát gyakran kell mentenünk. Mindegyik kulcsról biztonsági másolatot kell készítenünk, mert ha a pénztárca hozzáférhetetlenné válik, akkor a kulcs által kontrollált pénz örökre elvész. Ez közvetlenül ellentmond annak az alapelvnek, hogy a címeket ne használjuk föl újra, vagyis hogy mindegyik bitcoin címet csak egy tranzakcióra használjunk. A cím újbóli felhasználása csökkenti a titkosságot, mivel kapcsolatba hozza egymással a tranzakciókat és a címeket. A 0. típusú pénztárca emiatt gyenge választás, különösen akkor, ha szeretnénk elekerülni a címek újrafelhasználását, ami azt jelenti, hogy sok kulcs kezelésére és emiatt gyakori mentésre van szükség. A Bitcoin Core kliensben lévő pénztáca 0. típusú, de ennek a használatát a Bitcoin Core fejlesztők aktívan ellenjavallják. A <a href="#Type0_wallet">[Type0_wallet]</a> egy nem determinisztikus pénztárcát ábrázol, amely véletlenszerűen generált kulcsok gyűjteménye.</p></div>
</div>
<div class="sect3">
<h4 id="_determinisztikus_magot_használó_pénztárcák">Determinisztikus (magot használó) pénztárcák</h4>
<div class="paragraph"><p>A determinsiztikus, vagy másképpen „magot használó” pénztárcák olyan pénztárcák, melyekben a titkos kulcsokat egy egyirányú hash függvénnyel egy közös magból állítják elő. A mag egy véletlenszerűen generált szám, melyből más adatokkal, pl egy index számmal vagy „lánc kóddal” kombinálva állítják elő a titkos kulcsokat (lásd <a href="#hd_wallets">[hd_wallets]</a>). Egy determinisztikus pénztárca esetén a mag ismeretében az össze származtatott kulcs visszanyerhető, emiatt csupán egyetlen egy biztonsági másolat készítésére van szükség. A mag a pénztárca exportjához vagy importjához is elégséges, ezért a felhasználó összes kulcsa könnyen átköltöztethető egy tetszőleges másik pénztárcába.</p></div>
<div class="imageblock" id="Type0_wallet">
<div class="content">
<img src="images/msbt_0408.png" alt="non-deterministic wallet" />
</div>
<div class="title">Figure 8. 0. típusú, nem determinisztikus (véletlen) pénztárca: véletlenszerűen generált kulcsok gyűjteménye</div>
</div>
</div>
<div class="sect3">
<h4 id="mnemonic_code_words">Mnemonikok</h4>
<div class="paragraph"><p>A mnemonikok olyan szóláncok, melyek egy determinisztikus pénztárca magját alkotó véletlen számnak felelnek meg. A szólánc elégséges a mag újbóli előállítására, ezáltal a pénztárca és a származtatott kulcsok újbóli létrehozására. Az olyan pénztárca program, amely mnemonikokat használ, a pénztárca létrehozásakor 12 – 24 szót jelenít meg a felhasználónak. Ezek a szavak jelentik a pénztárca mentését, és segítségükkel  egy azonos típusú vagy egy kompatibilis pénztárca programban az összes kulcs visszaállítható. A mnemonikok megkönnyítik a pénztárcák mentését, mert egy véletlen számnál sokkal könnyebben olvashatók és rögzíthetők.</p></div>
<div class="paragraph"><p>A mnemonikokat a  Bitcoin Improvement Proposal 39 definiálja (lásd <a href="#bip0039">[bip0039]</a>), ami jelenleg még csak „tervezet”. A BIP0039 csak javaslat, nem szabvány. Például az Electrum pénztárca egy BIP0039 előtti másik mnemonik halmazt és egy másik szabványt használ. A Trezor és néhány másik pénztárca BIP0039-et használja, de ez nem kompatibilis az Electrum-mal.</p></div>
<div class="paragraph"><p>A BIP0039 a mnemonikok és a mag létrehozását a következőképpen definiálja:</p></div>
<div class="paragraph"><p>1 Hozzunk létre egy 128 .. 256 bites véletlen sorozatot (entrópiát)
2. Készítsük el a véletlen sorozat ellenőrző összegét oly módon, hogy vesszük az SHA256 hash-ének első néhány bitjét
3. Adjuk hozzá ezt az ellenőrző összeget a véletlen sorozat végéhez
4. Osszuk a sorozatot 11 bites részekre, melyek egy 2048 szavas, előre definiált szótár indexelésére szolgálnak.
5. Állítsuk elő a 12 – 24 szóból álló mnemonikot.</p></div>
<div class="paragraph"><p>A <a href="#table_4-5">[table_4-5]</a> a mnemonikok hossza és az entrópia mérete közötti összefüggést szemlélteti</p></div>
<div class="tableblock" id="table_4-5">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 5. Mnemonikok: Entrópia és szóhossz</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="left" valign="top">Entrópia (bitek) </th>
<th align="left" valign="top"> Ellenőrző összeg (bitek) </th>
<th align="left" valign="top"> Entrópia+Ellenőrző összeg </th>
<th align="left" valign="top"> Szóhossz</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">128</p></td>
<td align="left" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table">132</p></td>
<td align="left" valign="top"><p class="table">12</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">160</p></td>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">165</p></td>
<td align="left" valign="top"><p class="table">15</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">192</p></td>
<td align="left" valign="top"><p class="table">6</p></td>
<td align="left" valign="top"><p class="table">198</p></td>
<td align="left" valign="top"><p class="table">18</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">224</p></td>
<td align="left" valign="top"><p class="table">7</p></td>
<td align="left" valign="top"><p class="table">231</p></td>
<td align="left" valign="top"><p class="table">21</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">256</p></td>
<td align="left" valign="top"><p class="table">8</p></td>
<td align="left" valign="top"><p class="table">264</p></td>
<td align="left" valign="top"><p class="table">24</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>A mnemonikok a 128 .. 256 bitnek felelnek meg. Ezekből egy PBKDF2 kulcs-kiszélesítő függvénnyel egy hosszabb (512 bites) magot állítanak elő. Az így kapott magot használják a determinisztikus pénztárca és az összes származtatott kulcs létrehozására.</p></div>
<div class="paragraph"><p>A <xref linkend="table_4-6" xrefstyle="select: labelnumber"/> éa <xref linkend="table_4-7" xrefstyle="select: labelnumber"/> táblázatok a mnemonikokra és az általuk előállított magokra mutatnak néhány példát.</p></div>
<div class="tableblock" id="table_4-6">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 6. 128 bites entrópiájú mnemonik és a belőle kapott mag</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Entrópia (128 bit)</strong></p></td>
<td align="left" valign="top"><p class="table">0c1e24e5917779d297e14d45f14e1a1a</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mnemonik (12 szó)</strong></p></td>
<td align="left" valign="top"><p class="table">army van defense carry jealous true garbage claim echo media make crunch</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mag  (512 bit)</strong></p></td>
<td align="left" valign="top"><p class="table">3338a6d2ee71c7f28eb5b882159634cd46a898463e9d2d0980f8e80dfbba5b0fa0291e5fb88
8a599b44b93187be6ee3ab5fd3ead7dd646341b2cdb8d08d13bf7</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="table_4-7">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 7. 256 bites entrópiájú mnemonik és a belőle kapott mag</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Entrópia (256 bit)</strong></p></td>
<td align="left" valign="top"><p class="table">2041546864449caff939d32d574753fe684d3c947c3346713dd8423e74abcf8c</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mnemonik (24 szó)</strong></p></td>
<td align="left" valign="top"><p class="table">cake apple borrow silk endorse fitness top denial coil riot stay wolf
luggage oxygen faint major edit measure invite love trap field dilemma oblige</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mag (512 bit)</strong></p></td>
<td align="left" valign="top"><p class="table">3972e432e99040f75ebe13a660110c3e29d131a2c808c7ee5f1631d0a977fcf473bee22
fce540af281bf7cdeade0dd2c1c795bd02f1e4049e205a0158906c343</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="hd_wallets">Hierarchikus determinisztikus pénztárcák (BIP0032/BIP0044)</h4>
<div class="paragraph"><p>A determinisztikus pénztáráckat azért fejlesztették ki, hogy könnyű legyen egy "magból" sok kulcsot előállítani. A determinisztikus pénztárcák legfejlettebb fajtája a <em>hierarchikus determinisztikus pénztárca</em>, azaz a <em>HD pénztárca</em>, melyet a BIP0032 szabvány definiál. A hierarchikus determinisztikus pénztárcákban a kulcsok fa szerkezetet alkotnak, ahol egy szülő kulcsból számos gyermek kulcs állítható elő. A gyermek kulcsok mindegyikéből "unoka" kulcsok, és így tovább, a végtelenségig. Ez a fa szerkezet látható a  <a href="#Type2_wallet">[Type2_wallet]</a> ábrán. .</p></div>
<div class="imageblock" id="Type2_wallet">
<div class="content">
<img src="images/msbt_0409.png" alt="HD wallet" />
</div>
<div class="title">Figure 9. 2. típusú hierarchikus determinisztikus pénztárca: egyetlen magból kulcsok fája áll elő</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Az újonnan kifejlesztett bitcoin pénztárcák HD pénztárcák, melyek megfelelnek a BIP0032 és BIP0044 szabványoknak.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>A HD pénztárcáknak két nagy előnyük van a véletlenszerű (nem determinisztikus) kulcsokkal szemben. Az első az, hogy a fa szerkezethez további jelentés rendelhető hozzá, pl. az egyik ágon lévő kulcsok használhatók a bejövő fizetségekhez, míg egy másik a kimenő fizetségekhez tartozó visszajáró pénz kezelésére. A kulcscsoportok egy vállalaton belül különféle osztályoknak, részlegeknek vagy könyvelési kategóriáknak feleltethetők meg,</p></div>
<div class="paragraph"><p>A HD pénztárcák másik előnye  az, hogy a felhasználó anélkül tud nyilvános kulcsokat létrehozni, hogy ehhez szükség lenne a hozzájuk tartozó titkos kulcsokra. Ez lehetővé teszi, hogy a HD pénztárcákat nem biztonságos szervereken is használhassuk pénz fogadásra, és minden egyes tranzakcióhoz egy saját nyilvános kulcsot hozzunk létre. A nyilvános kulcsot nem kell előre betölteni vagy kiszámítani, ugyanakkor a szerveren nem kell, hogy ott legyen a a pénz elköltésére szolgáló titkos kulcs.</p></div>
<div class="sect4">
<h5 id="_hd_pénztárca_létrehozása_egy_magból">HD pénztárca létrehozása egy magból</h5>
<div class="paragraph"><p>A HD pénztárcák egyetlen egy <em>kiinduló magból</em> állíthatók elő. Ez a mag egy 128, 256 vagy 512 bites véletlenszám. A HD pénztárcában minden más ebből a kiinduló magból, determinisztikusan származik, ami lehetővé teszi, hogy bármelyik másik kompatibilis HD pénztárca programban az egész HD pénztárcát újraépítsük. Ez megkönnyíti a kulcsok ezreit vagy millióit tartalmazó HD pénztárcák exportját és importját, mivel egyszerűen csak a kiinduló magot kell exportálni ill. importálni. A kiinduló magot a a könnyű kezelhetőség miatt a leggyakrabban <em>mnemonikkal</em> ábrázolják, lásd az előző <a href="#mnemonic_code_words">[mnemonic_code_words]</a> részben leírtakat.</p></div>
<div class="paragraph"><p>Egy HD pénztárca mesterkulcsainak és lánc kódjainak előállítási folyamatát a <a href="#HDWalletFromSeed">[HDWalletFromSeed]</a> mutatja.</p></div>
<div class="imageblock" id="HDWalletFromSeed">
<div class="content">
<img src="images/msbt_0410.png" alt="HDWalletFromRootSeed" />
</div>
<div class="title">Figure 10. Mesterkódok és lánc kód előállítása a kiinduló magból</div>
</div>
<div class="paragraph"><p>A kiinduló magot a HMAC-SHA512 algoritmus bemeneteként használják, és az eredményként kapott hash-t használják a <em>titkos mesterkulcs</em> (m) és a <em>lánckód</em> előállítására. A nyilvános mesterkulcsot (M) a titkos mesterkulcs (m) segítségével, hagyományos elleptikus szorzással áll elő:  <tt>m * G</tt>, ahogyan azt a fejezet korábbi részében láttuk. A lánc kódot arra a célra szolgál, hogy entrópiát vigyen be abba a függvénybe, amely a szülő kulcsokból a gyermek kulcsokat állítja elő, amint azt a következő részben látni fogjuk.</p></div>
</div>
<div class="sect4">
<h5 id="_titkos_gyermek_kulcsok_előállítása">Titkos gyermek kulcsok előállítása</h5>
<div class="paragraph"><p>A hierarchikus determinisztikus pénztárcák  egy <em>gyermek kulcsok levezetésére szolgáló CKD (child key derivation)</em> függvényt használnak a leszármaztatott kulcsok szülő kulcsokból történő előállítására.</p></div>
<div class="paragraph"><p>A leszármaztatott kulcsok előállítására szolgáló függvény egy egyirányú hash-en alapul, amelyben a következők össze hash-elése történik:</p></div>
<div class="ulist"><ul>
<li>
<p>
A szülő titkos vagy nyilvános kulcsa (ECDSA tömörítetlen kulcs)
</p>
</li>
<li>
<p>
Egy lánckódnak nevezett mag (256 bites)
</p>
</li>
<li>
<p>
Egy index szám (32 bites)
</p>
</li>
</ul></div>
<div class="paragraph"><p>A lánckódot arra a célra szolgál, hogy az eljárásba látszólag véletlen adatot vigyen, vagyis hogy önmagában az index ne legyen elégséges a leszármaztatott kulcsok előállítására. Emiatt ha van egy leszármaztatott kulcsunk, akkor ebből csak akkor tudjuk a további leszármazottakat előállítani, ha a lánckóddal is rendelkezünk. A lánckód kezdeti magja (a fa gyökerénél) véletlen adatból származik, míg az egyes további lánckódok a szülő lánckódjából származnak.</p></div>
<div class="paragraph"><p>A fenti három tétel összekapcsolása és hash-elése a következőképpen történik:</p></div>
<div class="paragraph"><p>A szülő nyilvános kulcsának, lánckódjának és indexszámának összefűzése után a HMAC-SHA512 algoritmussal egy 512 bites hash-t állítanak elő. Ezt a hash értéket két részre vágják. A hash jobb oldali 256 bitje lesz a leszármazott lánckódja. A hash bal oldali 256 bitjét és az indexszámot hozzáadják a szülő titkos kulcsához, és így létrejön a leszármazott titkos kulcsa. A  <a href="#CKDpriv">[CKDpriv]</a> bemutatja, hogy az index 0-ra állításával hogyan lehet a szülő 0-ik (index szerint első) leszármaztatott kulcsát előállítani.</p></div>
<div class="imageblock" id="CKDpriv">
<div class="content">
<img src="images/msbt_0411.png" alt="ChildPrivateDerivation" />
</div>
<div class="title">Figure 11. A szülő titkos kulcsának kiterjesztésével a gyermek titkos kulcsának előállítása</div>
</div>
<div class="paragraph"><p>Az index megváltoztatása lehetővé teszi a szülő kiterjesztését, és további gyermek kulcsok előállítását, pl. Gyermek 0, Gyermek 1, Gyermek 2 stb. Mindegyik szülő kulcshoz 2 milliárd gyermek kulcs tartozik.</p></div>
<div class="paragraph"><p>Ha a folyamatot a fában egy szinttel lejjebb megismételjük, akkor minden egyes gyermekből szülő lesz, és saját gyermekeket hoz létre, végtelen sok generációban.</p></div>
</div>
<div class="sect4">
<h5 id="_a_leszármaztatott_kulcsok_használata">A leszármaztatott kulcsok használata</h5>
<div class="paragraph"><p>A származtatott titkos kulcsokat nem lehet megkülönböztetni a nem determinisztikus (véletlen) kulcsoktól. Mivel a származtató függvény egyirányú, a származtatott kulcsból a szülő kulcs nem állapítható meg. A származtatott kulccsal a további leszármazottak sem kereshetők meg. Ha van egy n-ik kulcsunk, akkor ennek ismeretében sem az n-1-ik, sem az n+1-ik testvérét sem lehet megtalálni, sőt, a sorozat egyik elemét sem. Csak a szülő kulccsal és a lánckóddal lehet a gyermekeket leszármaztatni. A gyermek lánckódja nélkül a a gyermek kulcsokból nem lehetséges az unokák levezetése sem. A gyermek titkos kulcsa és a gyermek lánckódja egyaránt szükséges egy új ág megkezdéséhez és az unoka kulcsok leszármaztatásához.</p></div>
<div class="paragraph"><p>De akkor mire használhatók önmagukban a gyermek titkos kulcsok? Arra, hogy egy nyilvános kulcsot és egy bitcoin címet állítsunk elő velük. Ezt követően pedig arra, hogy a titkos kulcshoz tartozó bitcoin címre küldött tranzakciókat aláírjuk velük, és ily módon elköltsük.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A gyermek kulcs, a hozzá tartozó nyilvános kulcs és a bitcoin cím megkülönböztethetetlen a véletlenszerűen előállított kulcsoktól és címektől. Nem látható rajtuk, hogy egy lánc részei, vagy hogy egy HD pénztárca függvény állította őket elő. A létrejöttük után már pontosan olyanok, mintg egy "normális" kulcs.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect4">
<h5 id="_kiterjesztett_kulcsok">Kiterjesztett kulcsok</h5>
<div class="paragraph"><p>Mint azt már korábban láttuk, a kulcs származtatást végző függvényekkel a fa bármelyik szintjén új leszármazottak (gyermekek) állítható elő. Ehhez három bemenetre van szükség: a kulcsra, a lánckódra, és a kívánt leszármazott indexére. Ezek közül a két legfontosabb a kulcs és a lánckód, és ezeket egy <em>kiterjesztett kulcsba</em> szokták összevonni. A "kiterjesztett kulcs" elnevezés "kibővíthető kulcsot" is jelent, mivel az ilyen kulcsokkal gyermekek állítható elő.</p></div>
<div class="paragraph"><p>A kiterjesztett kulcsok a 256 bites kulcs és a 256 bites lánckód összefűzése révén, egy 512 bites értékkel ábrázolhatók. Kétféle kiterjesztett kulcs van. A kiterjesztett titkos kulcs a titkos kulcs és a lánckód összefűzéséből áll, és a leszármazottak titkos kulcsainak (ezekből pedig a nyilvános kulcsainak) az előállítására használható. A kiterjesztett nyilvános kulcs a nyilvános kulcsból és a lánckódból áll, és a leszármazottak nyilvános kulcsai állíthatók elő vele, amint azt a <a href="#public_key_derivation">[public_key_derivation]</a> részben leírtuk.</p></div>
<div class="paragraph"><p>A kiterjesztett titkos kulcsot úgya képzelhetjük el,  mint a HD pénztárca fa szerkezetének a gyökerét. A gyökér ismeretében a többi ág levezethető. A kiterjesztett titkos kulcccsal egy teljes ág előállítható, míg a kiterjesztett nyilvános kulccsal egy teljes ág nyilvános kulcsai.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A kiterjesztett kulcs egy titkos vagy nyilvános kulcsból és egy lánckódból áll. A kiterjesztett kulccsal leszármazottak állíthatók elő, vagyis a fa szerkezetben a saját ága. Egy kiterjeszett kulcs megosztása az egész ághoz hozzáférést biztosít.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>A kiterjesztett kulcsokat Base58Check kódolással kódolják, hogy könnyű legyen a különféle BIP0032-kompatibilis pénztárcák közötti exportjuk és importjuk. A Base58Check kódolás a kiterjesztett kulcsok esetén egy különleges verziószámot használ, amelyből az "xprv" vagy "xpub" Base58 karakterek jönnek létre a kódolás során.Ezáltal a kiterjesztett kulcsok könnyen felismerhetők. Mivel egy kiterjesztett kulcs 512 vagy 513 bites, emiatt sokkal hosszabb, mint a korábban látott Base58Check kódolású stringek.</p></div>
<div class="paragraph"><p>Íme, egy példa egy Base58Check kódolású kiterjesztett titkos kulcsra:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>xprv9tyUQV64JT5qs3RSTJkXCWKMyUgoQp7F3hA1xzG6ZGu6u6Q9VMNjGr67Lctvy5P8oyaYAL9CAWrUE9i6GoNMKUga5biW6Hx4tws2six3b9c</tt></pre>
</div></div>
<div class="paragraph"><p>És itt a neki megfelelő kiterjesztett nyilvános kulcs, szintén Base58Check kódolásban:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>xpub67xpozcx8pe95XVuZLHXZeG6XWXHpGq6Qv5cmNfi7cS5mtjJ2tgypeQbBs2UAR6KECeeMVKZBPLrtJunSDMstweyLXhRgPxdp14sk9tJPW9</tt></pre>
</div></div>
</div>
<div class="sect4">
<h5 id="public__child_key_derivation">Gyermekek nyilvános kulcsainak leszármaztatása</h5>
<div class="paragraph"><p>Mint azt előzőleg említettük, a hierarchikus determinisztikus pénztárcák nagyon hasznos jellemzője, hogy a gyermekek nyilvános kulcsai <em>anélkül</em> is előállíthatók a szülők nyilvános kulcsaiból, hogy ehhez titkos kulcsokra lenne szükség. Ezért aztán a gyermekek nyilvános kulcsai kétféleképpen is előállíthatók: egyrészt a gyermek titkos kulcsából, másrészt közvetlenül a szülő nyilvános kulcsából.</p></div>
<div class="paragraph"><p>A kiterjesztett nyilvános kulcsből tehát a HD pénztárca egy ágának az összes <em>nyilvános kulcsa</em> (és csak a nyilvános kulcsok) leszármaztathatók.</p></div>
<div class="paragraph"><p>Ezzel a trükkel nagyon biztonságos csak-nyilvános-kulcsokat tartalmazó rendszerek hozhatók létre, ahol a szerver alkalmazásban csak a kiterjeszett nyilvános kulcs másolata van meg, és semmilyen titkos kulcsot sem tartalmaz. Az ilyen rendszerekben végtelen sok  nyilvános kulcs és bitcoin cím hozható létre, de ezekről a címekről nem lehetséges pénzt költeni. A kiterjeszett titkos kulccsal egy másik, biztonságosabb szerveren a nyilvános kulcsoknak megfelelő összes titkos kulcs levezethető, a tranzakcók aláírhatók és a pénz elkölthető.</p></div>
<div class="paragraph"><p>Ennek a megoldásnak az egyik gyakori alkalmazása az, hogy a kiterjesztett nyilvános kulcsot egy web szerveren installálják, amely egy e-kereskedelmi alkalmazást szolgál ki. A web szerver a leszármaztató függvénnyel képes minden tranzakció számára (pl. egy ügyfél bevásárló kosara számára) új bitcoin cím előállítására. A web szerveren nem lesz egyetlen egy titkos kulcs sem, mert azt ellophatják. A HD pénztárcák nélkül csak úgy lehetne bitcoin címek ezreit előállítani, hogy a címeket egy másik, biztonságos szerveren állítják elő, majd betöltik őket az e-kereskedelmi alkalmazásba. Ez sok bonyodalommal járna, és állandó karbantartást igényelne, mert biztosítani kellene, hogy az e-kereskedelmi alkalmazás soha "ne fusson ki" a kulcsokból.</p></div>
<div class="paragraph"><p>A megoldás egy másik gyakori alkalmazását a hideg tárolók vagy a hardver pénztárcák jelentik. Ebben az esetben a kiterjesztett titkos kulcsot egy papír pénztárca vagy egy hardver pénztárca tárolja, ilyen pl. a Terzor harver pénztárca, míg a kiterjesztett nyilvános kulcsot online tartják. A felhasználó tetszés szerint tud "fogadó" címeket létrehozni, míg a titkos kulcsok biztonságos módon, offline vannak tárolva. Az összegek elköltéséhez az szükséges, hogy a felhasználó a kiterjesztett titkos kulccsal egy offline bitcoin kliensben vagy egy hardver eszközzel (pl. a Trezorral) aláírja a tranzakciót. A <a href="#CKDpub">[CKDpub]</a> szemlélteti, hogyan lehetséges a szülő nyilvános kulcs kiterjesztésével a gyermek kulcsok levezetése.</p></div>
<div class="imageblock" id="CKDpub">
<div class="content">
<img src="images/msbt_0412.png" alt="ChildPublicDerivation" />
</div>
<div class="title">Figure 12. A szülő nyilvános kulcs kiterjesztése gyermek kulcsok levezetése céljából</div>
</div>
</div>
<div class="sect4">
<h5 id="_megerősített_gyermek_kulcsok_előállítása">Megerősített gyermek kulcsok előállítása</h5>
<div class="paragraph"><p>Az, hogy egy ág összes nyilvános kulcsa a kiterjesztett nyilvános kulcsból vezethető le, nagyon hasznos, de potenciális veszéllyel is jár. A kiterjesztett nyilvános kulcs alapján a gyermekek titkos kulcsa nem állítható elő. Mivel azonban a kiterjesztett nyilvános kulcs tartalmazza a lánckódot, ezért ha kiszivárog vagy az egyik gyermek titkos kulcsa, akkor ebből a lánc kód ismeretében az összes többi gyermek titkos kulcsa is előállítható. Egyetlen egy kiszivárgott titkos kulcs és a szülő lánckódja az összes gyermek titkos kódját felfedi. Ami még ennél is rosszabb, a gyermek titkos kulcsából és a szülő lánckódjából a szülő titkos kulcsa is megállapítható.</p></div>
<div class="paragraph"><p>Ennek a veszélynek a kivédése érdekében a HD pénztárcák egy alternatív kulcs előállító függvényt használnak, az ún. <em>megerősített kulcs előállítást</em>, amely "megszakítja" a szülő nyilvános kulcsa és a gyermek lánckódja közötti összefüggést. A megerősített kulcs előállító függvény a szülő nyilvános kulcsa helyett a szülő titkos kulcsát használja a gyermek lánckódjának a levezetésére. Ez "tűzfalat" hoz létre a szülő/gyermek sorozatban, és a lánckód a szülő vagy a gyermek titkos kódját már nem tudja kompromittálni. A megerősített kulcs levezető függvény majdnem megegyezik a gyermekek szokásos titkos kulcs levezetési függvényével, kivéve, hogy a hash függvény a szülő nyilvános kulcsa helyett a szülő titkos kulcsát használja, amint azt a  <a href="#CKDprime">[CKDprime]</a> ábra mutatja.</p></div>
<div class="imageblock" id="CKDprime">
<div class="content">
<img src="images/msbt_0413.png" alt="ChildHardPrivateDerivation" />
</div>
<div class="title">Figure 13. Gyermek kulcsok megerősített levezetése, a szülő nyilvános kulcs nem szerepel benne</div>
</div>
<div class="paragraph"><p>Mikor megerősített titkos kulcs származtatás történik, a eredményként kapott titkos kulcs és a lánckód teljesen különbözik a szokásos származtató függvény eredményétől. Az így kapott "ágon" a kulcsokból olyan kiterjesztett nyilvános kulcsok állítható elő, melyek nem támadhatóak, mivel az általuk tartalmazott lánckód alapján semmilyen privát kulcsot sem lehet előállítani. Ennek megfelelően a megerősített származtatást használják arra, hogy a fát "elszigeteljék" a kiterjeszett nyilvános kulcsok szintje fölötti résztől.</p></div>
<div class="paragraph"><p>Egyszerűen aról van szó, hogy ha a kiterjesztett nyilvános kulcsok kínálta kényelmet szeretnénk használni az ágak nyilvános kulcsainak a levezetése során, de nem szeretnénk kitenni magunkat a lánc kód kiszivárgása által okozott veszélynek, akkor a kiterjesztett nyilvános kulcsot egy megerősített szülőből kell létrehoznunk, nem pedig egy szokásos szülőből. A legjobb, ha a mesterkulcs 1. szintű gyermekeit mindig megerősített levezetésel állítjuk elő, mert így meg tudjuk akadályozni a mesterkulcsok kompomittálódását.</p></div>
</div>
<div class="sect4">
<h5 id="_a_szokásos_és_a_megerősített_kulcsképzés_indexszámai">A szokásos és a megerősített kulcsképzés indexszámai</h5>
<div class="paragraph"><p>A kulcs képző függvényben az index szám egy 32 bites egész. Annak érdekében, hogy könnyű legyen megkülönböztetni a szokásos kulcsképzést a megerősített kulcsképzéstől, az indexszámot két tartományra osztották. A 0 és 2<sup>31</sup>–1 (0x0 és 0x7FFFFFFF) közötti indexszámokat <em>kizárólag</em> a szokásos normál kulcsképzésre használják. A  2<sup>31</sup> és 2<sup>32</sup>–1 (0x80000000 és 0xFFFFFFFF) közötti indexszámokat pedig <em>kizárólag</em> a megerősített kulcsképzésre. Ezért, ha az indexszám  2<sup>31</sup> -nél kisebb, akkor a gyermek normál módon lett képezve, míg ha az indexszám 2<sup>31</sup> -nél nagyobb vagy egyenlő, akkor a gyermek megerősített módon lett képezve.</p></div>
<div class="paragraph"><p>Az indexszám könnyeb megjelenítése érdekében a megerősített gyermekek esetén az indexszám kijelzése 0-tól kezdődik, de egy vessző áll mögötte. A szokásos gyermek kulcs kijelzése a 0-tól kezdődik, míg az első megerősített gyermek (melynek indexe 0x80000000) megjelenítése a következő: <markup>0'</markup>. A sorban a következő megerősített kulcs indexe 0x80000001, melynek megjelenítése 1', stb. A HD pénztárcáknál az i' index az jelenti, hogy 2<sup>31</sup>+i.</p></div>
</div>
<div class="sect4">
<h5 id="_a_hd_pénztárca_kulcs_azonosítója_útvonal">A HD pénztárca kulcs azonosítója (útvonal)</h5>
<div class="paragraph"><p>A HD pénztárcák kulcsait egy "útvonal" azonosítja, amelyben mindegyik szintet egy per jel (/) választja el egymástól (lásd a <a href="#table_4-8">[table_4-8]</a> táblázatot).  A titkos mesterkulcsból levezetett titkos kulcsok az "m" betűvel kezdődnek. A nyilvános mesterkulcsból levezetett nyilvános kulcsok az "M" betűvel kezdődnek. Ennek megfelelően a titkos mesterkulcs első gyermeke az m/0. A nyilvános kulcs első gyermeke az M/0. Az első gyermek második unokája az m/0/1, és így tovább.</p></div>
<div class="paragraph"><p>Egy kulcs "ősei" jobbról balra olvashatók ki, amíg el nem jutunk ahhoz a mesterkulcshoz, amelyből a kulcs származik. Például az m/x/y/z azonosító azt a kulcsot jelenti, amely az m/x/y kulcs z-ik gyermeke, ahol az y az m/x y-ik gyermeke, ahol az x az m x-ik gyermeke.</p></div>
<div class="tableblock" id="table_4-8">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 8. Példák HD pénztárca útvonalakra</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">HD útvonal </th>
<th align="left" valign="top"> Kulcs leírása</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">m/0</p></td>
<td align="left" valign="top"><p class="table">A titkos mesterkulcsból (m) származó első (0) leszármazott titkos kulcsa.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/0/0</p></td>
<td align="left" valign="top"><p class="table">Az első gyermek (m/0) első unokája</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/0'/0</p></td>
<td align="left" valign="top"><p class="table">Az első <em>megerősített</em> gyermek kulcs (m/0') első normális unokája</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/1/0</p></td>
<td align="left" valign="top"><p class="table">A második gyermek  (m/1) első unokájának titkos kulcsa</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">M/23/17/0/0</p></td>
<td align="left" valign="top"><p class="table">A 24-ik gyermek 18-ik unokájának első dédunokájához tartozó nyilvános kulcs</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_navigálás_a_hd_pénztárca_fa_struktúrájában">Navigálás a HD pénztárca fa struktúrájában</h5>
<div class="paragraph"><p>A HD pénztárcák fa szerkezete hihetetlenül rugalmas. Mindegyik szülő kulcsnak 4 milliárd gyermeke lehet: 2 milliárd normális gyermeke ls a 2 milliárd megerősített gyermeke. Ezen gyermekek mindegyikének szintén 4 milliárd gyermeke lehet, és így tovább. A fa olyan mély lehet, amilyen mélyet szeretnénk, és végtelen sok generációt tartalmazhat. A rugalmassággal azonban együtt jár az is, hogy egészen nehéz ebben a végtelen fában a navigálás. Különösen nehéz a HD pénztárcák különféle implementációk közötti átmozgatása, mivel az ágak belső felépítésére végtelen sok lehetsőség van.</p></div>
<div class="paragraph"><p>A Bitcoin Javítására tett Javaslatok (Bitcoin Improvement Proposals (BIP-ek) megoldást nyújtanak erre a problémára: szabványos fa szerkezeteket javasolnak a HD pénztárcák felépítésére. A BIP0043 azt javasolja, hogy az első megerősített gyermek indexét különleges azonosító gyanánt használják, amely a fa szerkezet "célját" adja meg. A BIP0043 alapján a HD pénztárcáknak csak a fa 1-szintű ágait szabad használnia, ahol a cél definiálása révén az index szám azonosítja a fa további részének névterét és szerkezetét. Például egy HD pénztárca, amely csak az m/i'/ ágat használja, egy adott célra szolgál, és ezt a célt az "i" index szám adja meg.</p></div>
<div class="paragraph"><p>A BIP0044 ennek a specifikációnak a kiterjesztésével egy többszörös számla szerkezetet javasol, melynek "célját" a BIP0043 alatt a <tt>44'</tt> adja meg. Az összes, BIP0044 szerkezetnek megfelelő pénztárcát az azonosítja, hogy a fának csak egyetlen ágát használja: m/44'/.</p></div>
<div class="paragraph"><p>A BIP0044 definíciója szerint a fa szerkezet öt, előre definált szintből áll:</p></div>
<div class="paragraph"><p><tt>m / cél' / érme_típus' / számla' / visszajáró / cím_index</tt></p></div>
<div class="paragraph"><p>Az első szinten lévő "cél" értéke mindig <tt>44'</tt>.  A második szinten lévő "érme típus" a digitális pénzt fajtáját határozza meg, és ily módon több pénznem kezelését is lehetővé teszi egy HD pénztárcában: minden pénznemnek saját al-fája van a második szinten. Jelenleg három pénznem van definiálva: a Bitcoin az m/44'/0', Bitcoin Testnet az <markup>m/44'/1'</markup>; a Litecoin pedig az <markup>m/44'/2'</markup>.</p></div>
<div class="paragraph"><p>A fa harmadik szintjét a "számla" alkotja, amely lehetővé teszi, hogy a felhasználók a pénztárcáikat logikailag különálló al-számlákra osszák, pl. könyvelési vagy szervezeti szempontok alapján. Például egy HD pénztárca az alábbi két "számlát" tartalmazhatja:  <markup>m/44'/0'/0'</markup> és <markup>m/44'/0'/1'</markup>. Mindegyik számla a saját rész-fájának a gyökerét alkotja.</p></div>
<div class="paragraph"><p>A negyedik szinten, a "visszajáró" pénz szintjén a HD pénztárcáknak két al-fája van: az egyik a fogadó címek, a másik a visszajáró pénz számára. Figyeljék meg, hogy míg az előző szintek megerősített kulcs származtatást használtak, ez a szint normál származtatást használ. Ez lehetővé teszi az ezen a szinten lévő kiterjesztett nyilvános kulcsok exportját, és nem fokozott biztonságú környezetben történő használatát. A HD pénztárca a használható címeket a negyedik szint gyermekeiként definiálja, vagyis a fa ötödik szintjéből lesz a "cím index". Például a fő számla harmadik fogadó címe az lesz, hogy  M/44'/0'/0'/0/2. A <a href="#table_4-9">[table_4-9]</a> néhány további példát mutat.</p></div>
<div class="tableblock" id="table_4-9">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 9. Példák a BIP0044 HD pénztárca szerkezetre</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">HD útvonal </th>
<th align="left" valign="top"> Kulcs leírása</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">M/44'/0'/0'/0/2</p></td>
<td align="left" valign="top"><p class="table">A fő bitcoin számla harmadik nyilvános fogadó kulcsa</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">M/44'/0'/3'/1/14</p></td>
<td align="left" valign="top"><p class="table">A negyedik bitcoin számla visszajáró pénz kezelésre szolgáló 15-ik nyilvános kulcsa</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">m/44'/2'/0'/0/1</p></td>
<td align="left" valign="top"><p class="table">Egy Litecoin főszámla tranzakciók aláírására szolgáló második titkos kulcsa</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_bitcoin_explorer_rel_végzett_kísérletk_hd_pénztárcákkal">Bitcoin Explorer-rel végzett kísérletk HD pénztárcákkal</h5>
<div class="paragraph"><p>A <a href="#ch03_bitcoin_client">[ch03_bitcoin_client]</a> részben bevezetett Bitcoin Explorer parancssori eszközzel különféle kísérleteket végezhetünk BIP0032 determinisztikus kulcsok előállítására és kiterjesztésére vonatkozóan, valamit különféle formátumokban tudjuk megjeleníteni őket : </p></div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_kódolt_titkos_kulcsok_bip0038">Kódolt titkos kulcsok (BIP0038)</h3>
<div class="paragraph"><p>A következő részben kulcsok és címek egyéb fajtáira fogunk példákat látni, pl. a kódolt (titkosított) titkos kulcsoka, script és multi-sig címekre, kérkedő címekre, valamint papír pénztárcákra.</p></div>
<div class="sect3">
<h4 id="_titkosított_kódolt_titkos_kulcsok_bip0038">Titkosított (kódolt) titkos kulcsok (BIP0038)</h4>
<div class="paragraph"><p>A titkos kulcsoknak titokban kell maradniuk. A titkos kulcsok <em>bizalmas</em> volta olyan evidencia, amelyet a gyakorlatban egészen nehéz megvalósítni, mivel ütközik egy ugyanilyen fontos biztonsági céllal, a <em>rendelkezésre állással</em>. A titkos kulcsok titokban tartása sokkal nehezebb, ha a titkos kulcsokról biztonsági másolatokat kell tárolni, nehogy elveszítsük őket. A pénztárcákban lévő, jelszóval védett titkos kulcsok biztonságban vannak, de a pénztárcáról biztonsági másolatot kell készíteni. Néha a felhasználók az egyik pénztárcából a másikba mozgatják át kulcsokat – például a pénztárca program újabb változatának installálásakor vagy egy másik programra való lecserélésekor. A titkos kulcsokról készített biztonsági mentések papíron (lásd a <a href="#paper_wallets">[paper_wallets]</a> részt) vagy külső tároló eszközön, pl. USB kulcson is tárolhatók. De mi történik, ha a másolatot ellopják vagy elveszítjük? Ezek az egymásnak ellentmondó biztonsági követelmények vezettek egy hordozható és kényelmes szabvány, a BIP0038 létrejöttéhez (lásd <a href="#bip0038">[bip0038]</a>), mellyel a titkos kulcsok úgy titkosíthatók, hogy sok különféle pénztárca és bitcoin kliens megértse őket. (lásd [BIP0038]).</p></div>
<div class="paragraph"><p>A BIP0038 szabvány a titkos kulcsok jelmondattal történő titkosításáról, és Base58Check kódolásáról szól. Célja az, hogy a titkos kulcsok biztonságosan tárolhatók legyenek a mentő eszközön, és átvihetők legyenek a pénztárcák között, vagy olyan körülmények között is kezelhetők legyenek, ahol a kulcs nyilvánosságra kerülhet. A BIP0038 titkosítási szabvány az AES-t (Advanced Encryption Standard) használja, melyet az Amerikai Szabványügyi Hivatal (NIST, National Institute of Standards and Technology) fogadott el, és széles körben használják kereskedelmi és katonai alkalmazásokban.</p></div>
<div class="paragraph"><p>A BIP0038 titkosítás esetén a titkos kulcsból indulunk ki, amely általában Base58Check string formájában, „5” előtaggal, WIF formátumban (Wallet Import Format, pénztárca inport formátum) van kódolva. Ezen kívül a BIP0038 titkosításnak egy jelmondatra – egy hosszú jelszóra – van szüksége, amely általában számos szóból vagy egy bonyolult alfanumerikus karakterláncból áll. A BIP0038 titkosítás eredménye egy olyan Bas58Check kódolású titkos kulcs, amely a <tt>6P</tt> előtaggal kezdődik. Ha egy olyan kulccsal találkoznak, amely <tt>6P</tt>-vel kezdődik, az azt jelenti, hogy a kulcs kódolt, és egy jelmondatra van szükség ahhoz, hogy WIF-formátumú titkos kulccsá tudjuk visszaalakítani (visszakódolni), amely <tt>5</tt>-tel kezdődik, és bármelyik pénztárcában használható. Sok pénztárca alkalmazás felismeri a BIP0038 kódolású titkos kulcsokat. Ezek a kulcs dekódolása és importálása céljából megkérdezik a felhasználótól, hogy mi a jelmondat. Vannak egyéb alkalmazások, pl. a hihetetlenül hasznos web böngésző alapú  <a href="http://bitaddress.org">Bit Address</a>, amellyel (a „pénztárca részletei” fülön) szintén elvégezhető a BIP0038 kulcsok dekódolása.</p></div>
<div class="paragraph"><p>A BIP0038 titkosított kulcsokat leggyakrabban a papír pénztárcák esetén alkalmazzák. A papír pénztárcákkal a titkos kulcsok egy papírlapon tárolhatók. Ha a felhasználó egy erős jelmondatot választ, a BIP0038 kódolt papír pénztárcák nagyon biztonságosak, és kiválóan alkalmasan arra, hogy egy offline bitcoin tárolót hozzunk létre (ezeket „hideg tárolónak” (cold storage) is hívják).</p></div>
<div class="paragraph"><p>A <a href="#table_4-10">[table_4-10]</a> táblázatban látható kódolt kulcsok a bitaddress.org-gal lettek előállítva, és az szemléltetik, hogyan lehet a kulcsot a jelmondat beadásával dekódolni:</p></div>
<div class="tableblock" id="table_4-10">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 10. Példa egy BIP0038 kódolt titkos kulcsra</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Titkos kulcs (WIF)</strong></p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Jelmondat</strong></p></td>
<td align="left" valign="top"><p class="table">MyTestPassphrase</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>A titkosított kulcs (BIP0038)</strong></p></td>
<td align="left" valign="top"><p class="table">6PRTHL6mWa48xSopbU1cKrVjpKbBZxcLRRCdctLJ3z5yxE87MobKoXdTsJ</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect3">
<h4 id="p2sh_addresses">Fizetés script hashnek (P2SH, pay to script hash) címek és több aláírást megkövetelő (multi-sig) címek</h4>
<div class="paragraph"><p>Mint tudjuk, a hagyományos bitcoin címek „1”-gyel kezdődnek, és a nyilvános kulcsból származnak, a nyilvános kulcs pedig a titkos kulcsból. Az „1”-gyel kezdődő címekre bárki küldhet bitcoint, de csak az tudja elkölteni, aki be tudja mutatni a titkos kulccsal létrehozott megfelelő aláírást és a nyilvános kulcs zanzáját.</p></div>
<div class="paragraph"><p>A „3”-mal kezdődő bitcoin címek fizetés-script-hashnek (P2SH) bitcoin címek, melyeket néha hibásan több aláírást megkövetelő, vagy multi-sig címeknek hívnak. A bitcoin tranzakció kedvezményezettjét a script hash-ével, nem pedig a nyilvános kulcs tulajdonosával adják meg. Ezt az újítást 2012. januárjában, a BIP0016 keretében vezették be (lásd <a href="#bip0016">[bip0016]</a>). Az újítás széles körben elterjedt, mert lehetővé teszi, hogy magához a címhez legyen hozzárendelve valamilyen funkcionalitás. A hagyományos, „1” kezdetű bitcoin címeket használó tranzakciók neve fizetés-nyilvános-kulcs-hashnek (P2PKH, pay-to-public-key-hash). Ezekkel a hagyományos tranzakciókkal szemben, a „3” kezdetű címekre küldött pénzek esetében nem csak egy nyilvános kulcs hashének bemutatására és a tulajdonjogot bizonyító, titkos kulccsal történő aláírására van szükség. A követelmények meghatározása a cím létrehozásakor történik. A cím a hozzá tartozó összes bemenetet ugyanolyan módon korlátozza.</p></div>
<div class="paragraph"><p>A fizetés-script-hashnek címet egy tranzakciós scriptből hozzák létre. Ez a tranzakció határozza meg, hogy ki költheti el a tranzakció kimenetét (részletesebben lásd a<a href="#p2sh">[p2sh]</a> részt). A fizetés-scrip-hashnek cím kódolásához ugyanúgy a kettős hash függvényt kell használni, mint a hagyományos bitcoin címeknél, de a nyilvános kulcs helyett a scripten kell a műveletet elvégezni:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>script hash = RIPEMD160(SHA256(script))</tt></pre>
</div></div>
<div class="paragraph"><p>Az eredményként kapott „script hash”-tBase58Check segítségével,  „5” verzió előtaggal kódolják, ami egy <tt>3</tt>-mal kezdődő címet eredményez. Pl. egy P2SH cím: <tt>32M8ednmuyZ2zVbes4puqe44NZumgG92sM</tt>, amelyet a Bitcoin Explorer következő parancsaival lehet előállítani:  <tt>script-encode</tt>, <tt>sha256</tt>, <tt>ripemd160</tt>, és <tt>base58check-encode</tt> (lásd <a href="#libbitcoin">[libbitcoin]</a>). A parancsok a következőképpen használhatók:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ echo dup hash160 [ 89abcdefabbaabbaabbaabbaabbaabbaabbaabba ] equalverify checksig &gt; script
$ bx script-encode &lt; script | bx sha256 | bx ripemd160 | bx base58check-encode --version 5
3F6i6kwkevjR7AsAd4te2YB2zZyASEm1HM</tt></pre>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>A P2SH nem feltétlenül egyezik meg egy több aláírást megkövetelő, szabványos multi-sig tranzakcióval. A P2SH <em>leggyakrabban</em> egy multi-sig scriptnek felel meg, de más tranzakciótípusok scriptjeit is ábrázolhatja.</p></div>
</td>
</tr></table>
</div>
<div class="sect4">
<h5 id="_multi_signature_címek_és_p2sh">Multi-signature címek és P2SH</h5>
<div class="paragraph"><p>Jelenleg a P2SH függvényt a leggyakrabban a multi-sig script esetén alkalmazzák. Mint a multi-sig script neve is mutatja, a tulajdonjog igazolásához és a pénz elköltéséhez egynél több aláírást követel meg. A bitcoin multi-sig N kulcs esetén M aláírást követel meg. Ennek M-of-N multi-sig a neve, ahol M kisebb vagy egyenlő, mint N. például, Bob, az  <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a> részben megismert kávéház tulajdonos használhat olyan 1-of-2 multi-sig címeket, amelyeknél az egyik kulcs az övé, a másik a feleségéé, vagyis mindketten el tudják költeni az ilyen címeken lévő zárolt tranzakció kimeneteket. Ez hasonlít a hagyományos bankok "közös számlájához",  ahol a számlatulajdonosok bármelyike egyedül is képes számlaműveleteket végezni. Gopesh-nek, a web tervezőnek, aki Bob web helyét tervezte, lehet viszont egy 2-of-3 multi-sig címe az üzleti vállalkozásához, ami biztosítja, hogy a címről csak akkor lehet pénzt költeni, ha az üzlettársak közül legalább kettő aláírja a tranzakciót.</p></div>
<div class="paragraph"><p>A <a href="#transactions">[transactions]</a> részben fogjuk megvizsgálni, hogyan lehet P2SH tranzakciókat létrehozni és hogyan lehet P2SH tranzakciókról pénzt költeni.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="_kérkedő_címek">Kérkedő címek</h4>
<div class="paragraph"><p>A kérkedő címek olyan bitcoin címek, melyek olvasható üzeneteket tartalmaznak, péládul az <tt>1LoveBPzzD72PUXLzCkYAtGFYmK5vYNR33</tt> egy olyan érvényes cím, amely a „Love” (szeret) szót tartalmazza az „1” utáni négy Base-58 betűn. A kérkedő címekhez titkos kulcsok milliárdjait kell generálni és tesztelni, amíg a származtatott bitcoin címben létre nem jön a kívánt minta. Noha a kérkedő címet előállító algoritmusban vannak optimalizálások, a folyamat alapjában véve annak felel meg, hogy véletlenszerűen választunk egy titkos kulcsot, előállítjuk belőle a nyilvános kulcsot, ebből pedig a bitcoin címet, és leellenőrizzük, hogy megfelel-e a kívánt mintának – mindezt milliárdnyiszor megismételve, amíg sikerrel nem járunk.</p></div>
<div class="paragraph"><p>Ha találtunk egy kérkedő címet, amely megfelel a kívánt mintának, akkor a titkos kulcs épp úgy használható, mint bármely más címnél. A kérkedő címek épp olyan biztonságosak, mint a többi bitcoin cím. Ugyanaz az elliptikus görbékkel történő titkosítás (ECC, Elliptic Curve Cryptography) és biztonságos hash algoritmus (SHA, Secure Hash Algorithm) van mögöttük, mint bármely más cím mögött. Egy adott mintával rendelkező kérkedő címnél sem lehet könnyebben megtalálni a titkos kulcsot, mint bármely más cím esetén.</p></div>
<div class="paragraph"><p>Az <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a> fejezetben találkoztunk Eugéniával, aki egy gyermek-védelmi alap vezetője a Fülöp-szigeteken. Tegyük fel, hogy Eugénia egy bitcoin gyűjtést szervez, és a nagyobb reklám érdekében szeretne a gyűjtéshez egy kérkedő bitcoin címet használni. Eugénia egy olyan kérkedő címet fog létrehozni, amely úgy kezdődik, hogy „1Kids”, ezzel is elősegítve a gyűjtést a gyerekek számára. Vizsgáljuk meg, hogyan hozható létre ez a kérkedő cím, és mit jelent mindez Eugénia gyűjtésének a biztonsága szempontjából.</p></div>
<div class="sect4">
<h5 id="_kérkedő_címek_előállítása">Kérkedő címek előállítása</h5>
<div class="paragraph"><p>Fontos megértenünk, hogy a bitcoin cím egyszerűen csak egy szám, amely az Base-58 ábécé szimbólumaival van ábrázolva. Az „1Kids” minta keresése az <tt>1Kids11111111111111111111111111111</tt> és az <tt>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</tt> között történhet. Kb. 58<sup>29</sup> (kb. 1.4 * 10<sup>51</sup>) ilyen cím van ebben a tartományban, és ezek mindegyike úgy kezdődik, hogy „1Kids”. A <a href="#table_4-11">[table_4-11]</a> táblázatban látható az „1Kids” kezdető címek címtartománya.</p></div>
<div class="tableblock" id="table_4-11">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 11. Az „1Kids” kezdetű kérkedő címek tartománya</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Mettől</strong></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kids11111111111111111111111111111</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kids11111111111111111111111111112</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kids11111111111111111111111111113</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"></p></td>
<td align="left" valign="top"><p class="table"><tt>&#8230;</tt></p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Meddig</strong></p></td>
<td align="left" valign="top"><p class="table"><tt>1Kidszzzzzzzzzzzzzzzzzzzzzzzzzzzzz</tt></p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Tekintsük úgy az „1Kids” mintát, mint egy számot, és nézzük meg, milyen gyakran található meg ez a minta egy bitcoin címben (lásd <a href="#table_4-12">[table_4-12]</a>). Egy átlagos asztali számítógéppel, melyben nincs semmilyen célhardver, másodpercenként kb. 100 000 kulcs vizsgálható meg.</p></div>
<div class="tableblock" id="table_4-12">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 12. Egy kérkedő cím minta (1KidsCharity) előfordulási gyakorisága és a megtalálásához szükséges idő egy asztali számítógépen</caption>
<col width="25%" />
<col width="25%" />
<col width="25%" />
<col width="25%" />
<thead>
<tr>
<th align="left" valign="top"> Hossz </th>
<th align="left" valign="top"> Minta </th>
<th align="left" valign="top"> Gyakoriság </th>
<th align="left" valign="top"> Átlagos keresési idő</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">1</p></td>
<td align="left" valign="top"><p class="table">1K</p></td>
<td align="left" valign="top"><p class="table">58-ból 1</p></td>
<td align="left" valign="top"><p class="table">&lt; 1 millisec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">2</p></td>
<td align="left" valign="top"><p class="table">1Ki</p></td>
<td align="left" valign="top"><p class="table">3364-ből 1</p></td>
<td align="left" valign="top"><p class="table">50 millisec</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">3</p></td>
<td align="left" valign="top"><p class="table">1Kid</p></td>
<td align="left" valign="top"><p class="table">195&#8217;000-ből 1</p></td>
<td align="left" valign="top"><p class="table">&lt; 2 mp</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4</p></td>
<td align="left" valign="top"><p class="table">1Kids</p></td>
<td align="left" valign="top"><p class="table">11 millióból 1</p></td>
<td align="left" valign="top"><p class="table">1 perc</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">5</p></td>
<td align="left" valign="top"><p class="table">1KidsC</p></td>
<td align="left" valign="top"><p class="table">656 millióból 1</p></td>
<td align="left" valign="top"><p class="table">1 óra</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">6</p></td>
<td align="left" valign="top"><p class="table">1KidsCh</p></td>
<td align="left" valign="top"><p class="table">38 milliárdból 1</p></td>
<td align="left" valign="top"><p class="table">2 nap</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">7</p></td>
<td align="left" valign="top"><p class="table">1KidsCha</p></td>
<td align="left" valign="top"><p class="table">2.2 billióból 1</p></td>
<td align="left" valign="top"><p class="table">3–4 hónap</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">8</p></td>
<td align="left" valign="top"><p class="table">1KidsChar</p></td>
<td align="left" valign="top"><p class="table">128 billióból 1</p></td>
<td align="left" valign="top"><p class="table">13–18 év</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">9</p></td>
<td align="left" valign="top"><p class="table">1KidsChari</p></td>
<td align="left" valign="top"><p class="table">7000 billióból 1</p></td>
<td align="left" valign="top"><p class="table">800 év</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">10</p></td>
<td align="left" valign="top"><p class="table">1KidsCharit</p></td>
<td align="left" valign="top"><p class="table">0.4 trillióból 1</p></td>
<td align="left" valign="top"><p class="table">46&#8217;000 év</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">11</p></td>
<td align="left" valign="top"><p class="table">1KidsCharity</p></td>
<td align="left" valign="top"><p class="table">23 trillióból 1</p></td>
<td align="left" valign="top"><p class="table">2.5 millió év</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Mint látható, Eugénia nem fogja tudni az „1KidsCharity” címet belátható idő alatt létrehozni, még akkor sem, ha sok ezer számítógépet használ. Minden egyes további karakter 58-szorosára növeli a nehézséget. A hét karakternél hosszabb mintákat általában speciális hardverrel, pl. erre a célre összeépített asztali számítógépekkel keresik, melyekben több grafikus feldolgozó egység (GPU-k)")))(GPU, Graphical Processing Unit) található. Ezek általában olyan újrahasznosított bitcoin bányász „platformok”, melyek bitcoin bányászatra már gazdaságtalanok, de a kérkedő címek keresésére még hatékonyan használhatók. A GPU-val rendelkező rendszereken a kérkedő címek keresése sok nagyságrenddel gyorsabb lehet, mint egy általános célú CPU-n.</p></div>
<div class="paragraph"><p>Kérkedő címek úgy is előállíthatók, hogy megbízást adunk egy bányász közösségnek, amely ilyen címek keresésére szakosodott, lásd pl. a <a href="http://vanitypool.appspot.com">Vanity Pool</a> web címet. Ez a bányatársaság a GPU hardverrel rendelkező tagok számára lehetővé teszi, hogy a kérkedő címek keresése révén bitcoinokhoz jussanak. Egy kis fizetség fejében (0.01 bitcoin , vagyis írásunk idején kb. 5$ ellenében), Eugénia külső megbízást adhat a 7-karakterből álló minta megkeresésére, és ahelyett, hogy egy CPU-n hónapokig keresné a mintát, már néhány órán belül megkapja az eredményt.</p></div>
<div class="paragraph"><p>Egy kérkedő cím előállítása a nyers erő módszerével történik: kipróbálunk egy véletlen kulcsot, és megnézzük, hogy az így kapott cím illeszkedik-e a kívánt mintával. Ha nem, akkor megismételjük a folyamatot. A <a href="#vanity_miner_code">[vanity_miner_code]</a> egy példát mutat a "kérkedő címek bányászatára", vagyis egy olyan C++ programot mutat be, mellyel kérkedő címek állíthatók elő. A példák a  libbitcoin könyvtárat használják, melyet az <a href="#alt_libraries">[alt_libraries]</a> részben ismertettünk.</p></div>
<div class="exampleblock" id="vanity_miner_code">
<div class="title">Example 7. Kérkedő cím bányászat</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>A fenti példa a <tt>std::random_device</tt> -t használja. A megvalósítástól függően ez akár egy kriptográfiailag biztonságos véletlenszám generátor (cryptographically secure random number generator (CSRNG)) is lehet. A UNIX-szerű operációs rendszerek, pl. a Linux esetén ez a <tt>/dev/urandom</tt>-ot használja. A véletleszám generátor itt csupán szemléltetési célokra szolgál. Éles rendszerben <em>nem</em> használható bitcoin kulcsok előállítására, mivel ez a megvalósítás nem rendelkezik elégséges biztonsággal.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Ezt a példát egy C<tt> fordítóval kell lefordítani, és össze kell szerkesztenia libbitcoin könyvtárral (előbb a libbitcoin könyvtárat kell installálni a rendszeren). A példa futtatása úgy lehetséges, hogy a </tt>vanity-miner++ végrehajtható programot paraméterek nélkül futtatjuk (lásd <a href="#vanity_miner_run">[vanity_miner_run]</a>). A program egy "1kid" kezdetű kérkedő címet próbál találni.</p></div>
<div class="exampleblock" id="vanity_miner_run">
<div class="title">Example 8. A kérkedő cím bányászatára vonatkozó példa fordítása és futtatása</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>A mintapélda néhány másodperc alatt talált egy három kakakteres mintát ("kid), amint azt az időmérésre szolgáló  <tt>time</tt> Unix parancsból láthatjuk. A <tt>search</tt> keresési minta megváltoztatásával megvizsgálhatjuk, hogy meddig tart egy négy vagy öt karakteres minta megtalálása!</p></div>
</div>
<div class="sect4">
<h5 id="_a_kérkedő_címek_biztonsága">A kérkedő címek biztonsága</h5>
<div class="paragraph"><p>A kérkedő címek valódi kétélű kardot jelentenek, mert a biztonság fokozható is, de <em>csökkenthető</em> is velük. Ha a kérkedő címeket a bitonság javítására használjuk, a jellegzetes címek megnehezítik, hogy a támadó a saját címét helyettesítse be, és az ügyfelek neki fizessenek. Sajnos, a kérkedő címek azt is lehetővé teszik, hogy bárki létrehozzon egy olyan címet, ami <em>hasonlít</em> egy másik véletlen címhez, vagy akár egy másik kérkedő címhez, és így be tudja csapni az ügyfeleket.</p></div>
<div class="paragraph"><p>Eugénia eljárhat úgy, hogy egy véletlenszerűen generált címet tesz közzé (pl. <tt>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</tt>), amelyre bárki elküldheti az adományát. Vagy generálhat egy kérkedő címet is, amelynek 1Kids a kezdete, hogy jellegzetesebbé tegye a címet.</p></div>
<div class="paragraph"><p>Mindkét esetben az egyetlen fix cím használatának (az egyes adományozóknak külön, dinamikusan generált dinamikus címekkel szemben) az a veszélye, hogy egy tolvaj behatolhat a web helyre, és a saját címével helyettesítheti a címet, ezzel az adományokat magához irányíthatja át. Ha az adományokat fogadó cím számos különböző helyen lett reklámozva, akkor a felhasználók az utalás előtt vizuálisan ellenőrizni tudják a címet, hogy valóban ugyanaz-e a cím, mint amit a web helyen, a nekik küldött levélben vagy szórólapon láttak. Egy olyan véletlen cím esetében, mint amilyen pl. a <tt>1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</tt>, az átlagos felhasználó az első néhány karaktert ellenőrzi, például a "1J7mdg"-t, és ha ez egyezik, akkor úgy tekinti, hogy a cím helyes. Ha valaki lopási céllal egy hasonlónak látszó címet állít elő egy kérkedő címet generáló programmal, akkor gyorsan generálható egy olyan cím, melynek első néhány karaktere megegyezik az adománygyűtés címével.  <a href="#table_4-13">[table_4-13]</a>:</p></div>
<div class="tableblock" id="table_4-13">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 13. Egy véletlen címmel egyező kérkedő cím előállítása</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table"><strong>Eredeti véletlen cím</strong></p></td>
<td align="left" valign="top"><p class="table">1J7mdg5rbQyUHENYdx39WVWK7fsLpEoXZy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Kérkedő cím (4 kar. egyezés)</strong></p></td>
<td align="left" valign="top"><p class="table">1J7md1QqU4LpctBetHS2ZoyLV5d6dShhEy</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Kérkedő cím (5 kar. egyezés)</strong></p></td>
<td align="left" valign="top"><p class="table">1J7mdgYqyNd4ya3UEcq31Q7sqRMXw2XZ6n</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table"><strong>Kérkedő cím (6 kar. egyezés)</strong></p></td>
<td align="left" valign="top"><p class="table">1J7mdg5WxGENmwyJP9xuGhG5KRzu99BBCX</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>Növeli-e egy kérkedő cím a biztonságot? Ha Eugénia azt a kérkedő címet állítja elő, hogy <tt>1Kids33q44erFfpeXrmDSz7zEqG2FesZEN</tt>, a felhasználók a kérkedő karaktereket, valamint <em>az ezek mögött álló néhány karaktert</em> fogják megvizsgálni, pl. a cím "1Kids33" részét. Ez arra kényszeríti a támadót, hogy egy olyan kérkedő címet állítson elő, amely legalább 6 karakter hosszú, de ehhez 3364-szer (58 * 58) több munkára van szükség, mint Eugéniának a 4 karakteres kérkedő címéhez. Lényegében az Eugénia (vagy az általa megfizetett bányászközösség) által elvégzett munka arra „kényszeríti” a támadót, hogy hosszabb kérkedő címet állítson elő. Ha Eugénia egy bányászközösséget fogad föl egy 8 karakter hosszú kérkedő cím előállítására, akkor ezáltal a támadó a 10 karakteres tartományba kényszerül, amelynek személyi számítópen lehetetlen az előállítása, de még egy cél-hardverrel vagy bányászközösséggel is nagyon költséges. Ami Eugéniának még megfizethető, a támadónak megfizethetetlen, különösen akkor, ha a csalás által szerezhető pénz arra sem elég, hogy fedezze a kérkedő cím előállításának a költségét.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="paper_wallets">Papír pénztárcák</h4>
<div class="paragraph"><p>A papír pénztárcák papírra kinyomtatott privát kulcsok. A papír pénztárca kényelemi okokból gyakran a titkos kulcshoz tartozó bitcoin címet is tartalmazza, de ez nem feltétlenül szükséges, mivel a bitcoin cím előállítható a titkos kulcsból. A papír pénztárcák nagyon hatékony módszert jelentenek biztonsági mentések, vagy offline bitcoin tárolók létrehozására. Az offline bitcoin tárolók neve: „hideg tároló”. Mentési mechanizmusként a papír pénztárca védelmet jelent az ellen, nehogy egy számítógép meghibásodásakor elvesszen a kulcs, pl. ha a számítógépnek tönkremegy a diszkje, vagy ha ellopják a számítógépet, vagy ha a kulcs véletlenül törlésre kerül. A papír pénztárcák „hideg tárolóként” nagyon biztonságosak a hackerekkel, key-loggerekkel és más számítógépes fenyegetésekkel szemben, ha offline állították elő őket, és soha nem voltak online rendszeren tárolva.</p></div>
<div class="paragraph"><p>A papír pénztárcák sokféle alakban és méretben léteznek, de lényegében csupán egy papírra kinyomtatott kulcsból és címből állnak. A papír pénztárcáknak ez a legegyszerűbb alakja: <a href="#table_4-14">[table_4-14]</a></p></div>
<div class="tableblock" id="table_4-14">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 14. A legegyszerűbb papír pénztárca: a bitcoin cím és a titkos kulcs kinyomtatva</caption>
<col width="50%" />
<col width="50%" />
<thead>
<tr>
<th align="left" valign="top">Bitcoin cím</th>
<th align="left" valign="top">Titkos kulcs (WIF)</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">1424C2F4bC9JidNjjTUZCbUxv6Sa1Mt62x</p></td>
<td align="left" valign="top"><p class="table">5J3mBbAH58CpQ3Y5RNJpUKPE62SQ5tfcvU2JpbnkeyhfsYB1Jcn</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>A papír pénztárcák könnyen előállíthatók olyan eszközökkel, mint pl. a <em>bitaddress.org</em> címen található kliens-oldali Javascript generátor. Ez a web lap a kulcsok és a papír pénztárcák előállításához szükséges összes kódot tartalmazza, és a működéséhez nincs szükség Internet kapcsolatra. Használatához mentsük el a HTML oldalt a lokális meghajtónkra vagy egy külső USB meghajtóra. Szakítsuk meg az Internet kapcsolatot, és nyissuk meg az állományt egy Web böngészőben. Még jobb, ha egy friss operációs rendszert töltünk be, pléldául egy CDROM-ról bootolható Linuxot. Míg offline vagyunk, az eszköz által generált kulcsok a helyi nyomtatón egy USB kábellel (nem Wifi-vel) kinyomtathatók, ezáltal olyan papír tárcák állíthatók elő, melyek kulcsai csak a papíron léteznek, és soha nem voltak online rendszerben tárolva. Ha ezeket a papír pénztárcákat egy tűz-biztos széfbe tesszük, és bitcoint „küldünk” a bitcoin címeikre, akkor így egy egyszerű, de nagyon hatékony „hideg tárolót” valósítunk meg. A <a href="#paper_wallet_simple">[paper_wallet_simple]</a> ábrán egy papír pénztárca látható, amely a bitaddress.org segítségével lett előállítva.</p></div>
<div class="imageblock" id="paper_wallet_simple">
<div class="content">
<img src="images/msbt_0414.png" alt="images/msbt_0414.png" />
</div>
<div class="title">Figure 14. Példa egy egyszerű papír tárcára a bitaddress.org-ról</div>
</div>
<div class="paragraph"><p>Az egyszerű papír pénztárcák hátránya az, hogy a kinyomtatott kulcsok sebezhetők a lopással szemben. Ha egy tolvaj hozzáfér a papír tárcához, akkor ellophatja vagy lefényképezheti a kulcsokat, és a birtokába juthat a kulcsok által őrzött bitcoinoknak. Egy fejlettebb papír pénztárca rendszer BIP0038 kódolt privát kulcsokat használ. A papír tárcára kinyomtatott kulcsokat jelmondat védi, melyet a tulajdonos kívülről tud. A jelmondat nélkül a kódolt kulcsok használhatatlanok. Ugyanakkor ez a megoldás még mindig jobb, mint egy jelszóval védett pénztárca, mert a kulcsok soha sem voltak online, és fizikailag kell őket elővenni egy széfből vagy más, fizikailag biztonságos tárolóból. A  <a href="#paper_wallet_encrypted">[paper_wallet_encrypted]</a>  ábrán egy BIP0038 titkosított privát kulccsal rendelkező papír pénztárca látható, amely a bitaddress.org segítségével lett létrehozva.</p></div>
<div class="imageblock" id="paper_wallet_encrypted">
<div class="content">
<img src="images/msbt_0415.png" alt="images/msbt_0415.png" />
</div>
<div class="title">Figure 15. Példa egy kódolt papír tárcára a bitaddres.org-ról. A jelmondat: „test”</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Warning</div>
</td>
<td class="content">
<div class="paragraph"><p>Egy papír tárcába akár többször is lehet pénzt küldeni, de a pénzt csak egyszer lehet belőle felvenni. Ekkor a benne lévő összes pénzt el kell költeni. Ez azért van így, mert a pénz elköltése során felfedjük a privát kulcsot, másfelől azért, mert némelyik pénztárca a visszajáró pénznek egy további, újabb címet állít elő, ha nem az egész összeget költjük el. Mindent úgy költhetünk el, ha papír tárcában lévő összes pénzt felvesszük, és a maradék pénzt egy új papír tárcába küldjük.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Sokféle méretű és kivitelű papír tárca van, melyeknek különféle tulajdonságaik vannak. Némelyik ajándékul szolgál, és az alkalomhoz illő témáik vannak, pl. Karácsonyi vagy Újévi jelenetek. Mások arra a célra szolgálnak, hogy egy banki páncélteremben vagy széfben őrizzük őket. Ezeknél a privát kulcs valamilyen módszerrel el van takarva, pl. nem átlátszó, lekaparható matricával, vagy össze van hajtogatva és egy biztonságos öntapadó fóliával van leragasztva. Az alábbi <xref linkend="paper_wallet_bpw" xrefstyle="select: labelnumber"/> és <xref linkend="paper_wallet_spw" xrefstyle="select: labelnumber"/> közötti ábrákon különféle papír tárcák láthatók.</p></div>
<div class="imageblock" id="paper_wallet_bpw">
<div class="content">
<img src="images/msbt_0416.png" alt="images/msbt_0416.png" />
</div>
<div class="title">Figure 16. Példa egy papír tárcára a bitcoinpaperwallet.com-ról, ahol a titkos kulcs egy összehajtható fülön van.</div>
</div>
<div class="imageblock" id="paper_wallet_bpw_folded">
<div class="content">
<img src="images/msbt_0417.png" alt="images/msbt_0417.png" />
</div>
<div class="title">Figure 17. A bitcoinpaperwallet.com-ról származó papír tárca, ahol a titkos kulcs rejtve van.</div>
</div>
<div class="paragraph"><p>Más típusok leválasztható ellenőrző szelvények formájában a kulcsból és a címből több példányt tartalmaznak, hasonlóan a jegyek ellenőrző szelvényeihez, ezáltal több példányban tárolhatók, ami megvédi őket a tűzesetek, árvizek és más természeti katasztrófák ellen.</p></div>
<div class="imageblock" id="paper_wallet_spw">
<div class="content">
<img src="images/msbt_0418.png" alt="images/msbt_0418.png" />
</div>
<div class="title">Figure 18. Példa egy papír tárcára, amely egy tartalék „fülön” a kulcsok további másolatait tartalmazza.</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-07-15 16:56:49 UTC
</div>
</div>
</body>
</html>
