<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.7" />
<title></title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

pre {
  padding: 0;
  margin: 0;
}

#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

tt {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

.monospaced {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
}

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install();
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="transactions">Transazioni</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ch5_intro">Introduzione</h3>
<div class="paragraph"><p>Le transazioni sono la parte più importante del sistema bitcoin. Tutto il resto in bitcoin è progettato per assicurare che le transazioni possano essere create, propagate nel network, validate e infine aggiunte al registro globale delle transazioni (la blockchain). Le transazioni sono strutture dati che codificano il valore del trasferimento tra partecipanti nel sistema bitcoin. Ogni transazione è un dato pubblico nella blockchain di bitcoin, il registro contabile globale a partita doppia (double-entry bookkeeping).</p></div>
<div class="paragraph"><p>In questo capitolo esamineremo le varie forme di transazione, cosa contengono, come crearle, come sono verificate e come diventano parte del registro permanente di tutte le transazioni.</p></div>
</div>
<div class="sect2">
<h3 id="tx_lifecycle">Ciclo Vitale delle Transazioni</h3>
<div class="paragraph"><p>Il ciclo di vita di una transazione inizia con la sua creazione, anche conosciuta come <em>originazione</em>. La transazione è poi firmata con una o più firme che indicano l&#8217;autorizzazione a spendere i fondi riferiti dalla transazione. La transazione è poi trasmessa sul network bitcoin, dove ogni nodo del network (partecipante) valida e propaga la transazione fino che non arriva (quasi a) ogni nodo del network. Infine, la transazione è verificata da un nodo miner e inclusa in un blocco di transazioni che è registrato nella blockchain.</p></div>
<div class="paragraph"><p>Una volta registrata sulla blockchain e confermata da un numero di blocchi susseguenti sufficienti (conferme), la transazione è parte permanente del registro bitcoin ed è accettata come valida da tutti i partecipanti. I fondi assegnati al nuovo proprietario dalla transazione possono essere spesi in una nuova transazione, estendendo la catena di passaggi di proprietà e iniziando nuovamente il ciclo-vita di una transazione.</p></div>
<div class="sect3">
<h4 id="tx_origination">Creare Transazioni</h4>
<div class="paragraph"><p>In un certo senso si potrebbe pensare ad una transazione come se fosse un assegno. Come un assegno, una transazione è uno strumento che esprime l&#8217;intento di trasferire valuta e non è visibile al sistema finanziario fino a che non è immesso nel sistema affinchè sia eseguito. Come per gli assegni, chi effettua la transazione non deve essere per forza colui che firma la transazione.</p></div>
<div class="paragraph"><p>Transactions can be created online or offline by anyone, even if the person creating the transaction is not an authorized signer on the account. For example, an accounts payable clerk might process payable checks for signature by the CEO. Similarly, an accounts payable clerk can create bitcoin transactions and then have the CEO apply digital signatures to make them valid. Whereas a check references a specific account as the source of the funds, a bitcoin transaction references a specific previous transaction as its source, rather than an account.</p></div>
<div class="paragraph"><p>Once a transaction has been created, it is signed by the owner (or owners) of the source funds. If it is properly formed and signed, the signed transaction is now valid and contains all the information needed to execute the transfer of funds. Finally, the valid transaction has to reach the bitcoin network so that it can be propagated until it reaches a miner for inclusion in the pubic ledger (the blockchain).</p></div>
</div>
<div class="sect3">
<h4 id="tx_bcast">Trasmettere Transazioni sulla Rete Bitcoin</h4>
<div class="paragraph"><p>Per prima cosa, una transazione deve essere consegnata al network bitcoin così che possa essere propagata e inclusa nella blockchain. In sostanza, una transazione bitcoin è solamente da 300 a 400 byte di dati e deve raggiungere uno delle decine di migliaia di nodi bitcoin. I mittenti non devono fidarsi dei nodi che usano per pubblicare la transazione, fintanto che ne usino più di uno per assicurarsi che si propaghi. I nodi non devono riporre fiducia nel mittente o stabilire l'"identità" di esso. Visto che la transazione è firmata e non contiene nessuna informazione confidenziale, come chiavi private o credenziali, essa può essere pubblicata apertamente usando qualsiasi rete sottostante per il trasporto di dati che sia conveniente. A differenza delle transazioni delle carte di credito, per esempio, che contengono informazioni sensibili e possono essere trasmesse solo su reti protette, una transazione bitcoin può essere inviata su qualsiasi rete. Fin quando la transazione può raggiungere un nodo bitcoin che la possa propagare nella rete bitcoin, questo è sufficiente, non importa come sia trasportata al primo nodo.</p></div>
<div class="paragraph"><p>Le transazioni bitcoin possono per questo essere trasmesse al network bitcoin su reti insicure come le reti WiFi, Bluetooth, NFC, Chirp, codici a barre, o copiando e incollando attraverso un form web. In casi estremi, una transazione bitcoin può essere trasmessa attraverso packet radio, trasmissione satellitare, onde corte utilizzando una trasmissione burst a onde corte, ad ampio spettro, o con frequency hopping per evitare di essere rivelata e distrubata (jamming). Una transazione bitcoin può anche essere codificata come faccine (smileys, emoticon) e postata in un forum pubblico o inviata come messaggio testuale o Skype chat. Bitcoin ha trasformato i soldi in una struttura dati, facendo in modo che sia praticamente impossibile impedire a qualcuno di creare e eseguire una transazione bitcoin.</p></div>
</div>
<div class="sect3">
<h4 id="tx_propagation">Propagare Transazioni sulla Rete Bitcoin</h4>
<div class="paragraph"><p>Una volta che una transazione bitcoin è inviata a qualsiasi nodo connesso alla rete bitcoin, quella transazione sarà validata da quel nodo. Se valida, quel nodo la propagherà agli altri nodi a cui è connesso, e un messaggio di conferma verrà ritornato sincronamente all&#8217;originatore. Se la transazione è invalida, il nodo la respingerà e sincronamente ritornerà un messaggio rigettandola all&#8217;originatore.</p></div>
<div class="paragraph"><p>La rete bitcoin è una rete peer-to-peer, questo significa che ogni nodo bitcoin è connesso con un po di altri nodi bitcoin che scopre durante l&#8217;avvio del programma attraverso il protocollo peer-to-peer. L&#8217;intero network forma una maglia (mesh) connessa in modo lasso senza una tipologia fissa o struttura predefinita, rendendo tutti i nodi peer alla pari. I messaggi, includendo transazioni e blocchi, sono propagati da ogni nodo a tutti i peer a cui sono connessi, un processo chiamato "flooding" (inondazione). Una nuova transizione validata iniettata dentro un qualsiasi nodo della rete sarà inviata a tutti i nodi connessi ad esso (vicini), ognuno di essi invierà la transazione a tutti i suoi vicini, e così via. In questo modo, nel giro di pochi secondi una transazione valida si propagherà in un onda che si espanderà esponenzialmente attraverso il network fino a che tutti i nodi non l&#8217;avranno ricevuta.</p></div>
<div class="paragraph"><p>The bitcoin network is designed to propagate transactions and blocks to all nodes in an efficient and resilient manner that is resistant to attacks. To prevent spamming, denial-of-service attacks, or other nuisance attacks against the bitcoin system, every node independently validates every transaction before propagating it further. A malformed transaction will not get beyond one node. The rules by which transactions are validated are explained in more detail in <a href="#tx_verification">[tx_verification]</a>.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="tx_structure">Struttura della Transazione</h3>
<div class="paragraph"><p>Una transazioni è una <em>struttura dati</em> che codifica e trasferisce un valore da una fonte di fondi, chiamata un <em>input</em>, a una destinazione, chiamata un <em>output</em>. Gli input di transazione e gli output non sono relazionati a nessun account o identità. Al contrario, dovresti immaginarteli come pezzi/somme di bitcoin (allucchettati e) protetti tramite una chiave segreta che solo il proprietario, o la persona che conosce la chiave, può sbloccare. Una transazione contiene un certo numero di campi, come mostrato in <a href="#tx_data_structure">[tx_data_structure]</a>.</p></div>
<div class="tableblock" id="tx_data_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 1. La struttura di una transazione</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Dimensione</th>
<th align="left" valign="top"> Campo </th>
<th align="left" valign="top"> Descrizione</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Versione</p></td>
<td align="left" valign="top"><p class="table">Specifica quale regole segue la seguente transazione</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1–9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Input Counter</p></td>
<td align="left" valign="top"><p class="table">Quanti input sono inclusi</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Inputs</p></td>
<td align="left" valign="top"><p class="table">Uno o più input di transazione</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1–9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Output Counter</p></td>
<td align="left" valign="top"><p class="table">Quanti output sono inclusi</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Outputs</p></td>
<td align="left" valign="top"><p class="table">Uno o più output di transazione</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Locktime</p></td>
<td align="left" valign="top"><p class="table">Un Unix timestamp o numero del blocco</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="title">Locktime di Transazione</div>
<div class="paragraph"><p>Il locktime, conosciuto anche come nLockTime dal nome della variabile usata nel client di riferimento (reference client), definisce il primo tempo (timestamp) in cui una transazione è considerata valida e può essere trasmessa alla rete o aggiunta alla blockchain. E' impostata a zero in molte transazioni per indicare la propagazione e l&#8217;esecuzione immediata. Se il locktime non è impostato a zero e sotto 500 milioni, è interpretato come una block height, questo sta a significare che la transazione non è valida e non sarà trasmessa attraverso o inclusa nella blockchain prima della block height specificata. Se è oltre i 500 milioni, è interpretato come un timestamp Unix Epoch (secondi dal 1-Gen-1970) e la transazione non saraà valida prima del tempo specificato. Le transazioni con locktime che specificano un blocco futuro o un timestamp devono essere create dal sistema originante e trasmesse al network bitcoin solo dopo che esse sono divenute valide. L&#8217;uso del locktime è equivalente al postdatare un&#8217;assegno.</p></div>
</div></div>
</div>
<div class="sect2">
<h3 id="tx_inputs_outputs">Output e Input di una Transazione</h3>
<div class="paragraph"><p>I mattoni fondamentali di una transazione bitcoin sono gli <em>output di transazione non spesi</em> (unspent transaction outputs), o UTXO. Gli UTXO sono frammenti indivisibili di valuta bitcoin "allucchettati" su di un proprietario specifico, registrati sulla blockchain, e riconosciuti come unità di valuta da tutto il network. Il network bitcoin traccia tutti gli UTXO disponibili (non spesi) che attualmente si contano essere nell&#8217;ordine dei milioni. Ogniqualvolta un utente riceve bitcoin, quella somma è registrata dentro la blockchain come UTXO. Pertanto, i bitcoin di un&#8217;utente potrebbero essere sparpagliati in UTXO nelle centinaia di transazioni e centinaia di blocchi. In effetti, non c'è un qualcosa come un saldo salvato di un indirizzo bitcoin o account; ci sono solo UTXO disseminati, protetti sugli specifici proprietari. Il concetto di un saldo bitcoin di un utente è un costrutto derivato creato dall&#8217;applicazione wallet. Il wallet calcola il saldo dell&#8217;utente scansionando la blockchain e aggregando tutti gli UTXO appartenenti a quell&#8217;utente.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Non ci sono bilanci in bitcoin; ci sono solo <em>output di transazione non spesi</em> (UTXO) sparpagliati nella blockchain.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>Una UTXO può avere un valore arbitrario denominato in multipli di satoshi (satoshis). Proprio come i dollari che possono essere divisi alla seconda cifra decimale come i centesimi, i bitcoin possono essere divisi fino all&#8217;ottava cifra decimale come i satoshi. Anche se gli UTXO possono contenere un qualsiasi valore, quando creati questo valore è indivisibile proprio come una moneta che non può essere divisa a metà. Se un UTXO è più grande del valore desiderato della transazione, deve tuttavia essere consumato nella sua interezza e il resto deve essere generato nella transazione. In altre parole, se hai una UTXO da 20 bitcoin e vuoi pagare 1 bitcoin, la tua transazione deve consumare tutto l&#8217;UTXO da 20 bitcoin e produrre due output: uno che paga 1 bitcoin al tuo destinatario desiderato e un&#8217;altro che paga 19 bitcoin come resto indietro al tuo wallet. Come risultato, la maggior parte delle transazioni bitcoin genereranno resto.</p></div>
<div class="paragraph"><p>Immagina un cliente che compra una bevanda da 1.50$, prendendo il suo wallet e provando a trovare una combinazione di monete e banconote per coprire il costo da 1.50$. Il cliente sceglierà l&#8217;esatto resto se disponibile (una banconota da un dollaro e due da 25 cent), o una combinazione di denominazioni più piccole (sei monete da 25cent), o se necessario, una unità piu grande quale una banconota da cinque dollari. Se lei da troppa moneta, come per esempio 5$, al proprietario del negozio, lei si aspetterà di ricevere 3.50$ di resto, i quali ritorneranno al suo wallet e in questo modo lei li avrà disponibili per transazioni future.</p></div>
<div class="paragraph"><p>Nello stesso modo, una transazione bitcoin deve essere creata da una UTXO di un&#8217;utente in qualsiasi denominazioni questo utente abbia a disposizione. Gli utenti non possono tagliare una UTXO a metà più che possono tagliare una banconota da un dollaro a metà e utilizzarla come moneta. L&#8217;applicazione wallet dell&#8217;utente selezionerà solitamente dagli UTXO disponibili da parte dell&#8217;utente varie unità per comporre una somma più grande o uguale del valore di transazione desiderato.</p></div>
<div class="paragraph"><p>Come nella vita reale, l&#8217;applicazione bitcoin può usare diverse strategie per soddisfare la somma da trasferire (in questo caso l&#8217;acquisto): combinando diverse unità più piccole, trovando il resto giusto, o usando una singola unità più grande del valore della transazione e creare il resto. Tutto questo complesso assemblaggio di UTXO spendibili è fatto dal wallet dell&#8217;utente automaticamente ed è invisibile agli utenti. E' solo rilevante se stai costruendo programmaticamente transazioni raw da UTXO.</p></div>
<div class="paragraph"><p>Le UTXO consumate da una transazione sono chiamati input della transazione (transaction input), e le UTXO create da una transazione sono chiamati output della transazione (transaction output). In questo modo, una parte di valore bitcoin si muove in avanti da un proprietario all&#8217;altro in una catena di transazioni che consumano e creano UTXO. Le transazioni consumano UTXO sbloccandola con la firma del proprietario attuale e creano UTXO bloccandola sull&#8217;indirizzo bitcoin di un nuovo proprietario.</p></div>
<div class="paragraph"><p>L&#8217;eccezione alla catena di output e input è un tipo speciale di transazione chiamata la transazione <em>coinbase</em>, che è la prima transazione in ogni blocco. Questa transazione è immessa li (nella blockchain) dal miner "vincitore" e crea bitcoin "nuovi-di-zecca" pagabili a quel miner come ricompensa per aver effettuato il lavoro di mining. Questo è il modo (e l&#8217;unico modo, ndt.) in cui la massa monetaria (money supply) di bitcoin è creata durante il processo di mining, come vedremo nel <a href="#ch8">[ch8]</a>.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Cosa viene per primo? Gli input o gli output, l&#8217;uovo o la gallina?  Tecnicamente, gli output vengono prima a causa delle transazioni coinbase, le quali generano nuovi bitcoin, esse non hanno input e creano output dal niente.</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="tx_outs">Output della Transazione</h4>
<div class="paragraph"><p>Ogni transazione bitcoin crea output, che sono registrati sul registro di bitcoin (ledger). Quasi tutti questi output, con una eccezzione (vedi <a href="#op_return">[op_return]</a>) creano pezzi spendibili di bitcoin chiamati <em>unspent transaction outputs</em> o UTXO (output di transazione non spesi), i quali sono poi riconosciuti da tutto il network e disponibili per il proprietario per spenderli in una futura transazioni. Inviando a qualcuno bitcoin è l&#8217;azione del creare un&#8217;output di una transazione unspent (non spesa), cioè un UTXO, registrata con all&#8217;interno il loro indirizzo di modo che sia disponibile per loro spenderli.</p></div>
<div class="paragraph"><p>Gli UTXO sono tracciati da ogni client bitcoin full-node come serie di dati chiamati la <em>UTXO set</em> o <em>UTXO pool</em>, salvata in un database. Le nuove transazioni consumano (spendono) uno o più di questi output dal set di UTXO.</p></div>
<div class="paragraph"><p>Gli output di una Transazione consistono di due parti:</p></div>
<div class="ulist"><ul>
<li>
<p>
Un importo di bitcoin, denominati in <em>satoshi</em>, l&#8217;unità più piccola di bitcoin
</p>
</li>
<li>
<p>
A <em>locking script</em>, also known as an "encumbrance" that "locks" this amount by specifying the conditions that must be met to spend the output
</p>
</li>
</ul></div>
<div class="paragraph"><p>Il linguaggio di scripting delle transazioni, usato nel locking script menzionato precedentemente, è discusso in dettaglio in <a href="#tx_script">[tx_script]</a>. <a href="#tx_out_structure">[tx_out_structure]</a> invece mostra la struttura dell&#8217;output di una transazione.</p></div>
<div class="tableblock" id="tx_out_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 2. La struttura di un output di una transazione</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Dimensione</th>
<th align="left" valign="top"> Campo </th>
<th align="left" valign="top"> Descrizione</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">8 bytes</p></td>
<td align="left" valign="top"><p class="table">Importo</p></td>
<td align="left" valign="top"><p class="table">Valore bitcoin rappresentato in satoshi (10<sup>-8</sup> bitcoin)</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 byte (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Dimensione del Locking-Script</p></td>
<td align="left" valign="top"><p class="table">Lunghezza del Locking-Script in byte, a seguire</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Script di Locking</p></td>
<td align="left" valign="top"><p class="table">Uno script che definisce le condizioni necessarie per spendere l&#8217;output</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>In <a href="#get_utxo">[get_utxo]</a>, usiamo l&#8217;API di blockchain.info per trovare gli unspent output (UTXO) di un&#8217;indirizzo specifico.</p></div>
<div class="exampleblock" id="get_utxo">
<div class="title">Example 1. Uno script che chiama l&#8217;API di blockchain.info per trovare gli UTXO relativi ad un indirizzo</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>Eseguendo lo script, possiamo notare una lista di transaction ID, il carattere due punti, il numero dell&#8217;indice di un unspent transaction output (UTXO) specifico, e il valore di quell&#8217;UTXO in satoshi. Il locking script non è mostrato nell&#8217;output in <a href="#get_utxo_run">[get_utxo_run]</a>.</p></div>
<div class="exampleblock" id="get_utxo_run">
<div class="title">Example 2. Eseguendo lo script get-utxo.py</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="sect4">
<h5 id="_le_condizioni_per_lo_spending_oneri">Le condizioni per lo Spending (oneri)</h5>
<div class="paragraph"><p>Transaction outputs associate a specific amount (in satoshis) to a specific <em>encumbrance</em> or locking script that defines the condition that must be met to spend that amount. In most cases, the locking script will lock the output to a specific bitcoin address, thereby transferring ownership of that amount to the new owner. When Alice paid Bob&#8217;s Cafe for a cup of coffee, her transaction created a 0.015 bitcoin output <em>encumbered</em> or locked to the cafe&#8217;s bitcoin address. That 0.015 bitcoin output was recorded on the blockchain and became part of the Unspent Transaction Output set, meaning it showed in Bob&#8217;s wallet as part of the available balance. When Bob chooses to spend that amount, his transaction will release the encumbrance, unlocking the output by providing an unlocking script containing a signature from Bob&#8217;s private key.</p></div>
</div>
</div>
<div class="sect3">
<h4 id="tx_inputs">Input della Transaction</h4>
<div class="paragraph"><p>In simple terms, transaction inputs are pointers to UTXO. They point to a specific UTXO by reference to the transaction hash and sequence number where the UTXO is recorded in the blockchain. To spend UTXO, a transaction input also includes unlocking scripts that satisfy the spending conditions set by the UTXO. The unlocking script is usually a signature proving ownership of the bitcoin address that is in the locking script.</p></div>
<div class="paragraph"><p>When users make a payment, their wallet constructs a transaction by selecting from the available UTXO. For example, to make a 0.015 bitcoin payment, the wallet app may select a 0.01 UTXO and a 0.005 UTXO, using them both to add up to the desired payment amount.</p></div>
<div class="paragraph"><p>In <a href="#select_utxo">[select_utxo]</a>, we show the use of a "greedy" algorithm to select from available UTXO in order to make a specific payment amount. In the example, the available UTXO are provided as a constant array, but in reality, the available UTXO would be retrieved with an RPC call to Bitcoin Core, or to a third-party API as shown in <a href="#get_utxo">[get_utxo]</a>.</p></div>
<div class="exampleblock" id="select_utxo">
<div class="title">Example 3. Uno script per calcolare quanti bitcoin totali saranno emessi</div>
<div class="content">
<div class="listingblock">
<div class="content"></div></div>
</div></div>
<div class="paragraph"><p>If we run the <em>select-utxo.py</em> script without a parameter, it will attempt to construct a set of UTXO (and change) for a payment of 55,000,000 satoshis (0.55 bitcoin). If you provide a target payment amount as a parameter, the script will select UTXO to make that target payment amount. In <a href="#select_utxo_run">[select_utxo_run]</a>, we run the script trying to make a payment of 0.5 bitcoin or 50,000,000 satoshis.</p></div>
<div class="exampleblock" id="select_utxo_run">
<div class="title">Example 4. Lanciando lo script select-utxo.py</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre><tt>$ python select-utxo.py 50000000
Per una transazione con valore di 50000000 Satoshi (0.500000 bitcoin) usa:
([&lt;7dbc497969c7475e45d952c4a872e213fb15d45e5cd3473c386a71a1b0c136a1:0 with 25000000 Satoshis&gt;, &lt;7f42eda67921ee92eae5f79bd37c68c9cb859b899ce70dba68c48338857b7818:0 with 16100000 Satoshis&gt;, &lt;6596fd070679de96e405d52b51b8e1d644029108ec4cbfe451454486796a1ecf:0 with 16050000 Satoshis&gt;], 'Change: 7150000 Satoshis')</tt></pre>
</div></div>
</div></div>
<div class="paragraph"><p>Once the UTXO is selected, the wallet then produces unlocking scripts containing signatures for each of the UTXO, thereby making them spendable by satisfying their locking script conditions. The wallet adds these UTXO references and unlocking scripts as inputs to the transaction. <a href="#tx_in_structure">[tx_in_structure]</a> shows the structure of a transaction input.</p></div>
<div class="tableblock" id="tx_in_structure">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 3. La struttura di un input di una transazione</caption>
<col width="33%" />
<col width="33%" />
<col width="33%" />
<thead>
<tr>
<th align="left" valign="top">Dimensione</th>
<th align="left" valign="top"> Campo </th>
<th align="left" valign="top"> Descrizione</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left" valign="top"><p class="table">32 bytes</p></td>
<td align="left" valign="top"><p class="table">Hash della Transazione</p></td>
<td align="left" valign="top"><p class="table">Puntatore alla transazione contenente l&#8217;UTXO che andrà speso</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Indice dell&#8217;Output</p></td>
<td align="left" valign="top"><p class="table">Il numero indice dell&#8217;UTXO speso; il primo è 0</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">1-9 bytes (VarInt)</p></td>
<td align="left" valign="top"><p class="table">Dimensione dell&#8217;Unlocking-Script</p></td>
<td align="left" valign="top"><p class="table">Lunghezza dell&#8217;Unlocking-Script in bytes, a seguire</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Variable</p></td>
<td align="left" valign="top"><p class="table">Unlocking-Script</p></td>
<td align="left" valign="top"><p class="table">Uno script che completa le condizioni del locking script dell&#8217;UTXO.</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">4 bytes</p></td>
<td align="left" valign="top"><p class="table">Sequence Number</p></td>
<td align="left" valign="top"><p class="table">Attualmente disabilitato, funzione di Tx-replacement, impostato a 0xFFFFFFFF</p></td>
</tr>
</tbody>
</table>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>Il numero della sequenza è usato per sovrascrivere una transazione prima della scadenza del locktime della transazione, che è una funzione attualmente disabilitata in bitcoin. La maggior parte delle transazioni impostano questo valore al massimo valore intero (0xFFFFFFFF) così che sia ignorato dal network bitcoin. Se la transazione ha un locktime diverso da zero, almeno uno dei suoi input deve avere un numero di sequenza inferiore a 0xFFFFFFFF per abilitare il locktime.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="tx_fees">Commissioni sulla Transazione (transaction fee)</h4>
<div class="paragraph"><p>Most transactions include transaction fees, which compensate the bitcoin miners for securing the network. Mining and the fees and rewards collected by miners are discussed in more detail in <a href="#ch8">[ch8]</a>. This section examines how transaction fees are included in a typical transaction. Most wallets calculate and include transaction fees automatically. However, if you are constructing transactions programmatically, or using a command-line interface, you must manually account for and include these fees.</p></div>
<div class="paragraph"><p>Transaction fees serve as an incentive to include (mine) a transaction into the next block and also as a disincentive against "spam" transactions or any kind of abuse of the system, by imposing a small cost on every transaction. Transaction fees are collected by the miner who mines the block that records the transaction on the blockchain.</p></div>
<div class="paragraph"><p>Transaction fees are calculated based on the size of the transaction in kilobytes, not the value of the transaction in bitcoin. Overall, transaction fees are set based on market forces within the bitcoin network. Miners prioritize transactions based on many different criteria, including fees, and might even process transactions for free under certain circumstances. Transaction fees affect the processing priority, meaning that a transaction with sufficient fees is likely to be included in the next-most–mined block, whereas a transaction with insufficient or no fees might be delayed, processed on a best-effort basis after a few blocks, or not processed at all. Transaction fees are not mandatory, and transactions without fees might be processed eventually; however, including transaction fees encourages priority processing.</p></div>
<div class="paragraph"><p>Over time, the way transaction fees are calculated and the effect they have on transaction prioritization has been evolving. At first, transaction fees were fixed and constant across the network. Gradually, the fee structure has been relaxed so that it may be influenced by market forces, based on network capacity and transaction volume. The current minimum transaction fee is fixed at 0.0001 bitcoin or a tenth of a milli-bitcoin per kilobyte, recently decreased from one milli-bitcoin. Most transactions are less than one kilobyte; however, those with multiple inputs or outputs can be larger. In future revisions of the bitcoin protocol, it is expected that wallet applications will use statistical analysis to calculate the most appropriate fee to attach to a transaction based on the average fees of recent transactions.</p></div>
<div class="paragraph"><p>L&#8217;algoritmo usato attualmente dai miner per prioritizzare le transazioni per l&#8217;inclusione in un blocco basato sulle rispettive fee è esaminato in dettaglio in <a href="#ch8">[ch8]</a>.</p></div>
</div>
<div class="sect3">
<h4 id="_impostare_le_commissioni_sulle_transazioni">Impostare le Commissioni sulle Transazioni</h4>
<div class="paragraph"><p>The data structure of transactions does not have a field for fees. Instead, fees are implied as the difference between the sum of inputs and the sum of outputs. Any excess amount that remains after all outputs have been deducted from all inputs is the fee that is collected by the miners.</p></div>
<div class="listingblock" id="tx_fee_equation">
<div class="title">Le transaction fee sono l&#8217;eccesso degli input meno gli output:</div>
<div class="content">
<pre><tt>Fees = Sum(Inputs) – Sum(Outputs)</tt></pre>
</div></div>
<div class="paragraph"><p>This is a somewhat confusing element of transactions and an important point to understand, because if you are constructing your own transactions you must ensure you do not inadvertently include a very large fee by underspending the inputs. That means that you must account for all inputs, if necessary by creating change, or you will end up giving the miners a very big tip!</p></div>
<div class="paragraph"><p>For example, if you consume a 20-bitcoin UTXO to make a 1-bitcoin payment, you must include a 19-bitcoin change output back to your wallet. Otherwise, the 19-bitcoin "leftover" will be counted as a transaction fee and will be collected by the miner who mines your transaction in a block. Although you will receive priority processing and make a miner very happy, this is probably not what you intended.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>Se dimentichi di aggiungere un output a cui inviare il resto in una transazione costruita manualmente, il resto verrà attribuito come transaction fee. "Tieni il resto!" non è sempre quello che intendevi.</p></div>
</div></div>
<div class="paragraph"><p>Vediamo come funziona in pratica, osservando nuovamente l&#8217;acquisto del caffè effettuato da Alice. Alice vuole spendere 0.015 bitcoin per pagare il caffè. Per assicurare che questa transazione sia processata rapidamente, Alice vorrà includere una fee di transazione, diciamo 0.001. Questo vorrà dire che il costo totale della transazione sarà di 0.016 bitcoin. Il suo wallet dovrà quindi recuperare una serie di UTXO che arrivi a 0.016 o più e, se necessario, emettere il resto. Diciamo che il suo wallet abbia 0.2 bitcoin disponibili nelle UTXO. Dovrà quindi consumare queste UTXO, creare un output verso il Caffè di Bob da 0.015, e un secondo output con 0.184 bitcoin come resto re-inviati indietro al proprio wallet, lasciando 0.001 bitcoin non allocati, come fee implicita per la transazione.</p></div>
<div class="paragraph"><p>Ora diamo un&#8217;occhiata ad uno scenario differente. Eugenia, la nostra direttrice dell&#8217;organizzazione no profit nelle Filippine, ha completato una campagna di raccolta fondi per comprare libri di scuola per i bambini. Ha ricevuto molte piccole donazioni provenienti da persone in tutto il mondo, totalizzando 50 bitcoin, quindi il suo wallet è pieno di molti pagamenti molto piccoli (UTXO). A questo punto Eugenia vuole acquistare centinaia di libri di scuola da un editore locale.</p></div>
<div class="paragraph"><p>Come l&#8217;applicazione wallet di Eugenia prova a costruire una transazione singola per il pagamento, deve recuperare dalla serie di UTXO disponibili, che sono composte da varie transazioni più piccole. Questo vuol dire che la transazione risultante recupererà da più di un centinaio di UTXO di poco valore per quanto riguarda l&#8217;input e emetterà un solo output, pagando l&#8217;editore del libro. Una transazione con così tanti input sarà più grande di un kilobyte, forse dai 2 ai 3 kilobytes di dimensione. Come risultato, richiederà una fee più alta della network fee minima di 0.0001 bitcoin.</p></div>
<div class="paragraph"><p>L&#8217;applicazione wallet di Eugenia calcolerà le fee appropriate misurando la dimensione della transazione e moltiplicandola per la fee per kilobyte. Molti wallet pagano un valore di fee più alto per transazioni di dimensione maggiore per assicurarsi che la transazione sia eseguita rapidamente. Si ottiene una fee maggiorata non perchè Eugenia sta spendendo più soldi, invece è perchè la sua transazione è piu complessa e di più grande dimensione—la fee è indipendente rispetto al valore in bitcoin della transazione.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="tx_chains">Collegare Transazioni e Transazioni Orfane</h3>
<div class="paragraph"><p>As we have seen, transactions form a chain, whereby one transaction spends the outputs of the previous transaction (known as the parent) and creates outputs for a subsequent transaction (known as the child). Sometimes an entire chain of transactions depending on each other—say a parent, child, and grandchild transaction—are created at the same time, to fulfill a complex transactional workflow that requires valid children to be signed before the parent is signed. For example, this is a technique used in CoinJoin transactions where multiple parties join transactions together to protect their privacy.</p></div>
<div class="paragraph"><p>When a chain of transactions is transmitted across the network, they don&#8217;t always arrive in the same order. Sometimes, the child might arrive before the parent. In that case, the nodes that see a child first can see that it references a parent transaction that is not yet known. Rather than reject the child, they put it in a temporary pool to await the arrival of its parent and propagate it to every other node. The pool of transactions without parents is known as the <em>orphan transaction pool</em>. Once the parent arrives, any orphans that reference the UTXO created by the parent are released from the pool, revalidated recursively, and then the entire chain of transactions can be included in the transaction pool, ready to be mined in a block. Transaction chains can be arbitrarily long, with any number of generations transmitted simultaneously. The mechanism of holding orphans in the orphan pool ensures that otherwise valid transactions will not be rejected just because their parent has been delayed and that eventually the chain they belong to is reconstructed in the correct order, regardless of the order of arrival.</p></div>
<div class="paragraph"><p>There is a limit to the number of orphan transactions stored in memory, to prevent a denial-of-service attack against bitcoin nodes. The limit is defined as <tt>MAX_ORPHAN_TRANSACTIONS</tt> in the source code of the bitcoin reference client. If the number of orphan transactions in the pool exceeds <tt>MAX_ORPHAN_TRANSACTIONS</tt>, one or more randomly selected orphan transactions are evicted from the pool, until the pool size is back within limits.</p></div>
</div>
<div class="sect2">
<h3 id="tx_script">Script di Transazione e Linguaggio Bitcoin Script</h3>
<div class="paragraph"><p>Bitcoin clients validate transactions by executing a script, written in a Forth-like scripting language. Both the locking script (encumbrance) placed on a UTXO and the unlocking script that usually contains a signature are written in this scripting language. When a transaction is validated, the unlocking script in each input is executed alongside the corresponding locking script to see if it satisfies the spending condition.</p></div>
<div class="paragraph"><p>Oggi, la maggior parte delle transazioni processate attraverso il network bitcoin hanno la forma "Alice paga Bob" e sono basate sullo stesso script chiamato script Pay-to-Public-Key-Hash. Tuttavia, l&#8217;uso di script per fare il lock degli output e aggiungere regole di input che possano rimuovere il lock significa che attraverso l&#8217;uso del linguaggio di programmazione, le transazioni possono contenere un numero infinito di condizioni. Le transazioni bitcoin non sono limitate nella forma e nello schema di "Alice paga Bob".</p></div>
<div class="paragraph"><p>Questa è solo la punta dell&#8217;iceberg delle possibilità che possono essere espresse con questo linguaggio di scripting. In questa sezione, dimostreremo che i componenti del linguaggio bitcoin scripting delle transazioni e mostreremo come può essere utilizzato per esprimere condizioni complesse per lo spending dei bitcoin e come queste condizioni possono essere soddisfatte da vari unlocking script.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>La validazione delle transazioni bitcoin non è basata su di uno schema statico, ma invece è ottenuta tramite l&#8217;esecuzione di un linguaggio di scripting. Questo linguaggio permette di esprimere una quasi infinita varietà di condizioni. E' questo il modo nel cui bitcoin ottiene la potenza di "valuta programmabile" (programmable money).</p></div>
</td>
</tr></table>
</div>
<div class="sect3">
<h4 id="_costruzione_dello_script_lock_unlock">Costruzione dello Script (Lock + Unlock)</h4>
<div class="paragraph"><p>Il motore di validazione di transazioni bitcoin fa affidamento su due tipi di script per validare le transazioni: un locking script e uno script di unlock.</p></div>
<div class="paragraph"><p>A locking script is an encumbrance placed on an output, and it specifies the conditions that must be met to spend the output in the future. Historically, the locking script was called a <em>scriptPubKey</em>, because it usually contained a public key or bitcoin address. In this book we refer to it as a "locking script" to acknowledge the much broader range of possibilities of this scripting technology. In most bitcoin applications, what we refer to as a locking script will appear in the source code as <tt>scriptPubKey</tt>.</p></div>
<div class="paragraph"><p>An unlocking script is a script that "solves," or satisfies, the conditions placed on an output by a locking script and allows the output to be spent. Unlocking scripts are part of every transaction input, and most of the time they contain a digital signature produced by the user&#8217;s wallet from his or her private key. Historically, the unlocking script is called <em>scriptSig</em>, because it usually contained a digital signature. In most bitcoin applications, the source code refers to the unlocking script as <tt>scriptSig</tt>. In this book, we refer to it as an "unlocking script" to acknowledge the much broader range of locking script requirements, because not all unlocking scripts must contain signatures.</p></div>
<div class="paragraph"><p>Every bitcoin client will validate transactions by executing the locking and unlocking scripts together. For each input in the transaction, the validation software will first retrieve the UTXO referenced by the input. That UTXO contains a locking script defining the conditions required to spend it. The validation software will then take the unlocking script contained in the input that is attempting to spend this UTXO and execute the two scripts.</p></div>
<div class="paragraph"><p>In the original bitcoin client, the unlocking and locking scripts were concatenated and executed in sequence. For security reasons, this was changed in 2010, because of a vulnerability that allowed a malformed unlocking script to push data onto the stack and corrupt the locking script. In the current implementation, the scripts are executed separately with the stack transferred between the two executions, as described next.</p></div>
<div class="paragraph"><p>First, the unlocking script is executed, using the stack execution engine. If the unlocking script executed without errors (e.g., it has no "dangling" operators left over), the main stack (not the alternate stack) is copied and the locking script is executed. If the result of executing the locking script with the stack data copied from the unlocking script is "TRUE," the unlocking script has succeeded in resolving the conditions imposed by the locking script and, therefore, the input is a valid authorization to spend the UTXO. If any result other than "TRUE" remains after execution of the combined script, the input is invalid because it has failed to satisfy the spending conditions placed on the UTXO. Note that the UTXO is permanently recorded in the blockchain, and therefore is invariable and is unaffected by failed attempts to spend it by reference in a new transaction. Only a valid transaction that correctly satisfies the conditions of the UTXO results in the UTXO being marked as "spent" and removed from the set of available (unspent) UTXO.</p></div>
<div class="paragraph"><p><a href="#scriptSig_and_scriptPubKey">[scriptSig_and_scriptPubKey]</a> is an example of the unlocking and locking scripts for the most common type of bitcoin transaction (a payment to a public key hash), showing the combined script resulting from the concatenation of the unlocking and locking scripts prior to script validation.</p></div>
<div class="imageblock" id="scriptSig_and_scriptPubKey">
<div class="content">
<img src="images/msbt_0501.png" alt="scriptSig_and_scriptPubKey" />
</div>
<div class="title">Figure 1. Combinando scriptSig e scriptPubKey per valutare un transaction script</div>
</div>
</div>
<div class="sect3">
<h4 id="tx_script_language">Linguaggio di Scripting</h4>
<div class="paragraph"><p>The bitcoin transaction script language, called <em>Script</em>, is a Forth-like reverse-polish notation stack-based execution language. If that sounds like gibberish, you probably haven&#8217;t studied 1960&#8217;s programming languages. Script is a very simple language that was designed to be limited in scope and executable on a range of hardware, perhaps as simple as an embedded device, such as a handheld calculator. It requires minimal processing and cannot do many of the fancy things modern programming languages can do. In the case of programmable money, that is a deliberate security feature.</p></div>
<div class="paragraph"><p>Il linguaggio bitcoin scripting è detto un linguaggio stack-based perché utilizza una struttura dati chiamata  <em>stack</em>. Lo stack (pila) è una struttura dati molto semplice, che può essere visualizzata come un mazzo di carte. Uno stack permette due operazioni: push e pop. Push aggiunge gli elementi in cima alla pila. Pop rimuove l&#8217;elemento in cima alla pila.</p></div>
<div class="paragraph"><p>The scripting language executes the script by processing each item from left to right. Numbers (data constants) are pushed onto the stack. Operators push or pop one or more parameters from the stack, act on them, and might push a result onto the stack. For example, <tt>OP_ADD</tt> will pop two items from the stack, add them, and push the resulting sum onto the stack.</p></div>
<div class="paragraph"><p>Conditional operators evaluate a condition, producing a boolean result of TRUE or FALSE. For example, <tt>OP_EQUAL</tt> pops two items from the stack and pushes TRUE (TRUE is represented by the number 1) if they are equal or FALSE (represented by zero) if they are not equal. Bitcoin transaction scripts usually contain a conditional operator, so that they can produce the TRUE result that signifies a valid transaction.</p></div>
<div class="paragraph"><p>In <a href="#simplemath_script">[simplemath_script]</a>, the script <tt>2 3 OP_ADD 5 OP_EQUAL</tt> demonstrates the arithmetic addition operator <tt>OP_ADD</tt>, adding two numbers and putting the result on the stack, followed by the conditional operator <tt>OP_EQUAL</tt>, which checks that the resulting sum is equal to <tt>5</tt>. For brevity, the <tt>OP_</tt> prefix is omitted in the step-by-step example.</p></div>
<div class="paragraph"><p>Il seguente è uno script leggermente più complesso, che calcola <tt>2 + 7 - 3 + 1</tt>. Nota che quando lo script contiene una serie di operatori, lo attacchi permette al risultato di un operatore di essere utilizzato dall&#8217;operatore successivo:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2 7 OP_ADD 3 OP_SUB 1 OP_ADD 7 OP_EQUAL</tt></pre>
</div></div>
<div class="paragraph"><p>Prova a validare il precedente script tu stesso usando carta e penna. Quando l&#8217;esecuzione dello script finisce, rimarrà il valore TRUE nello stack.</p></div>
<div class="paragraph"><p>Although most locking scripts refer to a bitcoin address or public key, thereby requiring proof of ownership to spend the funds, the script does not have to be that complex. Any combination of locking and unlocking scripts that results in a TRUE value is valid. The simple arithmetic we used as an example of the scripting language is also a valid locking script that can be used to lock a transaction output.</p></div>
<div class="paragraph"><p>Usa una parte dello script aritmetico di esempio come locking script:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>3 OP_ADD 5 OP_EQUAL</tt></pre>
</div></div>
<div class="paragraph"><p>che può essere soddisfatta da una transazione che contiene un input con lo script di unlocking:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2</tt></pre>
</div></div>
<div class="paragraph"><p>Il software di validazione combina gli script di locking e unlocking e lo script risultante è:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2 3 OP_ADD 5 OP_EQUAL</tt></pre>
</div></div>
<div class="paragraph"><p>As we saw in the step-by-step example in <a href="#simplemath_script">[simplemath_script]</a>, when this script is executed, the result is <tt>OP_TRUE</tt>, making the transaction valid. Not only is this a valid transaction output locking script, but the resulting UTXO could be spent by anyone with the arithmetic skills to know that the number 2 satisfies the script. </p></div>
<div class="imageblock" id="simplemath_script">
<div class="content">
<img src="images/msbt_0502.png" alt="TxScriptSimpleMathExample" />
</div>
<div class="title">Figure 2. Validazione di un bitcoin script usando la matematica</div>
</div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Tip</div>
</td>
<td class="content">
<div class="paragraph"><p>Transactions are valid if the top result on the stack is TRUE (noted as <tt>&#x7b;0x01&#x7d;</tt>), any other non-zero value or if the stack is empty after script execution. Transactions are invalid if the top value on the stack is FALSE (a zero-length empty value, noted as <tt>&#x7b;&#x7d;</tt>) or if script execution is halted explicitly by an operator, such as OP_VERIFY, OP_RETURN, or a conditional terminator such as OP_ENDIF. See <a href="#tx_script_ops">[tx_script_ops]</a> for details.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="_incompletezza_di_turing">Incompletezza di Turing</h4>
<div class="paragraph"><p>The bitcoin transaction script language contains many operators, but is deliberately limited in one important way—there are no loops or complex flow control capabilities other than conditional flow control. This ensures that the language is not <em>Turing Complete</em>, meaning that scripts have limited complexity and predictable execution times. Script is not a general-purpose language. These limitations ensure that the language cannot be used to create an infinite loop or other form of "logic bomb" that could be embedded in a transaction in a way that causes a denial-of-service attack against the bitcoin network. Remember, every transaction is validated by every full node on the bitcoin network. A limited language prevents the transaction validation mechanism from being used as a vulnerability.</p></div>
</div>
<div class="sect3">
<h4 id="_stateless_verification">Stateless Verification</h4>
<div class="paragraph"><p>The bitcoin transaction script language is stateless, in that there is no state prior to execution of the script, or state saved after execution of the script. Therefore, all the information needed to execute a script is contained within the script. A script will predictably execute the same way on any system. If your system verifies a script, you can be sure that every other system in the bitcoin network will also verify the script, meaning that a valid transaction is valid for everyone and everyone knows this. This predictability of outcomes is an essential benefit of the bitcoin system.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="std_tx">Transazioni Standard</h3>
<div class="paragraph"><p>In the first few years of bitcoin&#8217;s development, the developers introduced some limitations in the types of scripts that could be processed by the reference client. These limitations are encoded in a function called <tt>isStandard()</tt>, which defines five types of "standard" transactions. These limitations are temporary and might be lifted by the time you read this. Until then, the five standard types of transaction scripts are the only ones that will be accepted by the reference client and most miners who run the reference client. Although it is possible to create a nonstandard transaction containing a script that is not one of the standard types, you must find a miner who does not follow these limitations to mine that transaction into a block.</p></div>
<div class="paragraph"><p>Controlla il codice sorgente del client Bitcoin Core (l&#8217;implementazione di riferimento) per controllare cos'è attualmente consentito come script di transazione valido.</p></div>
<div class="paragraph"><p>The five standard types of transaction scripts are pay-to-public-key-hash (P2PKH), public-key, multi-signature (limited to 15 keys), pay-to-script-hash (P2SH), and data output (OP_RETURN), which are described in more detail in the following sections.</p></div>
<div class="sect3">
<h4 id="p2pkh">Pay-to-Public-Key-Hash (P2PKH)</h4>
<div class="paragraph"><p>The vast majority of transactions processed on the bitcoin network are P2PKH transactions. These contain a locking script that encumbers the output with a public key hash, more commonly known as a bitcoin address. Transactions that pay a bitcoin address contain P2PKH scripts. An output locked by a P2PKH script can be unlocked (spent) by presenting a public key and a digital signature created by the corresponding private key.</p></div>
<div class="paragraph"><p>For example, let&#8217;s look at Alice&#8217;s payment to Bob&#8217;s Cafe again. Alice made a payment of 0.015 bitcoin to the cafe&#8217;s bitcoin address. That transaction output would have a locking script of the form:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>OP_DUP OP_HASH160 &lt;Cafe Public Key Hash&gt; OP_EQUAL OP_CHECKSIG</tt></pre>
</div></div>
<div class="paragraph"><p>The <tt>Cafe Public Key Hash</tt> is equivalent to the bitcoin address of the cafe, without the Base58Check encoding. Most applications would show the <em>public key hash</em> in hexadecimal encoding and not the familiar bitcoin address Base58Check format that begins with a "1".</p></div>
<div class="paragraph"><p>Il locking script precedente può essere soddisfatto dall&#8217;unlocking script nella forma:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt;</tt></pre>
</div></div>
<div class="paragraph"><p>I due script insieme andrebbero a formare il seguente script di validazione combinato:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Cafe Signature&gt; &lt;Cafe Public Key&gt; OP_DUP OP_HASH160
&lt;Cafe Public Key Hash&gt; OP_EQUAL OP_CHECKSIG</tt></pre>
</div></div>
<div class="paragraph"><p>When executed, this combined script will evaluate to TRUE if, and only if, the unlocking script matches the conditions set by the locking script. In other words, the result will be TRUE if the unlocking script has a valid signature from the cafe&#8217;s private key that corresponds to the public key hash set as an encumbrance.</p></div>
<div class="paragraph"><p>Figures <xref linkend="P2PubKHash1" xrefstyle="select: labelnumber"/> and <xref linkend="P2PubKHash2" xrefstyle="select: labelnumber"/> show (in two parts) a step-by-step execution of the combined script, which will prove this is a valid transaction.</p></div>
<div class="imageblock" id="P2PubKHash1">
<div class="content">
<img src="images/msbt_0503.png" alt="Tx_Script_P2PubKeyHash_1" />
</div>
<div class="title">Figure 3. Valutando uno script per una transazione P2PKH (Parte 1 di 2)</div>
</div>
</div>
<div class="sect3">
<h4 id="p2pk">Pay-to-Public-Key</h4>
<div class="paragraph"><p>Pay-to-public-key is a simpler form of a bitcoin payment than pay-to-public-key-hash. With this script form, the public key itself is stored in the locking script, rather than a public-key-hash as with P2PKH earlier, which is much shorter. Pay-to-public-key-hash was invented by Satoshi to make bitcoin addresses shorter, for ease of use. Pay-to-public-key is now most often seen in coinbase transactions, generated by older mining software that has not been updated to use P2PKH.</p></div>
<div class="paragraph"><p>Uno script di locking pay-to-public-key è simile al seguente esempio:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Public Key A&gt; OP_CHECKSIG</tt></pre>
</div></div>
<div class="paragraph"><p>L&#8217;unlocking script corrispondente che deve essere presentato per sbloccare questo tipo di output è una semplice firma, come questa:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Signature from Private Key A&gt;</tt></pre>
</div></div>
<div class="paragraph"><p>Lo script combinato, che è validato dal software di validazione della transazione, è:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Signature from Private Key A&gt; &lt;Public Key A&gt; OP_CHECKSIG</tt></pre>
</div></div>
<div class="paragraph"><p>Questo script è una semplice chiamata all&#8217;operatore <tt>CHECKSIG</tt>, che valida la firma affinchè corrisponda alla chiave corretta e ritorni TRUE sullo stack.</p></div>
<div class="imageblock" id="P2PubKHash2">
<div class="content">
<img src="images/msbt_0504.png" alt="Tx_Script_P2PubKeyHash_2" />
</div>
<div class="title">Figure 4. Eseguendo uno script per una transazione P2PKH (Parte 2 di 2)</div>
</div>
</div>
<div class="sect3">
<h4 id="multisig">Multi-Firma (Multi-Signature)</h4>
<div class="paragraph"><p>Multi-signature scripts set a condition where N public keys are recorded in the script and at least M of those must provide signatures to release the encumbrance. This is also known as an M-of-N scheme, where N is the total number of keys and M is the threshold of signatures required for validation. For example, a 2-of-3 multi-signature is one where three public keys are listed as potential signers and at least two of those must be used to create signatures for a valid transaction to spend the funds. At this time, standard multi-signature scripts are limited to at most 15 listed public keys, meaning you can do anything from a 1-of-1 to a 15-of-15 multi-signature or any combination within that range. The limitation to 15 listed keys might be lifted by the time this book is published, so check the <tt>isStandard()</tt> function to see what is currently accepted by the network.</p></div>
<div class="paragraph"><p>La forma generale di uno script di locking che imposta una condizione multi&#8217;signature M-di-N è:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>M &lt;Public Key 1&gt; &lt;Public Key 2&gt; ... &lt;Public Key N&gt; N OP_CHECKMULTISIG</tt></pre>
</div></div>
<div class="paragraph"><p>dove N è il numero totale di chiavi pubbliche elencate e M è la soglia del numero di firme richiesto per spendere un output.</p></div>
<div class="paragraph"><p>Uno script di locking che imposta una condizione multi-signnature-2-su-3 assomiglia a questo:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</tt></pre>
</div></div>
<div class="paragraph"><p>Il locking script precedente può essere soddisfatto con un unlocking script contenente coppie di firme e chiavi pubbliche:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>OP_0 &lt;Signature B&gt; &lt;Signature C&gt;</tt></pre>
</div></div>
<div class="paragraph"><p>o una qualsiasi combinazione di due firme dalle chiavi private corrispondenti alle tre chiavi pubbliche elencate.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>The prefix <tt>OP_0</tt> is required because of a bug in the original implementation of <tt>CHECKMULTISIG</tt> where one item too many is popped off the stack. It is ignored by <tt>CHECKMULTISIG</tt> and is simply a placeholder.</p></div>
</td>
</tr></table>
</div>
<div class="paragraph"><p>I due script insieme formeranno uno script di validazione combinato:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>OP_0 &lt;Signature B&gt; &lt;Signature C&gt; 2 &lt;Public Key A&gt; &lt;Public Key B&gt; &lt;Public Key C&gt; 3 OP_CHECKMULTISIG</tt></pre>
</div></div>
<div class="paragraph"><p>Quando eseguito, questo script combinato ritornerà TRUE se, e solo se, lo script di unlock pareggia le condizioni impostate dallo script di lock. In questo caso, la condizione è dove lo script di unlock ha una firma valida dalle due chiavi private che corrispondono a due delle tre chiavi pubbliche impostate come impaccio (encumberance).</p></div>
</div>
<div class="sect3">
<h4 id="op_return">Data Output (OP_RETURN)</h4>
<div class="paragraph"><p>Bitcoin&#8217;s distributed and timestamped ledger, the blockchain, has potential uses far beyond payments. Many developers have tried to use the transaction scripting language to take advantage of the security and resilience of the system for applications such as digital notary services, stock certificates, and smart contracts. Early attempts to use bitcoin&#8217;s script language for these purposes involved creating transaction outputs that recorded data on the blockchain; for example, to record a digital fingerprint of a file in such a way that anyone could establish proof-of-existence of that file on a specific date by reference to that transaction.</p></div>
<div class="paragraph"><p>The use of bitcoin&#8217;s blockchain to store data unrelated to bitcoin payments is a controversial subject. Many developers consider such use abusive and want to discourage it. Others view it as a demonstration of the powerful capabilities of blockchain technology and want to encourage such experimentation. Those who object to the inclusion of non-payment data argue that it causes "blockchain bloat," burdening those running full bitcoin nodes with carrying the cost of disk storage for data that the blockchain was not intended to carry. Moreover, such transactions create UTXO that cannot be spent, using the destination bitcoin address as a free-form 20-byte field. Because the address is used for data, it doesn&#8217;t correspond to a private key and the resulting UTXO can <em>never</em> be spent; it&#8217;s a fake payment. These transactions that can never be spent are therefore never removed from the UTXO set and cause the size of the UTXO database to forever increase, or "bloat."</p></div>
<div class="paragraph"><p>In version 0.9 of the Bitcoin Core client, a compromise was reached with the introduction of the <tt>OP_RETURN</tt> operator. <tt>OP_RETURN</tt> allows developers to add 80 bytes of nonpayment data to a transaction output. However, unlike the use of "fake" UTXO, the <tt>OP_RETURN</tt> operator creates an explicitly <em>provably unspendable</em> output, which does not need to be stored in the UTXO set. <tt>OP_RETURN</tt> outputs are recorded on the blockchain, so they consume disk space and contribute to the increase in the blockchain&#8217;s size, but they are not stored in the UTXO set and therefore do not bloat the UTXO memory pool and burden full nodes with the cost of more expensive RAM.</p></div>
<div class="paragraph"><p>gli script <tt>OP_RETURN</tt> sono fatti così:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>OP_RETURN &lt;data&gt;</tt></pre>
</div></div>
<div class="paragraph"><p>The data portion is limited to 80 bytes and most often represents a hash, such as the output from the SHA256 algorithm (32 bytes). Many applications put a prefix in front of the data to help identify the application. For example, the <a href="http://proofofexistence.com">Proof of Existence</a> digital notarization service uses the 8-byte prefix "DOCPROOF," which is ASCII encoded as <tt>44f4350524f4f46</tt> in hexadecimal.</p></div>
<div class="paragraph"><p>Keep in mind that there is no "unlocking script" that corresponds to <tt>OP_RETURN</tt> that could possibly be used to "spend" an <tt>OP_RETURN</tt> output. The whole point of <tt>OP_RETURN</tt> is that you can&#8217;t spend the money locked in that output, and therefore it does not need to be held in the UTXO set as potentially spendable—<tt>OP_RETURN</tt> is <em>provably un-spendable</em>. <tt>OP_RETURN</tt> is usually an output with a zero bitcoin amount, because any bitcoin assigned to such an output is effectively lost forever. If an <tt>OP_RETURN</tt> is encountered by the script validation software, it results immediately in halting the execution of the validation script and marking the transaction as invalid. Thus, if you accidentally reference an <tt>OP_RETURN</tt> output as an input in a transaction, that transaction is invalid.</p></div>
<div class="paragraph"><p>A standard transaction (one that conforms to the <tt>isStandard()</tt> checks) can have only one <tt>OP_RETURN</tt> output. However, a single <tt>OP_RETURN</tt> output can be combined in a transaction with outputs of any other type.</p></div>
<div class="paragraph"><p>Two new command-line options have been added in Bitcoin Core as of version 0.10. The option <tt>datacarrier</tt> controls relay and mining of OP_RETURN transactions, with the default set to "1" to allow them. The option <tt>datacarriersize</tt> takes a numeric argument specifying the maximum size in bytes of the OP_RETURN data, 40 bytes by default.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph"><p>OP_RETURN was initially proposed with a limit of 80 bytes, but the limit was reduced to 40 bytes when the feature was released. In February 2015, in version 0.10 of Bitcoin Core, the limit was raised back to 80 bytes. Nodes may choose not to relay or mine OP_RETURN, or only relay and mine OP_RETURN containing less than 80 bytes of data.</p></div>
</td>
</tr></table>
</div>
</div>
<div class="sect3">
<h4 id="p2sh">Pay-to-Script-Hash (P2SH)</h4>
<div class="paragraph"><p>Pay-to-script-hash (P2SH) was introduced in 2012 as a powerful new type of transaction that greatly simplifies the use of complex transaction scripts. To explain the need for P2SH, let&#8217;s look at a practical example.</p></div>
<div class="paragraph"><p>In <a href="#ch01_intro_what_is_bitcoin">[ch01_intro_what_is_bitcoin]</a> we introduced Mohammed, an electronics importer based in Dubai. Mohammed&#8217;s company uses bitcoin&#8217;s multi-signature feature extensively for its corporate accounts. Multi-signature scripts are one of the most common uses of bitcoin&#8217;s advanced scripting capabilities and are a very powerful feature. Mohammed&#8217;s company uses a multi-signature script for all customer payments, known in accounting terms as "accounts receivable," or AR. With the multi-signature scheme, any payments made by customers are locked in such a way that they require at least two signatures to release, from Mohammed and one of his partners or from his attorney who has a backup key. A multi-signature scheme like that offers corporate governance controls and protects against theft, embezzlement, or loss.</p></div>
<div class="paragraph"><p>Lo script risultante è abbastanza lungo ed è simile a questo:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG - ( 2 &lt;Chiave Pubblica di Mohamed&gt; &lt;Chiave Pubblica Partner1&gt; &lt;Chiave Pubblica Partner 2&gt; &lt;Chiave Pubblica Partner3&gt; &lt;Chiave Pubblica del Rappresentante Legale&gt; 5 OP_CHECKMULTISIG )</tt></pre>
</div></div>
<div class="paragraph"><p>Anche se gli script multi-signature sono una funzionalità potente, sono un po difficili da usare. Dato lo script precedente, Mohammed dovrebbe comunicare lo script a ogni cliente prima di iniziare un pagamento. Ogni cliente avrebbe dovuto usare un wallet bitcoin specifico con l&#8217;abilità di creare script di transazione custom e ogni cliente avrebbe dovuto capire come creare una transazione con script custom (personalizzati). Inoltre, la transazione risultante sarà cinque volte più grande di una transazione con un semplice pagamento, perchè questo script contiene chiavi pubbliche molto lunghe. Il peso di queste transazioni extra-large andrà a gravare sull&#8217;utente sotto forma di fee. Finalmente uno script così grande dovrà essere trasferito nel set delle UTXO in RAM in ogni full node, fino a che non sarà speso. Tutte queste problematiche fanno sì che l&#8217;uso di output script complessi sarà un po meno pratico.</p></div>
<div class="paragraph"><p>Pay-to-script-hash (P2SH) was developed to resolve these practical difficulties and to make the use of complex scripts as easy as a payment to a bitcoin address. With P2SH payments, the complex locking script is replaced with its digital fingerprint, a cryptographic hash. When a transaction attempting to spend the UTXO is presented later, it must contain the script that matches the hash, in addition to the unlocking script. In simple terms, P2SH means "pay to a script matching this hash, a script that will be presented later when this output is spent."</p></div>
<div class="paragraph"><p>In P2SH transactions, the locking script that is replaced by a hash is referred to as the <em>redeem script</em> because it is presented to the system at redemption time rather than as a locking script. <a href="#without_p2sh">[without_p2sh]</a> shows the script without P2SH and <a href="#with_p2sh">[with_p2sh]</a> shows the same script encoded with P2SH.</p></div>
<div class="tableblock" id="without_p2sh">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 4. Script complessi senza P2SH</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Locking Script</p></td>
<td align="left" valign="top"><p class="table">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Unlocking Script</p></td>
<td align="left" valign="top"><p class="table">Sig1 Sig2</p></td>
</tr>
</tbody>
</table>
</div>
<div class="tableblock" id="with_p2sh">
<table rules="all"
width="100%"
frame="border"
cellspacing="0" cellpadding="4">
<caption class="title">Table 5. Complex script come P2SH</caption>
<col width="50%" />
<col width="50%" />
<tbody>
<tr>
<td align="left" valign="top"><p class="table">Script di Riscatto</p></td>
<td align="left" valign="top"><p class="table">2 PubKey1 PubKey2 PubKey3 PubKey4 PubKey5 5 OP_CHECKMULTISIG</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Locking Script</p></td>
<td align="left" valign="top"><p class="table">OP_HASH160 &lt;20-byte hash dello script di riscatto&gt; OP_EQUAL</p></td>
</tr>
<tr>
<td align="left" valign="top"><p class="table">Unlocking Script</p></td>
<td align="left" valign="top"><p class="table">Sig1 Sig2 dello script di riscatto</p></td>
</tr>
</tbody>
</table>
</div>
<div class="paragraph"><p>As you can see from the tables, with P2SH the complex script that details the conditions for spending the output (redeem script) is not presented in the locking script. Instead, only a hash of it is in the locking script and the redeem script itself is presented later, as part of the unlocking script when the output is spent. This shifts the burden in fees and complexity from the sender to the recipient (spender) of the transaction.</p></div>
<div class="paragraph"><p>Osserviamo la ditta di Mohammed, lo script multi-signature complesso, e i risultanti script P2SH.</p></div>
<div class="paragraph"><p>Per primo, lo script multi-signature che la ditta di Mohammed usa per tutti i pagementi in entrata dai clienti:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2 &lt;Mohammed's Public Key&gt; &lt;Partner1 Public Key&gt; &lt;Partner2 Public Key&gt; &lt;Partner3 Public Key&gt; &lt;Attorney Public Key&gt; 5 OP_CHECKMULTISIG - ( 2 &lt;Chiave Pubblica di Mohamed&gt; &lt;Chiave Pubblica Partner1&gt; &lt;Chiave Pubblica Partner 2&gt; &lt;Chiave Pubblica Partner3&gt; &lt;Chiave Pubblica del Rappresentante Legale&gt; 5 OP_CHECKMULTISIG )</tt></pre>
</div></div>
<div class="paragraph"><p>Se i placeholder sono rimpiazzati con chiavi pubbliche reali (mostrati qui come numeri di 520-bit che iniziano con 04) noterai che lo script diverrà molto lungo:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>2
04C16B8698A9ABF84250A7C3EA7EEDEF9897D1C8C6ADF47F06CF73370D74DCCA01CDCA79DCC5C395D7EEC6984D83F1F50C900A24DD47F569FD4193AF5DE762C58704A2192968D8655D6A935BEAF2CA23E3FB87A3495E7AF308EDF08DAC3C1FCBFC2C75B4B0F4D0B1B70CD2423657738C0C2B1D5CE65C97D78D0E34224858008E8B49047E63248B75DB7379BE9CDA8CE5751D16485F431E46117B9D0C1837C9D5737812F393DA7D4420D7E1A9162F0279CFC10F1E8E8F3020DECDBC3C0DD389D99779650421D65CBD7149B255382ED7F78E946580657EE6FDA162A187543A9D85BAAA93A4AB3A8F044DADA618D087227440645ABE8A35DA8C5B73997AD343BE5C2AFD94A5043752580AFA1ECED3C68D446BCAB69AC0BA7DF50D56231BE0AABF1FDEEC78A6A45E394BA29A1EDF518C022DD618DA774D207D137AAB59E0B000EB7ED238F4D800 5 OP_CHECKMULTISIG</tt></pre>
</div></div>
<div class="paragraph"><p>Lo script per intero può invece essere rappresentato da un hash crittografico di 20-byte, applicando in principio l&#8217;algoritmo di hashing SHA256 e infine l&#8217;algoritmo RIPEMD160 sul risultato. L&#8217;hash di 20-byte dello script precedente è:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>54c557e07dde5bb6cb791c7a540e0a4796f5e97e</tt></pre>
</div></div>
<div class="paragraph"><p>Una transazione P2SH blocca l&#8217;output a questo hash invece dello script più lungo, usando lo script di unlock:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>OP_HASH160 54c557e07dde5bb6cb791c7a540e0a4796f5e97e OP_EQUAL</tt></pre>
</div></div>
<div class="paragraph"><p>che, come potete vedere, è più corto. Invece di "pagare a questo script a 5-chiavi", la transazione P2SH equivalente è "paga a uno script con questo hash." Un cliente che effettua un pagamento alla ditta di Mohammed deve includere solamente questo script di locking molto più breve nel proprio pagamento. Quando Mohammed vuole spendere questo UTXO, essi devono presentare lo script originale di riscatto (coloro che hanno protetto/firmato l&#8217;UTXO) e la firma necessaria per sbloccarlo, come la seguente:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Sig1&gt; &lt;Sig2&gt; &lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt;</tt></pre>
</div></div>
<div class="paragraph"><p>I due script sono combinati in due fasi. Nella prima, lo script di riscatto è comparato contro lo script di locking per essere sicuro che l&#8217;hash combaci:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG&gt; OP_HASH160 &lt;scriptHash di riscatto&gt; OP_EQUAL</tt></pre>
</div></div>
<div class="paragraph"><p>Se l&#8217;hash dello script di riscatto combacia, lo script di unlock è eseguito da solo, per sbloccare lo script di riscatto:</p></div>
<div class="listingblock">
<div class="content">
<pre><tt>&lt;Sig1&gt; &lt;Sig2&gt; 2 PK1 PK2 PK3 PK4 PK5 5 OP_CHECKMULTISIG</tt></pre>
</div></div>
<div class="sect4">
<h5 id="_indirizzi_pay_to_script_hash">Indirizzi Pay-to-script-hash</h5>
<div class="paragraph"><p>Another important part of the P2SH feature is the ability to encode a script hash as an address, as defined in BIP0013. P2SH addresses are Base58Check encodings of the 20-byte hash of a script, just like bitcoin addresses are Base58Check encodings of the 20-byte hash of a public key. P2SH addresses use the version prefix "5", which results in Base58Check-encoded addresses that start with a "3". For example, Mohammed&#8217;s complex script, hashed and Base58Check-encoded as a P2SH address becomes <tt>39RF6JqABiHdYHkfChV6USGMe6Nsr66Gzw</tt>. Now, Mohammed can give this "address" to his customers and they can use almost any bitcoin wallet to make a simple payment, as if it were a bitcoin address. The 3 prefix gives them a hint that this is a special type of address, one corresponding to a script instead of a public key, but otherwise it works in exactly the same way as a payment to a bitcoin address.</p></div>
<div class="paragraph"><p>Gli indirizzi P2SH nascondono tutta la complessità, di modo che la persona che effettua il pagamento non veda lo script.</p></div>
</div>
<div class="sect4">
<h5 id="_benefici_del_pay_to_script_hash">Benefici del pay-to-script-hash</h5>
<div class="paragraph"><p>The pay-to-script-hash feature offers the following benefits compared to the direct use of complex scripts in locking outputs:</p></div>
<div class="ulist"><ul>
<li>
<p>
Script complessi sono rimpiazzati da fingerprint più corti nell&#8217;output di transazione, rendendo la transazione più piccola.
</p>
</li>
<li>
<p>
Gli script possono essere codificati come un&#8217;indirizzo, in questo modo il mittente e al wallet del mittente non serve un codice complesso per implementare P2SH.
</p>
</li>
<li>
<p>
P2SH sposta l&#8217;onere di costruzione dello script sul ricevente, non sul mittente.
</p>
</li>
<li>
<p>
P2SH shifts the burden in data storage for the long script from the output (which is in the UTXO set) to the input (stored on the blockchain).
</p>
</li>
<li>
<p>
P2SH shifts the burden in data storage for the long script from the present time (payment) to a future time (when it is spent).
</p>
</li>
<li>
<p>
P2SH shifts the transaction fee cost of a long script from the sender to the recipient, who has to include the long redeem script to spend it.
</p>
</li>
</ul></div>
</div>
<div class="sect4">
<h5 id="_redeem_script_and_isstandard_validation">Redeem script and isStandard validation</h5>
<div class="paragraph"><p>Prior to version 0.9.2 of the Bitcoin Core client, pay-to-script-hash was limited to the standard types of bitcoin transaction scripts, by the <tt>isStandard()</tt> function. That means that the redeem script presented in the spending transaction could only be one of the standard types: P2PK, P2PKH, or multi-sig nature, excluding <tt>OP_RETURN</tt> and P2SH itself.</p></div>
<div class="paragraph"><p>As of version 0.9.2 of the Bitcoin Core client, P2SH transactions can contain any valid script, making the P2SH standard much more flexible and allowing for experimentation with many novel and complex types of transactions.</p></div>
<div class="paragraph"><p>Note that you are not able to put a P2SH inside a P2SH redeem script, because the P2SH specification is not recursive. You are also still not able to use <tt>OP_RETURN</tt> in a redeem script because <tt>OP_RETURN</tt> cannot be redeemed by definition.</p></div>
<div class="paragraph"><p>Note that because the redeem script is not presented to the network until you attempt to spend a P2SH output, if you lock an output with the hash of an invalid transaction it will be processed regardless. However, you will not be able to spend it because the spending transaction, which includes the redeem script, will not be accepted because it is an invalid script. This creates a risk, because you can lock bitcoin in a P2SH that cannot be spent later. The network will accept the P2SH encumbrance even if it corresponds to an invalid redeem script, because the script hash gives no indication of the script it represents.</p></div>
<div class="exampleblock">
<div class="content">
<div class="paragraph"><p>P2SH locking scripts contain the hash of a redeem script, which gives no clues as to the content of the redeem script itself. The P2SH transaction will be considered valid and accepted even if the redeem script is invalid. You might accidentally lock bitcoin in such a way that it cannot later be spent.</p></div>
</div></div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2015-07-15 16:57:51 UTC
</div>
</div>
</body>
</html>
